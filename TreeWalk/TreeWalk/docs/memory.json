{ "topic":"二元樹最短路徑演算法與快取策略", "steps":[ "需求:輸入字串建樹(level-order,空字串=空子樹),輸入source/destination,找最短路徑與方向", "策略A:預先BFS建所有點對最短路徑;優化1.NextHopMatrix(儲存下一步節點),2.NextDirectionMatrix(第一步方向),3.NextDirection+DistanceMatrix(方向+距離)", "策略B:LCA(Lowest Common Ancestor)用Binary Lifting,O(N logN)建表,O(logN+距離)查詢", "討論:是否需區分U成UL/UR,最後決定統一U;快取是否用Dictionary?結論:生產要用FrozenDictionary/Immutable+IMemoryCache+Lazy避免stampede,必要時Redis分散式", "測試:設計多案例(簡單小樹,不對稱含空子樹,深度10 zigzag,完全滿樹1023節點),驗證距離與路徑正確性,反向路徑對稱性(J->A輸出9個U)", "Benchmark:深度10滿樹(1023節點),Build:NextHop~52ms/60MB,NextDir~46ms/59MB,NextDir+Dist~49ms/60MB,LCA~0.08ms/0.27MB;Query:NextHop最快(~100-160ns),LCA稍慢(~200-275ns),NextDir系列較慢(~270-340ns)", "結論:NextHop適合固定樹且查詢超多,缺點耗記憶體;LCA適合樹會更新或記憶體有限,查詢稍慢但足夠快;NextDir+Dist僅在只查距離情境有價值", "最終輸出:Mermaid流程圖(依樹是否固定/記憶體/查詢需求選策略)" ] }