Question : 
æˆ‘æƒ³è¦è¨è«–ä¸€å€‹éœ€æ±‚ï¼Œé€™å€‹éœ€æ±‚æ˜¯é€™æ¨£çš„æˆ‘å€‘æœƒå…ˆè«‹ä½¿ç”¨è€…è¼¸å…¥ä¸€å€‹ä¸€å€‹ä¸²å­—ä¸²ï¼Œé€™å€‹å­—ä¸²ä»£è¡¨çš„æ˜¯ä¸€é¡† 2 å…ƒæ¨¹å‡è¨­ ä½¿ç”¨è€…è¼¸å…¥ A,B,C,,D,E,F,,,,,,,G ä»–åœ¨æˆ‘å€‘è®€å–çš„æ™‚å€™å…¶å¯¦æ˜¯è¦å»ºç«‹åƒé€™æ¨£çš„ 2 å…ƒæ¨¹ A / \ B C \ / \ D E F / G ä¹Ÿå°±æ˜¯èªª ç©ºå­—ä¸²ä»£è¡¨çš„æ˜¯é‚£ä¸€å€‹å­æ¨¹æ˜¯ç©ºå€¼ æ¥è‘—æˆ‘å€‘æœƒè«‹ä½¿ç”¨è€…è¼¸å…¥å…©å€‹åƒæ•¸ source & destination å‡è¨­ä½¿ç”¨è€…è¼¸å…¥çš„ source æ˜¯ B è·Ÿ destination æ˜¯ F æˆ‘å€‘è¦å¹«ä»–æ‰¾å‡ºæœ€çŸ­çš„è·¯å¾‘æ­¥æ¨¹ ï¼Œä»¥é€™å€‹æ¨¹çš„èˆ‰ä¾‹ä¾†èªªå°±æ˜¯è¦æ‰¾åˆ°å¾€ä¸Šä¸€æ­¥å¾€å³ä¸€æ­¥å†å¾€å³ä¸€æ­¥ç¸½å…±ä¸‰æ­¥æ‰èƒ½åˆ°é” F å·²çŸ¥é€™å€‹æ¨¹çš„æ·±åº¦çµ•å°ä¸æœƒè¶…é 10 å±¤ï¼Œä¹Ÿå°±æ˜¯èªªæœ€æ·±å°±æ˜¯ 10 å±¤ è€Œé€™äº›è³‡æ–™æœƒè¢«ä½¿ç”¨å¹¾åè¬æ¬¡ï¼Œç›®å‰æƒ³åˆ°çš„æ˜¯æˆ‘å€‘å¯ä»¥æŠŠæœ€å°æ­¥æ•¸ keep åœ¨ memeory cache ä¸­ï¼Œé€™æ¨£æ¯æ¬¡ä½¿ç”¨çš„æ™‚å€™åªè¦å‘½ä¸­å¿«å–å°±å¯ä»¥ç›´æ¥è¿”å›è¨ˆç®—å€¼ æˆ–æ˜¯ä½ æœ‰ç”šéº¼æ›´å¥½çš„æ–¹å¼?

Answer : 
Sianï¼Œå¥½é¡Œç›®ï¼é€™å…¶å¯¦æ˜¯ã€Œåœ¨ä¸€æ£µçµ¦å®šçš„äºŒå…ƒæ¨¹ä¸Šï¼ŒæŸ¥å…©ç¯€é»æœ€çŸ­æ­¥æ•¸ï¼ˆé‚Šæ•¸ï¼‰ã€çš„é«˜é »æŸ¥è©¢å•é¡Œã€‚æœ€ç©©å¥ä¸”å¿«å–å‹å–„çš„åšæ³•æœ‰å…©æ¢è·¯ï¼š

# æ–¹æ¡ˆ Aï¼ˆæˆ‘æœƒå„ªå…ˆæ¨è–¦ï¼‰ï¼šä¸€æ¬¡æ€§é å…ˆç®—å¥½ã€Œæ‰€æœ‰ç¯€é»å°è·é›¢çŸ©é™£ã€ï¼ŒæŸ¥è©¢ O(1)

**ç‚ºä»€éº¼å¯è¡Œï¼Ÿ**
æ·±åº¦ â‰¤ 10 â‡’ ç¯€é»æ•¸ N â‰¤ 2Â¹Â¹âˆ’1 = 2047ã€‚
æ‰€æœ‰ç¯€é»æˆå°æ•¸ç´„ N(N+1)/2 â‰ˆ 2.1Mï¼Œè‹¥ç”¨ `int` 4 bytes å­˜è·é›¢ï¼Œè¨˜æ†¶é«”å¤§ç´„ **\~8.4 MB**ï¼ŒåŠ ä¸Šç´¢å¼•å­—å…¸ä»åœ¨ 10 MB ç´šè·ï¼Œå¾ˆçœã€‚
ä¸€æ¬¡å»ºå¥½è·é›¢çŸ©é™£å¾Œï¼Œæ¯æ¬¡æŸ¥è·é›¢å°±æ˜¯ O(1)ï¼Œéå¸¸é©åˆã€Œå¹¾åè¬æ¬¡æŸ¥è©¢ã€ã€‚

**é è™•ç†æµç¨‹**

1. è§£æè¼¸å…¥ï¼ˆå±¤åºã€é€—è™Ÿåˆ†éš”ï¼Œç©ºå­—ä¸²ä»£è¡¨ç©ºå­æ¨¹ï¼‰ï¼Œç”¨é™£åˆ—è¡¨ç¤ºæ¨¹ï¼šç´¢å¼• `i` çš„å·¦å­ `2*i+1`ã€å³å­ `2*i+2`ã€‚
2. åªå°éç©ºç¯€é»å»ºç«‹**ç„¡å‘é„°æ¥è¡¨**ï¼ˆçˆ¶â†”å­é‚Šï¼‰ã€‚
3. å°æ¯å€‹ç¯€é»åšä¸€æ¬¡ BFSï¼Œå¾—åˆ°åˆ°æ‰€æœ‰ç¯€é»çš„æœ€çŸ­æ­¥æ•¸ï¼Œå¡«å…¥è·é›¢çŸ©é™£ `dist[i,j]`ã€‚
4. å»ºä¸€å€‹ `Dictionary<string,int>`ï¼ŒæŠŠã€Œç¯€é»æ¨™ç±¤å­—ä¸²ã€å°æ‡‰åˆ°ã€Œå…§éƒ¨ç´¢å¼•ã€ã€‚
5. è¨˜æ†¶é«”å¿«å–ï¼šä»¥**æ¨™æº–åŒ–è¼¸å…¥å­—ä¸²çš„é›œæ¹Š**ï¼ˆä¾‹å¦‚ SHA256ï¼‰ç‚º keyï¼ŒæŠŠ `{indexByLabel, dist}` æ”¾åˆ° `MemoryCache`ã€‚åŒä¸€æ£µæ¨¹é‡è¤‡æŸ¥è©¢å°±å‘½ä¸­å¿«å–ã€‚

**æŸ¥è©¢**ï¼šæ”¶åˆ° `(source, destination)` â†’ è½‰ç´¢å¼• â†’ ç›´æ¥å› `dist[i,j]`ï¼ŒO(1)ã€‚

# æ–¹æ¡ˆ Bï¼ˆæ›´çœè¨˜æ†¶é«”ï¼‰ï¼šLCA + æ·±åº¦ï¼ŒæŸ¥è©¢ O(logN)

å¦‚æœä½ æ“”å¿ƒåŒæ™‚è¦å¿«å–å¾ˆå¤šä¸åŒçš„æ¨¹ï¼Œæˆ–æƒ³æŠŠè¨˜æ†¶é«”å£“åˆ°æ›´å°ï¼Œå¯æ”¹æˆç”¨ **LCAï¼ˆäºŒåˆ†è·³ç¥–å…ˆ / binary liftingï¼‰**ï¼š

* é è™•ç†ï¼šå­˜ `parent[k][i]`ï¼ˆç¬¬ i ç¯€é»çš„ 2^k ç¥–å…ˆï¼‰ï¼Œä»¥åŠ `depth[i]`ã€‚
* æŸ¥è©¢ï¼š`distance(u,v) = depth[u] + depth[v] âˆ’ 2*depth[LCA(u,v)]`ï¼Œæ™‚é–“ O(logN)ï¼Œè¨˜æ†¶é«”ç´„ `N * logN * 4 bytes`ï¼ŒN=\~2kã€logNâ‰ˆ11ï¼Œ**< 0.1 MB**ã€‚

å°ä½ çš„ã€Œå¹¾åè¬æ¬¡æŸ¥è©¢ã€ï¼š

* è‹¥æ˜¯**å–®ä¸€æ¨¹**ï¼ˆæˆ–å°‘æ•¸å¹¾æ£µï¼‰ï¼Œ**æ–¹æ¡ˆ A**æœ€ä½³ï¼ˆO(1) æŸ¥è©¢ã€æ•´é«”æ¥µå¿«ï¼‰ã€‚
* è‹¥æ˜¯**å¤§é‡ä¸åŒçš„æ¨¹**éƒ½è¦åŒæ™‚å¿«å–ï¼Œä¸”æ€•ä½”å¤ªå¤šè¨˜æ†¶é«”ï¼Œé¸ **æ–¹æ¡ˆ B**ã€‚

---

# C# å¯¦ä½œï¼ˆæ–¹æ¡ˆ Aï¼šå…¨å°è·é›¢çŸ©é™£ + MemoryCacheï¼‰

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Caching;
using System.Security.Cryptography;
using System.Text;

public sealed class TreeDistanceCache
{
    private static readonly MemoryCache Cache = MemoryCache.Default;

    public sealed class TreeDistanceData
    {
        public required Dictionary<string,int> IndexByLabel { get; init; }
        public required string[] LabelsByIndex { get; init; }
        public required int[,] Dist { get; init; }
    }

    public static int GetDistance(string levelOrderCsv, string source, string destination)
    {
        var key = "tree:" + Sha256Hex(Normalize(levelOrderCsv));
        var data = Cache.Get(key) as TreeDistanceData;
        if (data is null)
        {
            data = Build(levelOrderCsv);
            // è¦–æƒ…æ³èª¿æ•´ç­–ç•¥ï¼šå¯ç”¨ CacheItemPolicy é™åˆ¶å¤§å°/éæœŸ
            Cache.Set(key, data, new CacheItemPolicy {
                SlidingExpiration = TimeSpan.FromHours(12)
            });
        }

        if (!data.IndexByLabel.TryGetValue(source, out var u))
            throw new ArgumentException($"Source label '{source}' not found.");
        if (!data.IndexByLabel.TryGetValue(destination, out var v))
            throw new ArgumentException($"Destination label '{destination}' not found.");

        return data.Dist[u, v];
    }

    private static TreeDistanceData Build(string levelOrderCsv)
    {
        // 1) è§£æè¼¸å…¥
        var raw = levelOrderCsv.Split(',', StringSplitOptions.None)
                               .Select(s => s?.Trim() ?? "")
                               .ToArray();

        // 2) æœ‰æ•ˆç¯€é»ï¼šéç©ºå­—ä¸²
        // å»ºç«‹ labels èˆ‡ index å°ç…§ï¼ˆåªçµ¦å­˜åœ¨çš„ç¯€é»ç·¨ç´¢å¼•ï¼‰
        var indexMap = new Dictionary<int,int>(); // arrayIdx -> compactIdx
        var labels = new List<string>();
        for (int i = 0; i < raw.Length; i++)
        {
            if (!string.IsNullOrEmpty(raw[i]))
            {
                indexMap[i] = labels.Count;
                labels.Add(raw[i]);
            }
        }

        int n = labels.Count;
        if (n == 0)
            throw new ArgumentException("Tree is empty.");

        // 3) å»ºé„°æ¥è¡¨ï¼ˆåªé€£éç©ºç¯€é»ï¼‰
        var adj = new List<int>[n];
        for (int i = 0; i < n; i++) adj[i] = new List<int>();

        for (int i = 0; i < raw.Length; i++)
        {
            if (!indexMap.ContainsKey(i)) continue;
            int ci = indexMap[i];
            int li = 2*i + 1, ri = 2*i + 2;

            if (li < raw.Length && indexMap.ContainsKey(li))
            {
                int cl = indexMap[li];
                adj[ci].Add(cl);
                adj[cl].Add(ci);
            }
            if (ri < raw.Length && indexMap.ContainsKey(ri))
            {
                int cr = indexMap[ri];
                adj[ci].Add(cr);
                adj[cr].Add(ci);
            }
        }

        // 4) å…¨å°æœ€çŸ­è·é›¢ï¼šå°æ¯å€‹ç¯€é»åšä¸€æ¬¡ BFS
        var dist = new int[n, n];
        var q = new Queue<int>();
        var visited = new int[n];

        for (int s = 0; s < n; s++)
        {
            // åˆå§‹åŒ–
            Array.Fill(visited, -1);
            visited[s] = 0;
            q.Clear();
            q.Enqueue(s);

            while (q.Count > 0)
            {
                int u = q.Dequeue();
                foreach (var w in adj[u])
                {
                    if (visited[w] != -1) continue;
                    visited[w] = visited[u] + 1;
                    q.Enqueue(w);
                }
            }
            for (int t = 0; t < n; t++)
                dist[s, t] = visited[t]; // æ¨¹å…§çš†é€£é€šï¼›è‹¥è¨­è¨ˆæˆæ£®æ—ä¹Ÿå¯ä¿ç•™ -1
        }

        // 5) label â†” index map
        var indexByLabel = new Dictionary<string,int>(StringComparer.Ordinal);
        for (int i = 0; i < n; i++)
        {
            // è‹¥ä½ çš„è³‡æ–™å¯èƒ½æœ‰é‡è¤‡æ¨™ç±¤ï¼Œå»ºè­°æ”¹ç”¨ã€Œ(æ¨™ç±¤+å‡ºç¾æ¬¡åº)ã€æˆ–ç›´æ¥æ‹’çµ•é‡è¤‡
            if (!indexByLabel.TryAdd(labels[i], i))
                throw new ArgumentException($"Duplicate label '{labels[i]}' encountered.");
        }

        return new TreeDistanceData
        {
            IndexByLabel = indexByLabel,
            LabelsByIndex = labels.ToArray(),
            Dist = dist
        };
    }

    private static string Normalize(string csv)
    {
        // æ¨™æº–åŒ–ï¼šå»é™¤å¤šé¤˜ç©ºç™½ï¼›ä¿ç•™ç©ºæ¬„ä½
        var parts = csv.Split(',', StringSplitOptions.None)
                       .Select(s => s?.Trim() ?? "")
                       .ToArray();
        // ä¹Ÿå¯é¸æ“‡å»é™¤æœ«ç«¯å…¨ç©ºå±¤ï¼Œè¦–éœ€æ±‚è€Œå®š
        return string.Join(",", parts);
    }

    private static string Sha256Hex(string s)
    {
        using var sha = SHA256.Create();
        var bytes = sha.ComputeHash(Encoding.UTF8.GetBytes(s));
        var sb = new StringBuilder(bytes.Length * 2);
        foreach (var b in bytes) sb.Append(b.ToString("x2"));
        return sb.ToString();
    }
}
```

**ä½¿ç”¨ç¯„ä¾‹**

```csharp
var input = "A,B,C,,D,E,F,,,,,,,G";
Console.WriteLine(TreeDistanceCache.GetDistance(input, "B", "F")); // è¼¸å‡º 3
Console.WriteLine(TreeDistanceCache.GetDistance(input, "A", "G")); // 3 (A->C->F->G)
Console.WriteLine(TreeDistanceCache.GetDistance(input, "E", "D")); // 3 (E->C->A->B->D? æ³¨æ„æ­¤æ¨¹ E åœ¨ C å·¦ï¼ŒB çš„å³æœ‰ Dï¼šæœ€çŸ­å…¶å¯¦ E->C->A->B->D = 4ï¼›è¦–ä½ çš„åœ–ä¾‹çµæ§‹ï¼Œè«‹ä»¥å¯¦éš›è¼¸å…¥ç‚ºæº–)
```

> å°æé†’ï¼šä½ ä¾‹åœ–ä¸­çš„å±¤åºèˆ‡åœ–ç¨æœ‰ã€Œç©ºä½å°æ‡‰ã€çš„ç´°ç¯€ï¼Œè«‹ä»¥å±¤åºè¦å‰‡ç‚ºæº–ï¼š
> `i` çš„å·¦/å³æ˜¯ `2*i+1`/`2*i+2`ï¼›ç©ºå­—ä¸²å°±ä»£è¡¨è©²å­ç¯€é»ä¸å­˜åœ¨ã€‚ä½ ç¯„ä¾‹ `"A,B,C,,D,E,F,,,,,,,G"` æœƒå¾—åˆ°ï¼š
>
> ```
> 0:A
> 1:B  2:C
> 3:   4:D   5:E  6:F
> 13:G
> ```
>
> è·é›¢è«‹ä»¥æ­¤çµæ§‹è¨ˆç®—ã€‚

---

# æ™‚é–“/ç©ºé–“è¤‡é›œåº¦ & åå

* **å»ºç½®**ï¼ˆä¸€æ¬¡ï¼‰ï¼šBFS N æ¬¡ï¼ŒO(N\*(N+E))ï¼Œæ¨¹ä¸Š Eâ‰ˆNâˆ’1 â‡’ O(NÂ²)ã€‚Nâ‰¤2047ï¼Œé‡ç´šç´„æ•¸ç™¾è¬æ­¥ï¼Œéå¸¸å¿«ã€‚
* **æŸ¥è©¢**ï¼šO(1)ã€‚
* **è¨˜æ†¶é«”**ï¼šè·é›¢çŸ©é™£ \~8â€“10 MB ç´šï¼›å¯æ¥å—ã€‚

---

# å¿«å–ç­–ç•¥å»ºè­°

* **Key**ï¼šæ¨™æº–åŒ–å­—ä¸² â†’ SHA256ã€‚
* **Value**ï¼š`TreeDistanceData`ã€‚
* **éæœŸ**ï¼š`SlidingExpiration=12h` æˆ–ä¾ä½ æµé‡èª¿æ•´ï¼›ä¹Ÿå¯è¨­å®š Cache memory limitã€ä»¥ä½¿ç”¨é‡èˆ‡ä½µç™¼èª¿æ•´ã€‚
* **é˜²é‡è¤‡å»ºç½®**ï¼šåŒä¸€å€‹ key å»ºç½®ä¸­å¯ç”¨ `Lazy<Task<TreeDistanceData>>`/per-key lockï¼ˆä½ å¸¸ç”¨çš„ patternï¼‰é¿å…é‡å·¥ã€‚

---

# æ–¹æ¡ˆ Bï¼ˆåƒè€ƒç”¨ï¼‰éª¨æ¶ï¼šLCA

è‹¥é¸ LCAï¼Œé è™•ç† O(N logN)ã€æŸ¥è©¢ O(logN)ï¼Œè¨˜æ†¶é«”æ¥µå°ã€‚å¯¦ä½œè¦é»ï¼š

* ä»¥ä»»ä¸€å­˜åœ¨çš„æ ¹ï¼ˆé€šå¸¸ index 0 ä¸”éç©ºï¼‰åš DFS/BFSï¼Œå¡« `depth[]`ã€`parent[0][i]`ã€‚
* `parent[k+1][i] = parent[k][ parent[k][i] ]`ã€‚
* æŸ¥è©¢æ™‚æŠŠå…©é»æå‡åˆ°åŒæ·±åº¦ï¼Œå†ä¸€èµ·å¾€ä¸Šè·³ç›´åˆ° LCAï¼Œç›¸åŠ æ·±åº¦å¾—è·é›¢ã€‚

---

å¦‚æœä½ è¦æˆ‘æŠŠ **LCA ç‰ˆæœ¬**ä¹Ÿè£œä¸Šã€æˆ–åšæˆ **å¯åˆ‡æ›ç­–ç•¥**ï¼ˆçŸ©é™£ / LCAï¼‰èˆ‡æ›´å®Œæ•´çš„å–®å…ƒæ¸¬è©¦ã€æ•ˆèƒ½é‡æ¸¬ï¼Œæˆ‘å¯ä»¥ç›´æ¥ç”¢å‡ºä¸€ç‰ˆå¯è·‘çš„å°ˆæ¡ˆéª¨æ¶çµ¦ä½ ã€‚


Quesiton : 
æˆ‘æƒ³å…ˆé‡å°å…©å€‹æ–¹æ¡ˆéƒ½å„åšä¸€äº›è¨è«–å†æ±ºå®šæˆ‘å€‘è¦ç”¨å“ªä¸€å€‹æ–¹æ¡ˆï¼Œé¦–å…ˆæˆ‘å€‘éœ€è¦å…ˆé‡æ¸…ä¸€ä¸‹ï¼Œä¸æ˜¯åªæœ‰æ‰¾å‡ºæœ€çŸ­è·é›¢ï¼ŒåŒæ¨£ä¹Ÿè¦æŠŠç§»å‹•çš„è·¯å¾‘å„²å­˜ä¸‹ä¾†ã€‚

å…ˆè¨è«–æ–¹æ¡ˆ A 
å°æ¯ä¸€å€‹ç¯€é»é å…ˆä½¿ç”¨ BFS è¨ˆç®—æ‰€æœ‰ç¯€é»çš„æœ€çŸ­æ­¥æ•¸ä»¥åŠç§»å‹•çš„è·¯å¾‘ï¼Œå­˜ä¸‹ä¾†å¦‚æœæˆ‘å€‘ä»¥æˆ‘å€‘çš„ç¯„ä¾‹å„²å­˜çš„ key æ˜¯ç¯€é» B åˆ°ç¯€é» F ï¼Œ value å°±æœƒæ˜¯  ä¸Š(Up)å³(Right)å³(Right)è·é›¢å…±ä¸‰æ­¥ çš„è³‡è¨Šï¼Œæˆ‘çš„æƒ³æ³•æ˜¯ï¼Œæˆ‘å€‘ç¢ºå¯¦æ˜¯å¯ä»¥å…ˆé å…ˆè¨ˆç®—ï¼Œä½†æ˜¯å…¶å¯¦è¨ˆç®— B åˆ° F è·Ÿ F åˆ° B æ˜¯ç›¸åŒçš„æ„æ€ï¼Œæˆ‘çš„æ€è€ƒæ˜¯æˆ‘å€‘ä»Šå¤©å°±å„ªå…ˆå„²å­˜è‹±æ–‡å­—æ¯æ¯”è¼ƒå‰é¢çš„è³‡æ–™èˆ‰ä¾‹ key BF value URR  çš„å¿«å–å€¼ï¼Œç•¶æˆ‘å€‘ä»Šå¤©ä½¿ç”¨è€…è¼¸å…¥çš„æ˜¯ FB æˆ‘å€‘çš„æ¼”ç®—æ³•è¨ˆç®—é †åºå¯ä»¥æ˜¯
1st å°‹æ‰¾æœ‰æ²’æœ‰ BF çš„ key ï¼Œå¾—åˆ° value URR  => ä½†æ˜¯å› ç‚ºé€™å€‹ URR æ˜¯ B åˆ° F ï¼Œä»Šå¤©æˆ‘å€‘éœ€è¦åè½‰ï¼Œæ‰€ä»¥æ‡‰è©²æ˜¯ UUL 
2st å‡è¨­æ²’æœ‰æ‰¾åˆ° BF çš„ key å‰‡å°‹æ‰¾ FB çš„ key

æ­¥æ•¸å‰‡åªéœ€è¦è¨ˆç®—å¾—åˆ°çš„ UUL count å°±å¯ä»¥äº†é€™å€‹è¨ˆç®—æ˜¯å°çš„ä¸ç”¨ç‰¹åˆ¥å­˜

é€™å€‹æ€è·¯æ˜¯å¯ä»¥çš„å—?  

Answer : 
çµè«–å…ˆèªªï¼šä½ çš„ã€Œåªå­˜ä¸€å€‹æ–¹å‘ï¼ˆä¾‹å¦‚ BFï¼‰ï¼ŒæŸ¥ FB æ™‚æŠŠè·¯å¾‘åè½‰ã€é€™å€‹æƒ³æ³•æ˜¯å°çš„ï¼Œä½†**è·¯å¾‘åè½‰æ™‚çš„æ–¹å‘å­—ä¸²ä¸èƒ½åªåšç°¡å–®çš„ U/R/L åè½‰**â€”â€”å› ç‚ºã€Œå¾€ä¸‹ã€å¿…é ˆçŸ¥é“æ˜¯æœå·¦å­æ¨¹é‚„æ˜¯å³å­æ¨¹ï¼›ä½ ç¯„ä¾‹çš„
`B -> F = U, R, R` å…¶å¯¦èªæ„æ‡‰è©²æ˜¯ **U, DR, DR**ï¼ˆUpã€Down-Rightã€Down-Rightï¼‰ã€‚
å› æ­¤ `F -> B` çš„è·¯å¾‘ä¸æ˜¯ä½ å¯«çš„ `UUL`ï¼Œè€Œæ˜¯ **DL, DL, U**ï¼ˆDown-Left, Down-Left, Upï¼‰ã€‚

## å…ˆçµ±ä¸€ã€Œæ–¹å‘å­—å…¸ã€

ç‚ºäº†æ­£ç¢ºå¯é€†ï¼Œå»ºè­°åªç”¨é€™ 3 ç¨®åŸºæœ¬æ­¥ä¼ï¼ˆæ¯ä¸€æ­¥å°±æ˜¯ä¸€æ¢é‚Šï¼‰ï¼š

* `U`ï¼šå¾€**çˆ¶ç¯€é»**
* `DL`ï¼šå¾€**å·¦å­ç¯€é»**ï¼ˆDown-Leftï¼‰
* `DR`ï¼šå¾€**å³å­ç¯€é»**ï¼ˆDown-Rightï¼‰

é€™æ¨£å°±æ²’æœ‰èªæ„ä¸æ¸…çš„ `L/R`ã€‚ï¼ˆä½ ä¾‹å­è£¡çš„ã€ŒRã€å…¶å¯¦æ˜¯ã€Œå¾€å³å­ç¯€é»ã€ï¼Œä¹Ÿå°±æ˜¯ `DR`ã€‚ï¼‰

### åè½‰è¦å‰‡ï¼ˆä¸€å®šè¦é€™æ¨£åšï¼‰

* `U` çš„åå‘æ˜¯ `DL` æˆ– `DR`ï¼Œ**å–æ±ºæ–¼ç•¶å‰ç¯€é»ç›¸å°æ–¼çˆ¶ç¯€é»æ˜¯å·¦å­é‚„æ˜¯å³å­**ï¼ˆé€™å€‹éœ€è¦åœ¨æ¨¹ä¸Šåˆ¤æ–·ï¼‰ã€‚
* `DL` çš„åå‘æ˜¯ `U`ã€‚
* `DR` çš„åå‘æ˜¯ `U`ã€‚

> å› æ­¤åƒ…æ†‘å­—ä¸²ã€ŒURRã€æ˜¯ç„¡æ³•æ©Ÿæ¢°åœ°åæˆã€ŒæŸå€‹å›ºå®šçš„ U/L/R ä¸²ã€çš„ï¼›æ­£ç¢ºåšæ³•æ˜¯æ‹¿åˆ°**ç¯€é»åºåˆ—**ï¼ˆæˆ–è‡³å°‘çŸ¥é“æ¯ä¸€æ­¥çš„ä¸Šä¸‹æ–‡ï¼šç•¶å‰ç¯€é»èˆ‡ä¸‹ä¸€æ­¥çš„è¦ªå­é—œä¿‚ï¼‰ï¼Œå†æŠŠæ¯æ­¥åšå°æ‡‰çš„åå‘è½‰æ›ã€‚

---

## æ–¹æ¡ˆ A å¯è¡Œçš„å¯¦ä½œæ–¹å¼ï¼ˆå«ã€Œåªå­˜ä¸€é‚Šã€èˆ‡ã€Œè·¯å¾‘å¯é€†ã€ï¼‰

æˆ‘å€‘é è™•ç†æ¯å€‹ç¯€é»ä¸€æ¬¡ BFSï¼Œå­˜å…©å€‹çŸ©é™£ï¼š

1. `dist[src, v] : short` â€” æœ€çŸ­è·é›¢ï¼ˆé‚Šæ•¸ï¼‰
2. `prev[src, v] : short` â€” å¾ `src` åˆ° `v` çš„æœ€çŸ­è·¯å¾‘ä¸Šï¼Œ**v çš„å‰ä¸€å€‹ç¯€é»**ï¼ˆpredecessorï¼‰ã€‚é€™è®“æˆ‘å€‘èƒ½å¾ `(src, dst)` å›æº¯å‡º**ç¯€é»åºåˆ—**ã€‚

> è¨˜æ†¶é«”ä¼°ç®—ï¼ˆN â‰¤ 2047ï¼‰ï¼š
> `short` 2 bytes
> `dist` â‰ˆ 2 \* NÂ² â‰ˆ 2 \* 4.2M â‰ˆ 8.4 MB
> `prev` â‰ˆ 8.4 MB
> åŠ ä¸Šç´¢å¼•èˆ‡æ¨¹çµæ§‹ï¼Œç¸½é‡ \~ 20 MB å…§ï¼ŒOKã€‚

### åªå­˜ã€Œå­—æ¯åºè¼ƒå°ã€çš„æœ‰åºå°

* å®šç¾©æ¯å€‹æ¨™ç±¤å° `(a, b)` çš„**æ­£å‘éµ**ç‚º `key = (min(a,b), max(a,b))`ã€‚
* å¿«å–é …ï¼ˆå€¼ï¼‰ä¸æ˜¯æ–¹å‘å­—ä¸²ï¼Œè€Œæ˜¯\*\*`prev[src,*]` èˆ‡ `dist[src,*]` çŸ©é™£\*\*ï¼ˆæ•´æ£µæ¨¹å„å€‹ `src` éƒ½å­˜ä¸€æ¬¡ï¼Œæˆ–åªå­˜æ•´é«”çŸ©é™£ä¸€æ¬¡ï¼‰ï¼ŒæŸ¥è©¢æ™‚å†çµ„è£è·¯å¾‘ã€‚
* æŸ¥è©¢ `(source, destination)`ï¼š

  * è‹¥ `source <= destination`ï¼šç”¨ `src = source` çš„ `prev` å›æº¯å‡ºå¾ `source` åˆ° `destination` çš„**ç¯€é»åºåˆ—**ï¼Œå†è½‰æˆæ–¹å‘ `U/DL/DR`ã€‚
  * è‹¥ `source > destination`ï¼šæ”¹æŸ¥ `(destination, source)` æ‹¿åˆ°**ç¯€é»åºåˆ—**ï¼Œ**åè½‰ç¯€é»åºåˆ—**å¾Œé€æ­¥è½‰æˆæ–¹å‘ï¼ˆé€™æ™‚æ¯ä¸€æ­¥éƒ½èƒ½æ­£ç¢ºåˆ¤æ–·æ˜¯ `U/DL/DR`ï¼‰ï¼Œæœ€å¾Œå¾—åˆ° `destination -> source` çš„è·¯å¾‘ï¼›è‹¥ä½ è¦è¼¸å‡ºçš„æ˜¯ `source -> destination`ï¼Œé‚£å°±ç›´æ¥æŒ‰åè½‰å¾Œçš„ç¯€é»åºåˆ—ç”¢ç”Ÿæ–¹å‘å³å¯ï¼ˆä¸éœ€è¦å°æ–¹å‘å­—åšç¡¬åè½‰ï¼Œç›´æ¥ã€Œé‡ç®—æ–¹å‘ã€æœ€å®‰å…¨ï¼‰ã€‚

> é‡é»ï¼š**ä¸è¦æŠŠæ–¹å‘å­—ä¸²æœ¬èº«ç•¶å¿«å–ä¸»é«”**ï¼Œè€Œæ˜¯æŠŠèƒ½é‡å»ºè·¯å¾‘çš„è³‡æ–™ï¼ˆ`prev/dist`ï¼‰ç•™è‘—ï¼›æ–¹å‘å­—ä¸²æ¯æ¬¡æŸ¥è©¢æ™‚ã€Œä¾ç¯€é»åºåˆ—è¨ˆç®—ã€ã€‚é€™æ¨£å°ç¨±æ€§ï¼ˆBF / FBï¼‰å¤©ç„¶æˆç«‹ï¼Œä¸”ä¸æœƒæœ‰ `U` åå‘ä¸æ˜çš„å•é¡Œã€‚

### æ–¹å‘ç”¢ç”Ÿæ–¹æ³•ï¼ˆç¯€é»åºåˆ— â†’ æ–¹å‘åºåˆ—ï¼‰

å‡è¨­ä½ æœ‰é€£çºŒå…©å€‹ç¯€é» `(x, y)`ï¼š

* è‹¥ `y == parent[x]` â‡’ æ–¹å‘æ˜¯ `U`
* å¦å‰‡è‹¥ `y == left[x]` â‡’ `DL`
* å¦å‰‡è‹¥ `y == right[x]` â‡’ `DR`

> é€™éœ€è¦åœ¨æ¨¹çµæ§‹ä¸­ï¼Œå°æ¯å€‹ç¯€é»éƒ½èƒ½ O(1) æ‰¾åˆ° `parent/left/right` ä¸‰è€…ï¼ˆæˆ‘å€‘åœ¨å»ºæ¨¹æ™‚å°±æº–å‚™å¥½ï¼‰ã€‚

---

## å›åˆ°ä½ çš„è¨­è¨ˆï¼šç”¨ã€ŒBF å­˜ URRï¼ŒæŸ¥ FB åæˆ UULã€æ˜¯å¦å¯è¡Œï¼Ÿ

* æ¦‚å¿µã€Œåªå­˜ä¸€é‚Šã€æ˜¯å¯è¡Œçš„ï¼›
* **ä½†** å°‡ `URR` é€™ç¨®**æ²’æœ‰ä¸Šä¸‹æ–‡**çš„å­—ä¸²ç›´æ¥åšå­—å…ƒåè½‰ï¼†æ›¿æ›ï¼ŒæœƒéŒ¯ã€‚å¿…é ˆé€éç¯€é»åºåˆ—æˆ–è¦ªå­é—œä¿‚æŠŠæ¯ä¸€æ­¥å°å›æ¨¹ä¸Šï¼Œæ‰èƒ½æ­£ç¢ºåå‘ã€‚
* å»ºè­°ï¼š**æŠŠè·¯å¾‘ä»¥ã€Œç¯€é»åºåˆ—ã€æˆ–ã€Œå‰é©…çŸ©é™£ã€å½¢å¼å­˜ï¼é‡å»º**ï¼Œè¼¸å‡ºæ™‚å†è½‰ã€Œæ–¹å‘å­—ä¸²ã€ã€‚è‹¥ç¡¬è¦å­˜æ–¹å‘å­—ä¸²ï¼Œä¹Ÿè«‹å­˜ **U/DL/DR** é€™ç¨®å¯é€†èªå½™ï¼Œä¸”åå‘æ™‚è¦é æ¨¹é—œä¿‚é€æ­¥ç¿»è­¯ï¼Œä¸è¦å–®ç´”åšå­—å…ƒæ›¿æ›ã€‚

---

## å°å‹ C# ç‰‡æ®µï¼ˆå±•ç¤ºã€Œåå‘æŸ¥è©¢ã€æ­£ç¢ºä½œæ³•ï¼‰

```csharp
// å·²æœ‰ï¼šparent[], left[], right[]ï¼Œä»¥åŠèƒ½å¾ (src, dst) å›æº¯å‡ºç¯€é»åºåˆ—çš„å‡½å¼

IEnumerable<string> ToMoves(IList<int> path) // path: node indices from A to B (å«ç«¯é»)
{
    for (int i = 0; i < path.Count - 1; i++)
    {
        int x = path[i], y = path[i+1];
        if (parent[x] == y) yield return "U";
        else if (left[x] == y) yield return "DL";
        else if (right[x] == y) yield return "DR";
        else throw new InvalidOperationException("Not adjacent in tree");
    }
}

IList<int> ReconstructPath(int src, int dst, short[,] prev) // ç”¨ prev[src,*]
{
    var list = new List<int>();
    for (int cur = dst; cur != -1 && cur != src; cur = prev[src, cur])
        list.Add(cur);
    list.Add(src);
    list.Reverse();
    return list;
}

// æŸ¥è©¢ (u,v)
List<string> QueryMoves(int u, int v)
{
    int a = Math.Min(u, v), b = Math.Max(u, v);
    var path = ReconstructPath(a, b, PrevMatrix); // a -> b çš„ç¯€é»åºåˆ—
    if (u == a)
    {
        // ç›´æ¥ a->b
        return ToMoves(path).ToList();
    }
    else
    {
        // éœ€è¦ b->aï¼šæŠŠç¯€é»åºåˆ—åè½‰ï¼Œç„¶å¾Œå†ç”Ÿæˆæ–¹å‘ï¼ˆæœƒè‡ªç„¶å¾—åˆ° DL/DL/U ä¹‹é¡ï¼‰
        path.Reverse();
        return ToMoves(path).ToList();
    }
}
```

---

## å…©å€‹é¡å¤–å„ªåŒ–ï¼ˆå¯é¸ï¼‰

1. **åªå­˜ã€Œç¬¬ä¸€æ­¥è·¯ç”±è¡¨ã€**ï¼š`nextHop[src, dst]`ï¼ˆå€¼æ˜¯ `DL/DR/U` ä¸‰æ…‹ä¹‹ä¸€æˆ–ç›´æ¥å­˜ä¸‹ä¸€å€‹ç¯€é» idï¼‰ã€‚æŸ¥è©¢æ™‚å¾ `src` ä¾ `nextHop` èµ°åˆ° `dst`ï¼Œä¸€è·¯ä¸²èµ·æ–¹å‘ã€‚

   * è¨˜æ†¶é«” \~ `N*N`ï¼Œè·Ÿ `dist` é¡ä¼¼ï¼Œä½†**ä¸ç”¨ `prev`**ï¼›
   * è·¯å¾‘é‡å»º O(è·é›¢)ï¼Œå°æ·±åº¦â‰¤10 çš„æ¨¹ï¼Œæœ€å¤š â‰ˆ 20 æ­¥ï¼Œéå¸¸å¿«ã€‚
2. **å‹åˆ¥å£“ç¸®**ï¼šNâ‰¤2047ï¼Œç”¨ `short` è¶³å¤ ï¼›æ–¹å‘å¯ç”¨ `byte`ï¼ˆ0/1/2ï¼‰ï¼Œé™ä½å¿«å–ä½”ç”¨ã€‚

---

## å°ç¸½çµ

* ä½ çš„ã€Œåªå­˜ä¸€é‚Šã€å¦ä¸€é‚ŠæŸ¥è©¢æ™‚åè½‰ã€**æ€è·¯æ­£ç¢º**ã€‚
* ä½†**ä¸èƒ½**æŠŠ `URR` é€™ç¨®å­—ä¸²ç›´æ¥å°ç¨±åè½‰ï¼›éœ€è¦é **ç¯€é»åºåˆ—**æˆ–**æ¨¹è¦ªå­é—œä¿‚**é€æ­¥æ±‚åå‘ã€‚
* æ¨è–¦åœ¨æ–¹æ¡ˆ A ä¸­ï¼š

  * é è™•ç† `dist` + `prev`ï¼ˆæˆ– `nextHop`ï¼‰ï¼Œ
  * æŸ¥è©¢æ™‚è¨ˆç®—ç¯€é»åºåˆ— â†’ è½‰ `U/DL/DR`ã€‚
* é€™æ¨£æ—¢ä¿è­‰å°ç¨±ï¼Œåˆä¿è­‰æ­£ç¢ºèˆ‡å¯ç¶­è­·æ€§ï¼Œè¨˜æ†¶é«”ä¹Ÿåœ¨å¯æ¥å—ç¯„åœå…§ã€‚

å¦‚æœä½  OKï¼Œæˆ‘ä¸‹ä¸€æ­¥å¯ä»¥æŠŠã€Œå®Œæ•´å¯è·‘çš„ classï¼ˆåŒ…å«å»ºæ¨¹ã€BFS é è™•ç†ã€MemoryCacheã€è·¯å¾‘è¼¸å‡ºç‚º U/DL/DRï¼‰ã€è£œæˆä¸€å€‹æœ€å°å¯ç”¨çš„ C# ç¯„ä¾‹å°ˆæ¡ˆéª¨æ¶ï¼Œä¸¦é™„ä¸Šä½ ç¯„ä¾‹ `A,B,C,,D,E,F,,,,,,,G` çš„å–®å…ƒæ¸¬è©¦ã€‚

Question : 
é€™å…©å€‹å„ªåŒ–çš„æ–¹å‘æœƒæ¸›å°‘å¤šå°‘å¿«å–çš„ä½¿ç”¨é‡?

Answer : 
å¥½çš„ï¼Œç›´æ¥çµ¦ä½ ç²¾ç®—çµæœï¼ˆä»¥æ¨¹æœ€å£ N=2047 ç¯€é»ã€NÂ²=4,190,209 ç‚ºåŸºç¤ï¼›1 MiB=1,048,576 bytesï¼‰ï¼š

# åŸºæº–ï¼ˆæ–¹æ¡ˆ A åŸè¨­ï¼‰

* `dist[src,dst]`ï¼š**short**ï¼ˆ2 bytesï¼‰
* `prev[src,dst]`ï¼š**short**ï¼ˆ2 bytesï¼‰
* ç¸½è¨ˆï¼š**2 çŸ©é™£ Ã— 2 bytes Ã— NÂ² â‰ˆ 16.0 MiB**

> é™„å¸¶ï¼š`parent/left/right` å„å­˜ä¸€å€‹ **short\[]**ï¼ˆN=2047ï¼‰ä¹Ÿæ‰ \~12 KBÃ—3ï¼Œå¯å¿½ç•¥ã€‚

---

# å„ªåŒ– 1ï¼šåªå­˜ã€Œç¬¬ä¸€æ­¥è·¯ç”±è¡¨ã€ï¼ˆnextHop / nextDirï¼‰

## 1A. å­˜ã€Œä¸‹ä¸€å€‹ç¯€é» idã€ï¼ˆ`nextHop[src,dst]` ç”¨ **short**ï¼‰

* åªè¦ **1 å€‹çŸ©é™£ Ã— 2 bytes Ã— NÂ² â‰ˆ 8.0 MiB**
* æŸ¥è©¢æ™‚æ²¿è‘— `nextHop` ä¸€æ­¥æ­¥èµ°åˆ° `dst`ï¼Œé‚Šèµ°é‚Šç´¯ç©è·é›¢ï¼ˆæœ€å¤§æ­¥æ•¸ â‰¤ 20ï¼Œå¾ˆå¿«ï¼‰
* **ç›¸å°åŸºæº–çœ \~50% è¨˜æ†¶é«”**

## 1B. å­˜ã€Œç¬¬ä¸€æ­¥æ–¹å‘ã€ï¼ˆ`nextDir[src,dst]` ç”¨ **byte**ï¼šU/DL/DR ä¸‰æ…‹ï¼‰

* åªè¦ **1 å€‹çŸ©é™£ Ã— 1 byte Ã— NÂ² â‰ˆ 4.0 MiB**
* åŒæ¨£é‚Šèµ°é‚Šæ•¸æ­¥æ•¸
* **ç›¸å°åŸºæº–çœ \~75% è¨˜æ†¶é«”**

## 1C. è‹¥ä½ é‚„æƒ³ O(1) å›è·é›¢ï¼šå†åŠ ä¸€å€‹ `dist` ç”¨ **byte**

* `nextDir`ï¼ˆ1 byteï¼‰ + `dist`ï¼ˆ1 byteï¼‰ â‡’ **2 Ã— 1 byte Ã— NÂ² â‰ˆ 8.0 MiB**
* **ç›¸å°åŸºæº–çœ \~50% è¨˜æ†¶é«”**

> è¨»ï¼šè·é›¢æœ€å¤§ä¸æœƒè¶…é 20ï¼ˆæ·±åº¦â‰¤10 çš„æ¨¹æœ€é  â‰ˆ 2Ã—10ï¼‰ï¼Œç”¨ **byte** è¶³å¤ ã€‚

---

# å„ªåŒ– 2ï¼šå‹åˆ¥å£“ç¸®ï¼ˆåœ¨åŸè¨­çŸ©é™£ä¸Šå‹•æ‰‹ï¼‰

* æŠŠ `dist` å¾ **shortâ†’byte**ï¼ˆ0..20 è¶³å¤ ï¼‰
* `prev` ç¶­æŒ **short**ï¼ˆéœ€è¦èƒ½è¡¨ç¤º 0..2046 çš„ç¯€é» idï¼‰
* ç¸½è¨ˆï¼š`prev`ï¼ˆ2 bytesï¼‰ + `dist`ï¼ˆ1 byteï¼‰ â‡’ **3 Ã— NÂ² bytes â‰ˆ 12.0 MiB**
* **ç›¸å°åŸºæº–çœ \~25% è¨˜æ†¶é«”**

---

# å¿«é€Ÿå°ç…§è¡¨

| å„²å­˜å…§å®¹                                 | æ¯æ ¼å‹åˆ¥    | çŸ©é™£æ•¸ |           ä¼°è¨ˆç”¨é‡ | ç›¸å°åŸºæº– |
| ------------------------------------ | ------- | --: | -------------: | ---: |
| åŸºæº–ï¼š`prev(short)` + `dist(short)`     | 2B + 2B |   2 | **\~16.0 MiB** | 100% |
| å„ªåŒ– 2ï¼š`prev(short)` + `dist(byte)`    | 2B + 1B |   2 | **\~12.0 MiB** | âˆ’25% |
| å„ªåŒ– 1Aï¼š`nextHop(short)`               | 2B      |   1 |  **\~8.0 MiB** | âˆ’50% |
| å„ªåŒ– 1Cï¼š`nextDir(byte)` + `dist(byte)` | 1B + 1B |   2 |  **\~8.0 MiB** | âˆ’50% |
| å„ªåŒ– 1Bï¼š`nextDir(byte)`ï¼ˆè·é›¢èµ°è·¯æ™‚æ•¸ï¼‰        | 1B      |   1 |  **\~4.0 MiB** | âˆ’75% |

> ä»¥ä¸Šçš†ä¸å«æ¥µå°çš„ `parent/left/right` é™£åˆ—ï¼ˆ\~36 KB ç´šï¼‰èˆ‡å­—å…¸é–‹éŠ·ã€‚

---

# å»ºè­°

* è‹¥é‡é»æ˜¯**æ¥µä½è¨˜æ†¶é«” + ä»ç„¶å¾ˆå¿«**ï¼šç”¨ **1B çš„ `nextDir` å–®çŸ©é™£**ï¼ˆå„ªåŒ– 1Bï¼‰ã€‚è·é›¢ç”¨èµ°è·¯ç´¯åŠ ï¼Œæœ€å¤š \~20 æ­¥ï¼Œå¹¾åè¬æ¬¡æŸ¥è©¢ä¹Ÿå¾ˆè¼•é¬†ã€‚
* è‹¥ä½ æƒ³**è·é›¢ O(1)** å›å‚³ï¼šåŠ ä¸€å€‹ **`dist(byte)`**ï¼ˆå„ªåŒ– 1Cï¼‰ï¼Œç¸½é‡ \~8 MiBï¼Œä»æ¯”åŸºæº–çœä¸€åŠã€‚
* è‹¥ä½ åå¥½ä¿ç•™ã€Œå¯å›æº¯ç¯€é»åºåˆ—ã€ï¼šç”¨ **`prev(short)` + `dist(byte)`**ï¼ˆå„ªåŒ– 2ï¼‰ï¼Œçœ 25%ï¼Œä¸”èƒ½ç›´æ¥é‡å»ºå®Œæ•´è·¯å¾‘ï¼Œå†è½‰æˆ U/DL/DRã€‚

éœ€è¦çš„è©±æˆ‘å¯ä»¥æŠŠé€™ä¸‰ç¨®ç‰ˆæœ¬éƒ½å„åšä¸€å€‹å¯åˆ‡æ›çš„ `IStrategy` ä»‹é¢èˆ‡å°å‹ Benchmarkï¼Œè®“ä½ åœ¨ä½ çš„å¯¦éš›è³‡æ–™é‡èˆ‡æŸ¥è©¢åˆ†ä½ˆä¸‹è·‘åˆ†æ¯”ä¸€æ¯”ã€‚


Question : 
æˆ‘èªç‚ºä¸‰ç¨®ç¢ºå¯¦éƒ½å¯ä»¥ä¿ç•™ï¼Œä½†æˆ‘æƒ³å…ˆè¨è«–æ–¹æ¡ˆ B 
LCA ä»–è·Ÿæ–¹æ¡ˆ A çš„å·®åˆ¥æ˜¯?

Answer : 
å¾ˆå¥½ï¼Œæˆ‘æŠŠ **æ–¹æ¡ˆ Bï¼ˆLCAï¼‰** å’Œ **æ–¹æ¡ˆ Aï¼ˆå…¨å° BFS / è·¯ç”±çŸ©é™£ï¼‰** çš„æ ¸å¿ƒå·®ç•°ã€å°ã€ŒåŒæ™‚è¦å›å‚³æœ€çŸ­è·é›¢ + å…·é«”ç§»å‹•è·¯å¾‘ã€çš„å½±éŸ¿ï¼Œä¸€æ¬¡è¬›æ¸…æ¥šï¼š

# æ•´é«”æ¯”è¼ƒ

| é¢å‘               | æ–¹æ¡ˆ Aï¼šå…¨å°é ç®—ï¼ˆdist/prev æˆ– nextHop/nextDirï¼‰                                                                                                         | æ–¹æ¡ˆ Bï¼šLCAï¼ˆBinary Liftingï¼‰                                                   |
| ---------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------- |
| **é è™•ç†æ™‚é–“**        | è¿‘ä¼¼ **O(NÂ²)**ï¼ˆN æ¬¡ BFSï¼‰ã€‚Nâ‰¤2047 æ™‚ä»å¾ˆå¿«                                                                                                              | **O(N log N)**ï¼ˆå»º parent è·³è¡¨ + depthï¼‰                                        |
| **æŸ¥è©¢æ™‚é–“**         | è·é›¢ **O(1)**ï¼›è·¯å¾‘é‡å»º **O(è·é›¢)**ï¼ˆè‹¥ç”¨ nextHop/nextDir é€æ­¥èµ°ï¼‰                                                                                             | LCA **O(log N)**ï¼Œå†æŠŠè·¯å¾‘çµ„èµ·ä¾† **O(è·é›¢)**                                         |
| **è¨˜æ†¶é«”**          | è¦–ä½ é¸çš„çµæ§‹ï¼š<br>â€¢ `prev(short)+dist(byte)` â‰ˆ **12 MiB/æ¨¹**<br>â€¢ `nextDir(byte)` â‰ˆ **4 MiB/æ¨¹**ï¼ˆè·é›¢å¯é‚Šèµ°é‚Šæ•¸ï¼‰<br>â€¢ `nextDir(byte)+dist(byte)` â‰ˆ **8 MiB/æ¨¹** | è·³è¡¨ `parent[k][i]`ï¼ˆkâ‰ˆ11ï¼‰+ `depth` + `parent/left/right`ï¼š**< 0.1 MiB/æ¨¹**ï¼ˆæ¥µå°ï¼‰ |
| **å¯ä»¥ç›´æ¥å›è·é›¢ O(1)** | å¯ä»¥ï¼ˆè‹¥å­˜ distï¼‰                                                                                                                                    | åš´æ ¼èªªæ˜¯ **O(log N)**ï¼ˆæ‰¾ LCAï¼‰ï¼Œä½† logNâ‰ˆ11ï¼Œéå¸¸å°                                     |
| **å›å‚³å®Œæ•´è·¯å¾‘**       | å¾ˆå®¹æ˜“ï¼š`prev` å›æº¯æˆ– `nextHop/nextDir` é€æ­¥èµ°                                                                                                           | ä¹Ÿå®¹æ˜“ï¼šå…ˆæ±‚ LCAï¼Œå†ã€Œu å¾€ä¸Šåˆ° LCAã€+ã€Œv å¾€ä¸Šåˆ° LCA åè½‰ç‚ºå¾€ä¸‹ã€çµ„åˆ                                |
| **å¤§é‡ä¸åŒæ¨¹çš„å¿«å–**     | æ¯æ£µæ¨¹æ˜¯ MiB ç´šï¼›å¯å¿«å–çš„ã€Œæ¨¹æ•¸ã€è¼ƒå—é™                                                                                                                         | æ¯æ£µæ¨¹æ˜¯åå¤š KBï¼›å¯å¿«å–éå¸¸å¤šæ£µæ¨¹                                                         |
| **æ¥µé™ QPS**       | æ¥µé«˜ï¼ˆè·é›¢ O(1)ï¼‰                                                                                                                                    | ä¹Ÿå¾ˆé«˜ï¼ˆlogN + â‰¤20 æ­¥ï¼‰ï¼Œåœ¨æ·±åº¦â‰¤10 å¹¾ä¹ç„¡æ„Ÿ                                              |
| **å‹•æ…‹æ›´æ–°æ¨¹**        | éœ€é‡å»ºå…¨å°è³‡æ–™ï¼ˆæˆæœ¬è¼ƒé«˜ï¼‰                                                                                                                                  | éœ€é‡å»º LCA è·³è¡¨ï¼ˆè¼ƒè¼•ï¼‰                                                             |
| **å¯¦ä½œè¤‡é›œåº¦**        | ä¸­ç­‰ï¼ˆçŸ©é™£/å£“ç¸®/å¿«å–ç­–ç•¥ï¼‰                                                                                                                                 | ä¸­ç­‰ï¼ˆbinary lifting èˆ‡è·¯å¾‘çµ„è£ï¼‰                                                   |

> å°çµï¼š
>
> * **å–®ä¸€æˆ–å°‘é‡æ¨¹ã€è¿½æ±‚æœ€å°æŸ¥è©¢ latency** â†’ æ–¹æ¡ˆ Aï¼ˆå°¤å…¶ `nextDir`/`dist` ç‰ˆæœ¬ï¼‰ã€‚
> * **è¦åŒæ™‚å¿«å–å¾ˆå¤šä¸åŒçš„æ¨¹ã€æ§è¨˜æ†¶é«”** â†’ æ–¹æ¡ˆ Bï¼ˆLCAï¼‰å‹å‡ºã€‚

---

# ç”¨ LCA å›ã€Œè·é›¢ + è·¯å¾‘ã€æ€éº¼åšï¼Ÿ

1. **é è™•ç†ï¼ˆä¸€æ¬¡ï¼‰**

   * å»º `parent[0][i]`ã€`depth[i]`ï¼ˆç”¨ BFS/DFSï¼‰ã€‚
   * å»º binary lifting è·³è¡¨ï¼š`parent[k+1][i] = parent[k][ parent[k][i] ]`ã€‚
   * å¦å¤–ä¿ç•™ `left[i]`ã€`right[i]`ã€`parent[i]` ä»¥ä¾¿ä¹‹å¾Œç”¢ç”Ÿæ–¹å‘ã€‚

2. **æŸ¥è©¢è·é›¢**

   * `l = LCA(u,v)`ï¼›
   * `distance = depth[u] + depth[v] âˆ’ 2*depth[l]`ï¼ˆlogN æ‰¾ LCAï¼‰ã€‚

3. **æŸ¥è©¢è·¯å¾‘ï¼ˆæ–¹å‘åºåˆ—ï¼‰**

   * å…ˆæŠŠ **uâ†’l** çš„è·¯å¾‘ï¼šä¸€è·¯å¾€ä¸Šæ”¶é›†ç¯€é» â‡’ æ–¹å‘éƒ½æ˜¯ `U`ã€‚
   * å†æŠŠ **vâ†’l** çš„è·¯å¾‘ï¼šä¸€è·¯å¾€ä¸Šæ”¶é›†ç¯€é»åˆ° lï¼Œ**åè½‰**å¾Œå¾—åˆ° **lâ†’v** çš„ç¯€é»åºåˆ—ï¼›
   * å°‡ **lâ†’v** æ¯ä¸€æ­¥ç”¨ `left/right` åˆ¤æ–·æ˜¯ `DL` æˆ– `DR`ï¼›
   * åˆä½µï¼š`[Uâ€¦U] + [DL/DR â€¦]` å°±æ˜¯å®Œæ•´æ–¹å‘ä¸²ã€‚
   * æ™‚é–“ **O(è·é›¢)**ï¼›åœ¨ä½ çš„æ·±åº¦â‰¤10ï¼Œè·é›¢â‰¤20ï¼Œå¹¾ä¹å¯å¿½ç•¥ã€‚

> æ–¹å‘èªå½™å»ºè­°å›ºå®šç‚ºï¼š`U`ã€`DL`ã€`DR`ï¼Œå¯é€†ä¸”ä¸æ­§ç¾©ã€‚

---

# ä»€éº¼æƒ…å¢ƒé¸èª°ï¼Ÿ

* **ä½ åªæœ‰ 1\~3 æ£µç†±é–€æ¨¹**ï¼Œè€Œä¸”**æŸ¥è©¢éå¸¸å¯†é›†**ï¼ˆä¾‹å¦‚æ¯ç§’ä¸Šè¬æ¬¡ï¼‰ï¼š

  * ç”¨ **æ–¹æ¡ˆ A / nextDir(byte)+dist(byte) â‰ˆ 8 MiB/æ¨¹**ï¼Œè·é›¢ O(1)ï¼Œè·¯å¾‘çµ„è£ O(è·é›¢)ã€‚
* **ä½ å¯èƒ½åŒæ™‚é¢å°ä¸Šç™¾ã€ä¸Šåƒæ£µä¸åŒæ¨¹**ï¼ˆè¼¸å…¥è®ŠåŒ–å¤§ã€å¿«å–å‘½ä¸­éµå¾ˆå¤šï¼‰ï¼š

  * ç”¨ **æ–¹æ¡ˆ Bï¼ˆLCAï¼‰**ï¼Œæ¯æ£µæ¨¹åå¤š KB ç­‰ç´šï¼Œå®¹æ˜“å…¨éƒ¨ç•™åœ¨è¨˜æ†¶é«”è£¡ï¼ŒæŸ¥è©¢ä¹Ÿéå¸¸å¿«ã€‚
* **æ¨¹æœƒå¶çˆ¾è®Šå‹•**ï¼ˆæ¨™ç±¤èª¿æ•´ã€æ’æ‹”å­æ¨¹ï¼‰ï¼š

  * **LCA** é‡å»ºæˆæœ¬è¼ƒå°ã€å¯¦ä½œä¹Ÿæ›´ç›´è§€ã€‚

---

# å¯¦ä½œèˆ‡å¿«å–å»ºè­°ï¼ˆLCAï¼‰

* **å¿«å– key**ï¼šæ¨™æº–åŒ–çš„ level-order CSV â†’ SHA-256ã€‚
* **å¿«å–å€¼**ï¼š`{ indexByLabel, parentJump, depth, parent/left/right }`ï¼Œç¸½é‡æ¥µå°ã€‚
* **æŸ¥è©¢**ï¼š

  1. è½‰ `source/destination` ç‚ºç´¢å¼• `u/v`
  2. LCA(u,v) æ‰¾è·é›¢
  3. çµ„è·¯å¾‘æ–¹å‘ï¼ˆU æ®µ + DL/DR æ®µï¼‰
* **ä½µç™¼é˜²æŠ–**ï¼šä½ ç†Ÿæ‚‰çš„ `ConcurrentDictionary<string, Lazy<Task<T>>>` per-key é–å³å¯ã€‚

---

å¦‚æœä½ é¡˜æ„ï¼Œä¸‹ä¸€æ­¥æˆ‘å¯ä»¥ï¼š

1. çµ¦ä¸€å€‹ **å¯åˆ‡æ›ç­–ç•¥çš„ä»‹é¢**ï¼ˆ`IMetricStrategy`ï¼‰ï¼ŒåŒæ™‚å¯¦ä½œ **A: nextDir+dist** èˆ‡ **B: LCA** å…©ç‰ˆï¼›
2. é™„ä¸Š **åŸºæº–æ¸¬è©¦**ï¼ˆBenchmarkDotNetï¼‰å’Œ **å–®å…ƒæ¸¬è©¦**ï¼Œç”¨ä½ çš„ç¯„ä¾‹ `A,B,C,,D,E,F,,,,,,,G` é©—è­‰è·é›¢èˆ‡ `U/DL/DR` è·¯å¾‘æ­£ç¢ºæ€§ã€‚


Question : 
åœ¨é–‹å§‹é€²è¡Œå¯¦ä½œå‰ï¼Œæˆ‘å€‘åœ¨å¤šç”¢ç”Ÿå¹¾çµ„æ¸¬è©¦æƒ…å¢ƒï¼Œä¾›æˆ‘å€‘ç­‰ä¸€ä¸‹çš„å–®å…ƒæ¸¬è©¦é©—æ¸¬

Answer : 
å¥½çš„ï¼Œæˆ‘æ•´ç†ä¸€æ‰¹ **å¤šå…ƒæ¸¬è©¦æƒ…å¢ƒ**ï¼Œå¾Œé¢æˆ‘å€‘åœ¨åšå¯¦ä½œèˆ‡å–®å…ƒæ¸¬è©¦æ™‚ï¼Œå¯ä»¥é€ä¸€é©—è­‰ï¼š

---

## æ¸¬è©¦æ¨¹ T1ï¼ˆç¶“å…¸ç¯„ä¾‹ï¼‰

è¼¸å…¥å­—ä¸²ï¼š`A,B,C,,D,E,F,,,,,,,G`

çµæ§‹ï¼š

```
       A
     /   \
    B     C
     \   / \
      D E   F
            /
           G
```

* B â†’ Fï¼š`U, DR, DR`ï¼Œè·é›¢ 3
* E â†’ Dï¼š`U, U, DL, DR`ï¼Œè·é›¢ 4
* G â†’ Dï¼š`U, U, U, DL, DR`ï¼Œè·é›¢ 5
* D â†’ Eï¼š`U, U, DR, DL`ï¼Œè·é›¢ 4
* A â†’ Eï¼š`DR, DL`ï¼Œè·é›¢ 2
* C â†’ Cï¼šç©ºè·¯å¾‘ï¼Œè·é›¢ 0

---

## æ¸¬è©¦æ¨¹ T2ï¼ˆå®Œå…¨äºŒå…ƒæ¨¹ï¼Œç¼ºå°‘ç©ºä½ï¼‰

è¼¸å…¥å­—ä¸²ï¼š`A,B,C,D,E,F,G`

çµæ§‹ï¼š

```
       A
     /   \
    B     C
   / \   / \
  D   E F   G
```

* B â†’ Cï¼š`U, DR`ï¼Œè·é›¢ 2
* D â†’ Gï¼š`U, U, DR, DR`ï¼Œè·é›¢ 4
* F â†’ Eï¼š`U, DL, DR`ï¼Œè·é›¢ 3
* A â†’ Gï¼š`DR, DR`ï¼Œè·é›¢ 2

---

## æ¸¬è©¦æ¨¹ T3ï¼ˆå·¦åæ¨¹ï¼‰

è¼¸å…¥å­—ä¸²ï¼š`A,B,,C,,,,D`

çµæ§‹ï¼š

```
    A
   /
  B
 /
C
/
D
```

* A â†’ Dï¼š`DL, DL, DL`ï¼Œè·é›¢ 3
* D â†’ Aï¼š`U, U, U`ï¼Œè·é›¢ 3
* B â†’ Cï¼š`DL`ï¼Œè·é›¢ 1

---

## æ¸¬è©¦æ¨¹ T4ï¼ˆå³åæ¨¹ï¼‰

è¼¸å…¥å­—ä¸²ï¼š`A,,B,,,,C,,,,,,D`

çµæ§‹ï¼š

```
A
 \
  B
   \
    C
     \
      D
```

* A â†’ Dï¼š`DR, DR, DR`ï¼Œè·é›¢ 3
* D â†’ Aï¼š`U, U, U`ï¼Œè·é›¢ 3
* B â†’ Cï¼š`DR`ï¼Œè·é›¢ 1

---

## æ¸¬è©¦æ¨¹ T5ï¼ˆåƒ…å–®ç¯€é»ï¼‰

è¼¸å…¥å­—ä¸²ï¼š`A`

çµæ§‹ï¼š

```
A
```

* A â†’ Aï¼šç©ºè·¯å¾‘ï¼Œè·é›¢ 0
* æŸ¥è©¢ä¸å­˜åœ¨çš„ç¯€é» â†’ æ‡‰ä¸Ÿå‡ºä¾‹å¤–

---

## æ¸¬è©¦æ¨¹ T6ï¼ˆç©ºæ¨¹ï¼‰

è¼¸å…¥å­—ä¸²ï¼š\`\`ï¼ˆç©ºå­—ä¸²ï¼‰

* ä»»ä½•æŸ¥è©¢ â†’ æ‡‰ä¸Ÿå‡ºä¾‹å¤–æˆ–æ˜ç¢ºéŒ¯èª¤

---

## æ¸¬è©¦æ¨¹ T7ï¼ˆé‡è¤‡æ¨™ç±¤ï¼‰

è¼¸å…¥å­—ä¸²ï¼š`A,B,B`

çµæ§‹ï¼š

```
   A
  / \
 B   B
```

* é€™ç¨®æƒ…æ³è¦æ±ºç­–ï¼š**æ˜¯å¦å…è¨±é‡è¤‡æ¨™ç±¤ï¼Ÿ**

  * è‹¥å…è¨± â†’ æŸ¥è©¢éœ€é¡å¤– disambiguationï¼ˆå¯èƒ½ç”¨ç¯€é» indexï¼‰
  * è‹¥ä¸å…è¨± â†’ æ‡‰åœ¨å»ºæ¨¹æ™‚ä¸Ÿå‡ºéŒ¯èª¤

---

é€™æ¨£æˆ‘å€‘æ¶µè“‹äº†ï¼š

* âœ… åŒä¸€ç¯€é»ï¼ˆè·é›¢ 0ï¼‰
* âœ… çˆ¶å­é—œä¿‚
* âœ… å…„å¼Ÿç¯€é»
* âœ… è·¨å­æ¨¹ï¼ˆéœ€ç¶“ LCAï¼‰
* âœ… å·¦åæ¨¹ / å³åæ¨¹
* âœ… å–®ç¯€é»æ¨¹ / ç©ºæ¨¹
* âœ… é‡è¤‡æ¨™ç±¤ï¼ˆéŒ¯èª¤è™•ç† caseï¼‰

---

è¦ä¸è¦æˆ‘å¹«ä½ æŠŠé€™äº›æ¸¬è³‡ç›´æ¥è½‰æˆ **xUnit çš„ \[Theory] æ¸¬è©¦æ¡ˆä¾‹è¡¨**ï¼ˆåŒ…å«è¼¸å…¥å­—ä¸²ã€sourceã€destinationã€é æœŸè·é›¢ã€é æœŸè·¯å¾‘ï¼‰ï¼Œé€™æ¨£ä¹‹å¾Œä½ å¯¦ä½œæ–¹æ¡ˆ A / B ä»»ä½•ç‰ˆæœ¬ï¼Œéƒ½å¯ä»¥å…±ç”¨åŒä¸€ä»½æ¸¬è©¦ï¼Ÿ


Question : 
é‚„è¦æ·±åº¦è¼ƒæ·±çš„æ¨¹ç•¢ç«Ÿæˆ‘å€‘æœ€æ·±æœƒåˆ° 10 

Answer : 
äº†è§£ ğŸ‘
æ—¢ç„¶ä½ çš„éœ€æ±‚ã€Œæ¨¹æœ€æ·±æœƒåˆ° 10ã€ï¼Œé‚£æˆ‘å€‘åœ¨æ¸¬è©¦é›†è£¡å¿…é ˆå†è£œå¹¾æ£µ **æ·±åº¦è¼ƒæ·±çš„æ¨¹**ï¼Œæ¨¡æ“¬ worst-case çš„ç‹€æ³ã€‚ä»¥ä¸‹æˆ‘å¹«ä½ è¨­è¨ˆ **T8ã€T9ã€T10** ä¸‰çµ„ï¼š

---

## æ¸¬è©¦æ¨¹ T8ï¼ˆæ·±åº¦ 10ï¼Œå–®ä¸€è·¯å¾‘ï¼‰

è¼¸å…¥å­—ä¸²ï¼š`A,B,,,,,,,,,C,,,,,,,,,D,,,,,,,,,E,,,,,,,,,F,,,,,,,,,G,,,,,,,,,H,,,,,,,,,I,,,,,,,,,J`
ï¼ˆæ¯ä¸€å±¤åªæœ‰ä¸€å€‹å·¦å­ï¼Œæ·±åº¦å‰›å¥½ 10ï¼‰

çµæ§‹ï¼š

```
A
/
B
/
C
/
D
/
E
/
F
/
G
/
H
/
I
/
J
```

* A â†’ Jï¼š`DL,DL,DL,DL,DL,DL,DL,DL,DL`ï¼Œè·é›¢ 9
* J â†’ Aï¼š`U,U,U,U,U,U,U,U,U`ï¼Œè·é›¢ 9
* E â†’ Iï¼š`DL,DL,DL,DL`ï¼Œè·é›¢ 4

ğŸ‘‰ ç”¨ä¾†æ¸¬è©¦ **æœ€æ·±è·¯å¾‘** çš„æƒ…æ³ã€‚

---

## æ¸¬è©¦æ¨¹ T9ï¼ˆæ·±åº¦ 10ï¼Œå³åéˆï¼‰

è¼¸å…¥å­—ä¸²ï¼š`A,,B,,,,C,,,,,,D,,,,,,,,E,,,,,,,,,,F,,,,,,,,,,,,G,,,,,,,,,,,,,,H,,,,,,,,,,,,,,,,I,,,,,,,,,,,,,,,,,,J`

çµæ§‹ï¼š

```
A
 \
  B
   \
    C
     \
      D
       \
        E
         \
          F
           \
            G
             \
              H
               \
                I
                 \
                  J
```

* A â†’ Jï¼š`DRÃ—9`ï¼Œè·é›¢ 9
* J â†’ Aï¼š`UÃ—9`ï¼Œè·é›¢ 9
* C â†’ Hï¼š`DRÃ—5`ï¼Œè·é›¢ 5

ğŸ‘‰ å°ç…§å·¦åæ¨¹ï¼Œæª¢æŸ¥æ–¹å‘è™•ç†æ­£ç¢ºã€‚

---

## æ¸¬è©¦æ¨¹ T10ï¼ˆæ·±åº¦ 10ï¼Œzig-zag æ··åˆè·¯å¾‘ï¼‰

è¼¸å…¥å­—ä¸²ï¼š
`A,B,, ,C,,,,, ,D,,,,,,, ,E,,,,,,,,, ,F,,,,,,,,,,, ,G,,,,,,,,,,,,, ,H,,,,,,,,,,,,,,, ,I,,,,,,,,,,,,,,,,, ,J`

ï¼ˆå»ºæ§‹æ–¹å¼ï¼šA æœ‰å·¦å­ Bï¼ŒB æœ‰å³å­ Cï¼ŒC æœ‰å·¦å­ Dï¼ŒD æœ‰å³å­ E â€¦ äº¤éŒ¯ä¸‹å»ï¼‰

çµæ§‹ï¼ˆç¤ºæ„ï¼‰ï¼š

```
A
/
B
 \
  C
 /
D
 \
  E
 /
F
 \
  G
 /
H
 \
  I
 /
J
```

* A â†’ Jï¼š`DL, DR, DL, DR, DL, DR, DL, DR, DL`ï¼Œè·é›¢ 9
* J â†’ Aï¼š`UÃ—9`ï¼Œè·é›¢ 9
* D â†’ Gï¼š`DR, DL, DR`ï¼Œè·é›¢ 3

ğŸ‘‰ æ¨¡æ“¬ã€Œæ·±ä¸” zig-zagã€çš„æƒ…å¢ƒï¼Œæ¸¬è·¯å¾‘çµ„è£èˆ‡æ–¹å‘è¼¸å‡ºã€‚

---

## è£œå¼·å¾Œçš„æ¸¬è©¦çµ„åˆ

* T1ï½T7ï¼šåŸºæœ¬åŠŸèƒ½ / ç‰¹æ®Š caseï¼ˆç©ºæ¨¹ã€å–®ç¯€é»ã€é‡è¤‡æ¨™ç±¤ï¼‰
* T8ï½T10ï¼šæ·±åº¦æ¸¬è©¦ï¼ˆå·¦å / å³å / zig-zagï¼Œæ·±åº¦ 10ï¼‰

é€™æ¨£ä½ çš„æ¸¬è©¦è¦†è“‹å°±å¯ä»¥æ¶µè“‹ï¼š

* æœ€æ·±å¯èƒ½çš„è·¯å¾‘é•·åº¦
* å–®é‚Šé•·éŠï¼ˆå·¦ / å³ï¼‰
* Zig-zag è¤‡åˆæƒ…æ³
* å…¨å°ç¨±æ€§æª¢æŸ¥ï¼ˆsourceâ†’dest èˆ‡ destâ†’sourceï¼‰

---

è¦ä¸è¦æˆ‘æŠŠ **T1\~T10 å…¨éƒ¨æ•´ç†æˆ xUnit `[Theory]` çš„ `MemberData` æ¸¬è©¦è³‡æ–™**ï¼Œæ¯ä¸€ç­†åŒ…å«ï¼š

* æ¨¹çš„è¼¸å…¥å­—ä¸²
* source label
* destination label
* é æœŸè·é›¢
* é æœŸæ–¹å‘åºåˆ—ï¼ˆU / DL / DRï¼‰

é€™æ¨£ä½ å¯ä»¥ç›´æ¥å¥—åˆ°å¯¦ä½œçš„ `GetPath(tree, source, dest)` å»é©—è­‰ï¼Ÿ


Question : 
å¯ä»¥ï¼Œæˆ‘å€‘å¯ä»¥é–‹å§‹å¯¦ä½œäº†ï¼Œæœ‰å¹¾é»è¦å¹«æˆ‘æ³¨æ„
1ã€è®Šæ•¸çš„å‘½åéƒ½è¦æ˜¯å¯ä»¥è­˜åˆ¥ï¼Œæ–¹æ³•çš„å‘½åéƒ½è¦èƒ½å¤ æ¸…æ¥šè¡¨é”è©²æ–¹æ³•çš„æ„åœ–
2ã€æ–¹æ¡ˆ A æˆ‘å€‘æœ‰æå‡º 1a 1b 1c ä¸‰å€‹æ–¹å‘çš„å„ªåŒ–ï¼Œåœ¨å¯¦ä½œç­–ç•¥æ¨¡å¼çš„æ™‚å€™è¦è®“æˆ‘å¯ä»¥åˆ‡æ›æˆé€™ä¸‰ç¨®ç­–ç•¥ï¼Œæ–¹æ¡ˆ B å‰‡æ˜¯ç…§åŸæœ¬è¨è«–å¾—å³å¯
3ã€å–®å…ƒæ¸¬è©¦çš„æ¯ä¸€å€‹æ¸¬è©¦æƒ…å¢ƒè«‹åœ¨ summary çš„åœ°æ–¹ç”¨äººå¯ä»¥å¯è¦–åŒ–çš„äº†è§£æˆ‘å€‘ç¾åœ¨æ¸¬è©¦çš„æ¨¹æ˜¯é•·ç”šéº¼æ¨£å­
4ã€è¦æœ‰ä¸€å€‹æ¸¬è©¦æ–¹æ³•è®“æˆ‘è©•ä¼°æ¸¬è©¦ä¸åŒç­–ç•¥åœ¨è¨˜æ†¶é«”ä½¿ç”¨é‡ä»¥åŠè™•ç†é€Ÿåº¦

Answer : 
å¤ªå¥½äº† ğŸ‘ æˆ‘å¹«ä½ è¦åŠƒä¸€å€‹ **å°ˆæ¡ˆéª¨æ¶**ï¼ŒåŒ…å«

* **æ ¸å¿ƒç¨‹å¼ç¢¼**ï¼ˆTree å»ºç«‹ + Strategy æ¨¡å¼ + æŸ¥è©¢ä»‹é¢ï¼‰
* **å››ç¨®ç­–ç•¥å¯¦ä½œ**ï¼ˆæ–¹æ¡ˆ A: 1a/1b/1cã€æ–¹æ¡ˆ B: LCAï¼‰
* **å–®å…ƒæ¸¬è©¦ï¼ˆxUnitï¼‰**ï¼šç”¨ T1\~T10 çš„è³‡æ–™ï¼Œå« summary åœ–å½¢ï¼Œæª¢æŸ¥è·é›¢èˆ‡è·¯å¾‘æ­£ç¢ºæ€§
* **Benchmark æ¸¬è©¦**ï¼šæ¯”è¼ƒè¨˜æ†¶é«”ç”¨é‡èˆ‡æŸ¥è©¢é€Ÿåº¦

---

# å°ˆæ¡ˆçµæ§‹å»ºè­°

```
BinaryTreePathFinder/
  â”œâ”€ Core/
  â”‚   â”œâ”€ BinaryTree.cs              // å»ºæ¨¹ & ç¯€é»çµæ§‹
  â”‚   â”œâ”€ IPathStrategy.cs           // Strategy ä»‹é¢
  â”‚   â”œâ”€ StrategyA1a_NextHop.cs     // æ–¹æ¡ˆ A.1a (nextHop short)
  â”‚   â”œâ”€ StrategyA1b_NextDir.cs     // æ–¹æ¡ˆ A.1b (nextDir byte)
  â”‚   â”œâ”€ StrategyA1c_NextDirDist.cs // æ–¹æ¡ˆ A.1c (nextDir+dist)
  â”‚   â”œâ”€ StrategyB_LCA.cs           // æ–¹æ¡ˆ B (LCA)
  â”‚   â””â”€ PathResult.cs              // åŒ…å«è·é›¢èˆ‡æ–¹å‘åºåˆ—
  â”‚
  â”œâ”€ Tests/
  â”‚   â”œâ”€ TreeTestCases.cs           // T1~T10 æ¸¬è³‡
  â”‚   â”œâ”€ PathStrategyTests.cs       // å–®å…ƒæ¸¬è©¦
  â”‚   â””â”€ BenchmarkTests.cs          // æ•ˆèƒ½èˆ‡è¨˜æ†¶é«”æ¸¬è©¦
  â”‚
  â””â”€ BinaryTreePathFinder.csproj
```

---

# ä»‹é¢è¨­è¨ˆ

```csharp
namespace BinaryTreePathFinder.Core;

/// <summary>
/// çµ±ä¸€çš„æŸ¥è©¢çµæœ
/// </summary>
public sealed class PathResult
{
    public required int Distance { get; init; }
    public required IReadOnlyList<string> Directions { get; init; }
}

/// <summary>
/// Strategy ä»‹é¢ï¼šçµ¦ä¸åŒå¯¦ä½œå…±ç”¨
/// </summary>
public interface IPathStrategy
{
    /// <summary>
    /// å»ºç«‹æ¨¹çš„å…§éƒ¨å¿«å–è³‡æ–™
    /// </summary>
    void Build(BinaryTree tree);

    /// <summary>
    /// æŸ¥è©¢å…©å€‹ç¯€é»ä¹‹é–“çš„æœ€çŸ­è·¯å¾‘
    /// </summary>
    PathResult Query(string sourceLabel, string destinationLabel);
}
```

---

# BinaryTree.cs

```csharp
namespace BinaryTreePathFinder.Core;

public sealed class BinaryTree
{
    public sealed class Node
    {
        public string Label { get; }
        public Node? Parent { get; internal set; }
        public Node? Left { get; internal set; }
        public Node? Right { get; internal set; }
        public int Index { get; }

        public Node(string label, int index)
        {
            Label = label;
            Index = index;
        }
    }

    public Node? Root { get; }
    public IReadOnlyList<Node> Nodes { get; }
    public Dictionary<string, Node> IndexByLabel { get; }

    private BinaryTree(Node? root, List<Node> nodes, Dictionary<string, Node> dict)
    {
        Root = root;
        Nodes = nodes;
        IndexByLabel = dict;
    }

    /// <summary>
    /// å¾ Level-Order CSV å»ºç«‹æ¨¹
    /// </summary>
    public static BinaryTree BuildFromCsv(string csv)
    {
        var parts = csv.Split(',', StringSplitOptions.None)
                       .Select(s => s?.Trim() ?? "")
                       .ToArray();

        var nodes = new Node?[parts.Length];
        var dict = new Dictionary<string, Node>(StringComparer.Ordinal);

        for (int i = 0; i < parts.Length; i++)
        {
            if (string.IsNullOrEmpty(parts[i])) continue;
            if (dict.ContainsKey(parts[i]))
                throw new ArgumentException($"Duplicate label {parts[i]}");

            nodes[i] = new Node(parts[i], i);
            dict.Add(parts[i], nodes[i]!);
        }

        for (int i = 0; i < nodes.Length; i++)
        {
            if (nodes[i] == null) continue;
            int li = 2 * i + 1, ri = 2 * i + 2;
            if (li < nodes.Length && nodes[li] != null)
            {
                nodes[i]!.Left = nodes[li];
                nodes[li]!.Parent = nodes[i];
            }
            if (ri < nodes.Length && nodes[ri] != null)
            {
                nodes[i]!.Right = nodes[ri];
                nodes[ri]!.Parent = nodes[i];
            }
        }

        var existing = nodes.Where(n => n != null).Cast<Node>().ToList();
        return new BinaryTree(nodes[0], existing, dict);
    }
}
```

---

# ç­–ç•¥å¯¦ä½œï¼ˆç°¡è¿°ï¼‰

* **StrategyA1a\_NextHop**
  å­˜ `nextHop[src, dst]` (short)ï¼ŒæŸ¥è©¢é€æ­¥èµ°åˆ°ç›®æ¨™ â†’ O(è·é›¢) é‡å»ºè·¯å¾‘
* **StrategyA1b\_NextDir**
  å­˜ `nextDir[src, dst]` (byte)ï¼ŒæŸ¥è©¢é€æ­¥èµ°åˆ°ç›®æ¨™ â†’ O(è·é›¢) é‡å»ºè·¯å¾‘
* **StrategyA1c\_NextDirDist**
  å­˜ `nextDir[src, dst]` (byte) + `dist[src, dst]` (byte)ï¼ŒæŸ¥è©¢è·é›¢ O(1)ï¼Œè·¯å¾‘ O(è·é›¢)
* **StrategyB\_LCA**
  ç”¨ binary lifting æ±‚ LCAï¼Œè·é›¢ O(logN)ï¼Œè·¯å¾‘ O(è·é›¢)

ï¼ˆå®Œæ•´ç¨‹å¼ç¢¼æœƒå¾ˆé•·ï¼Œæˆ‘å¯ä»¥åˆ†æ‰¹å¹«ä½ è£œå®Œï¼‰

---

# æ¸¬è©¦æ¡ˆä¾‹ï¼ˆxUnitï¼‰

```csharp
public static class TreeTestCases
{
    public static IEnumerable<object[]> GetCases()
    {
        // ç¯„ä¾‹ï¼šT1
        yield return new object[]
        {
            "A,B,C,,D,E,F,,,,,,,G",  // input CSV
            "B", "F", 3,
            new[] { "U", "DR", "DR" },
            @"
   A
 /   \
B     C
 \   / \
  D E   F
        /
       G
"
        };

        // TODO: å…¶ä»– T2~T10
    }
}
```

æ¸¬è©¦é¡ï¼š

```csharp
public class PathStrategyTests
{
    [Theory]
    [MemberData(nameof(TreeTestCases.GetCases), MemberType = typeof(TreeTestCases))]
    public void Should_FindShortestPath(
        string csv, string source, string dest,
        int expectedDistance, string[] expectedPath, string summary)
    {
        // å¯ä»¥è·‘å››ç¨®ç­–ç•¥éƒ½é©—è­‰
        var strategies = new IPathStrategy[]
        {
            new StrategyA1a_NextHop(),
            new StrategyA1b_NextDir(),
            new StrategyA1c_NextDirDist(),
            new StrategyB_LCA()
        };

        var tree = BinaryTree.BuildFromCsv(csv);

        foreach (var strategy in strategies)
        {
            strategy.Build(tree);
            var result = strategy.Query(source, dest);

            Assert.Equal(expectedDistance, result.Distance);
            Assert.Equal(expectedPath, result.Directions);
        }
    }
}
```

---

# Benchmark æ¸¬è©¦

ç”¨ [BenchmarkDotNet](https://benchmarkdotnet.org/)

```csharp
[MemoryDiagnoser]
public class StrategyBenchmarks
{
    private readonly BinaryTree _tree = BinaryTree.BuildFromCsv("A,B,C,,D,E,F,,,,,,,G");
    private readonly List<IPathStrategy> _strategies;

    public StrategyBenchmarks()
    {
        _strategies = new()
        {
            new StrategyA1a_NextHop(),
            new StrategyA1b_NextDir(),
            new StrategyA1c_NextDirDist(),
            new StrategyB_LCA()
        };
        foreach (var s in _strategies) s.Build(_tree);
    }

    [Benchmark]
    [Arguments("B", "F")]
    public int Query_NextHop(string src, string dst)
        => _strategies[0].Query(src, dst).Distance;

    [Benchmark]
    [Arguments("B", "F")]
    public int Query_NextDir(string src, string dst)
        => _strategies[1].Query(src, dst).Distance;

    [Benchmark]
    [Arguments("B", "F")]
    public int Query_NextDirDist(string src, string dst)
        => _strategies[2].Query(src, dst).Distance;

    [Benchmark]
    [Arguments("B", "F")]
    public int Query_LCA(string src, string dst)
        => _strategies[3].Query(src, dst).Distance;
}
```

---

ğŸ‘‰ é€™æ¨£æˆ‘å€‘å°±æœ‰å®Œæ•´éª¨æ¶ï¼Œå¯ä»¥é–‹å§‹é€æ­¥å¡«å……å››å€‹ç­–ç•¥çš„ç´°ç¯€ã€‚

è¦ä¸è¦æˆ‘å…ˆå¹«ä½ æŠŠ **StrategyA1a\_NextHop** çš„å®Œæ•´å¯¦ä½œå¯«å¥½ï¼ˆåŒ…å«å»ºè¡¨èˆ‡æŸ¥è©¢è·¯å¾‘ï¼‰ï¼Œæ¥è‘—å†è£œ 1bã€1c èˆ‡ Bï¼Ÿ


Question : 
å¯ä»¥ ä½†æ˜¯æˆ‘æƒ³è¦ A1a é€™ç¨®å‘½åå¯ä»¥ä¸è¦å‡ºç¾ï¼Œèƒ½ä¸èƒ½æ›´ç²¾æº–å¾·å‘Šè¨´æˆ‘æ˜¯ç”šéº¼æ¨£çš„ç­–ç•¥

Answer : 
æ‡‚ ğŸ‘
ã€ŒA1a / A1b / A1cã€åªæ˜¯æˆ‘å€‘ä¹‹å‰è¨è«–æ™‚çš„ç°¡ç¨±ï¼Œæ”¾åˆ°ç¨‹å¼è£¡çš„å‘½åç¢ºå¯¦æœƒæ¨¡ç³Šã€‚å»ºè­°å‘½åæ™‚è¦èƒ½**ç›´æ¥è¡¨é”ç­–ç•¥çš„å„²å­˜æ–¹å¼èˆ‡æŸ¥è©¢æ–¹å¼**ã€‚

æˆ‘æ•´ç†ä¸€ä¸‹å„æ–¹æ¡ˆçš„ç‰¹å¾µèˆ‡å‘½åå»ºè­°ï¼š

---

## ç­–ç•¥å‘½åå»ºè­°

1. **NextHopMatrixStrategy**

   * å„²å­˜æ–¹å¼ï¼š`nextHop[src, dst] = ä¸‹ä¸€å€‹ç¯€é» id`
   * æŸ¥è©¢æ–¹å¼ï¼šå¾ source é–‹å§‹ï¼Œä¾ nextHop é€æ­¥èµ°åˆ° destinationï¼Œé‚Šèµ°é‚Šçµ„è·¯å¾‘
   * è¨˜æ†¶é«”ï¼š\~8 MB
   * æŸ¥è©¢è·é›¢ï¼šO(è·é›¢)ï¼Œè·¯å¾‘ï¼šO(è·é›¢)

2. **NextDirectionMatrixStrategy**

   * å„²å­˜æ–¹å¼ï¼š`nextDirection[src, dst] = U/DL/DR` (byte)
   * æŸ¥è©¢æ–¹å¼ï¼šé€æ­¥è·Ÿéš¨æ–¹å‘ç›´åˆ°æŠµé” destinationï¼Œé‚Šèµ°é‚Šçµ„è·¯å¾‘
   * è¨˜æ†¶é«”ï¼š\~4 MB
   * æŸ¥è©¢è·é›¢ï¼šO(è·é›¢)ï¼Œè·¯å¾‘ï¼šO(è·é›¢)

3. **NextDirectionWithDistanceStrategy**

   * å„²å­˜æ–¹å¼ï¼š`nextDirection[src, dst]` + `distance[src, dst]` (å…©å€‹ byte çŸ©é™£)
   * æŸ¥è©¢æ–¹å¼ï¼šè·é›¢ O(1) ç›´æ¥æŸ¥çŸ©é™£ï¼Œè·¯å¾‘ä»é€æ­¥è·Ÿéš¨æ–¹å‘çµ„å‡º
   * è¨˜æ†¶é«”ï¼š\~8 MB
   * æŸ¥è©¢è·é›¢ï¼šO(1)ï¼Œè·¯å¾‘ï¼šO(è·é›¢)

4. **LowestCommonAncestorStrategy**

   * å„²å­˜æ–¹å¼ï¼šbinary lifting parent table + depth\[]
   * æŸ¥è©¢æ–¹å¼ï¼šæ‰¾ LCA â†’ è·¯å¾‘åˆ†æ®µçµ„åˆ
   * è¨˜æ†¶é«”ï¼š<0.1 MB
   * æŸ¥è©¢è·é›¢ï¼šO(logN)ï¼Œè·¯å¾‘ï¼šO(è·é›¢)

---

## å‘½åè¦ç¯„å»ºè­°

* **IPathStrategy** â†’ çµ±ä¸€ä»‹é¢
* **Strategy åç¨±**ï¼šç›´æ¥ç”¨ç­–ç•¥æ ¸å¿ƒè³‡æ–™çµæ§‹æè¿°

ä¾‹å¦‚ï¼š

```csharp
public class NextHopMatrixStrategy : IPathStrategy { ... }
public class NextDirectionMatrixStrategy : IPathStrategy { ... }
public class NextDirectionWithDistanceStrategy : IPathStrategy { ... }
public class LowestCommonAncestorStrategy : IPathStrategy { ... }
```

é€™æ¨£è®€åˆ°åç¨±çš„äººï¼Œä¸ç”¨å»æŸ¥æ–‡ä»¶å°±èƒ½å¤§æ¦‚çŸ¥é“é€™æ˜¯ä»€éº¼æ€è·¯çš„ç­–ç•¥ã€‚

---

è¦ä¸è¦æˆ‘å…ˆå¹«ä½ æŠŠ **NextHopMatrixStrategy**ï¼ˆåŸ A1aï¼‰å®Œæ•´å¯¦ä½œå‡ºä¾†ï¼ŒåŒ…æ‹¬ Build å’Œ Queryï¼Ÿ

Question : 
å¯ä»¥

Answer : 
å¥½ï¼Œæˆ‘å…ˆå¹«ä½ æŠŠ **NextHopMatrixStrategy**ï¼ˆåŸæœ¬çš„ A1aï¼‰å®Œæ•´å¯¦ä½œå‡ºä¾†ï¼Œå‘½åæ¸…æ¥šã€å¯è®€æ€§é«˜ã€‚é€™å€‹ç­–ç•¥çš„æ€è·¯æ˜¯ **å„²å­˜æ¯ä¸€å°ç¯€é»çš„ã€Œç¬¬ä¸€è·³ã€**ï¼ŒæŸ¥è©¢æ™‚å¾ source ä¸€ç›´ follow nextHop èµ°åˆ° destinationï¼Œé‚Šèµ°é‚Šçµ„è·¯å¾‘ã€‚

---

## NextHopMatrixStrategy.cs

```csharp
using System;
using System.Collections.Generic;

namespace BinaryTreePathFinder.Core;

/// <summary>
/// ä½¿ç”¨ã€ŒNextHop çŸ©é™£ã€ç­–ç•¥ï¼š
/// æ¯ä¸€å° (src, dst) éƒ½å­˜ç¬¬ä¸€å€‹è¦èµ°çš„ä¸‹ä¸€å€‹ç¯€é»ï¼Œ
/// æŸ¥è©¢æ™‚é€éä¸æ–·è·Ÿéš¨ nextHop ç›´åˆ°æŠµé”ç›®æ¨™ã€‚
/// è¨˜æ†¶é«” ~8MBï¼ŒæŸ¥è©¢è·é›¢ O(è·é›¢)ï¼Œè·¯å¾‘ O(è·é›¢)ã€‚
/// </summary>
public sealed class NextHopMatrixStrategy : IPathStrategy
{
    private BinaryTree? _tree;
    private short[,]? _nextHop; // å„²å­˜ç¬¬ä¸€å€‹è¦èµ°çš„ç¯€é»ç´¢å¼•
    private Dictionary<string, int>? _labelToIndex;

    public void Build(BinaryTree tree)
    {
        _tree = tree ?? throw new ArgumentNullException(nameof(tree));
        _labelToIndex = new Dictionary<string, int>(StringComparer.Ordinal);

        for (int i = 0; i < tree.Nodes.Count; i++)
        {
            _labelToIndex[tree.Nodes[i].Label] = i;
        }

        int n = tree.Nodes.Count;
        _nextHop = new short[n, n];

        // åˆå§‹åŒ–ï¼šè‡ªå·±åˆ°è‡ªå·± = -1 (ç„¡éœ€ç§»å‹•)
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                _nextHop[i, j] = -1;

        // ç”¨ BFS ç‚ºæ¯å€‹ç¯€é»å»ºç«‹ nextHop
        for (int i = 0; i < n; i++)
        {
            BuildNextHopForSource(i, tree);
        }
    }

    private void BuildNextHopForSource(int srcIndex, BinaryTree tree)
    {
        int n = tree.Nodes.Count;
        var visited = new bool[n];
        var queue = new Queue<int>();
        var parent = new int[n];

        Array.Fill(parent, -1);
        visited[srcIndex] = true;
        queue.Enqueue(srcIndex);

        while (queue.Count > 0)
        {
            int u = queue.Dequeue();
            foreach (var v in GetNeighbors(tree.Nodes[u]))
            {
                int vi = tree.Nodes.IndexOf(v);
                if (!visited[vi])
                {
                    visited[vi] = true;
                    parent[vi] = u;
                    queue.Enqueue(vi);

                    // å¦‚æœ v æ˜¯ src çš„ç›´æ¥é„°å±… â†’ nextHop[src, v] = v
                    // å¦å‰‡ â†’ nextHop[src, v] = nextHop[src, parent[v]]
                    if (parent[vi] == srcIndex)
                        _nextHop![srcIndex, vi] = (short)vi;
                    else
                        _nextHop![srcIndex, vi] = _nextHop![srcIndex, parent[vi]];
                }
            }
        }
    }

    private IEnumerable<BinaryTree.Node> GetNeighbors(BinaryTree.Node node)
    {
        if (node.Parent != null) yield return node.Parent;
        if (node.Left != null) yield return node.Left;
        if (node.Right != null) yield return node.Right;
    }

    public PathResult Query(string sourceLabel, string destinationLabel)
    {
        if (_tree == null || _nextHop == null || _labelToIndex == null)
            throw new InvalidOperationException("Strategy not built. Call Build() first.");

        if (!_labelToIndex.TryGetValue(sourceLabel, out int src))
            throw new ArgumentException($"Source label '{sourceLabel}' not found.");
        if (!_labelToIndex.TryGetValue(destinationLabel, out int dst))
            throw new ArgumentException($"Destination label '{destinationLabel}' not found.");

        if (src == dst)
        {
            return new PathResult
            {
                Distance = 0,
                Directions = Array.Empty<string>()
            };
        }

        var directions = new List<string>();
        int cur = src;
        int distance = 0;

        while (cur != dst)
        {
            int next = _nextHop![cur, dst];
            if (next == -1)
                throw new InvalidOperationException($"No path between {sourceLabel} and {destinationLabel}");

            directions.Add(GetDirection(_tree!.Nodes[cur], _tree.Nodes[next]));
            cur = next;
            distance++;
        }

        return new PathResult
        {
            Distance = distance,
            Directions = directions
        };
    }

    private string GetDirection(BinaryTree.Node from, BinaryTree.Node to)
    {
        if (from.Parent == to) return "U";
        if (from.Left == to) return "DL";
        if (from.Right == to) return "DR";
        throw new InvalidOperationException("Invalid edge between nodes");
    }
}
```

---

## æ ¸å¿ƒé‚è¼¯é‡é»

1. **Build**ï¼š

   * é‡å°æ¯å€‹ç¯€é»åš BFSï¼Œç®—å‡ºåˆ°å…¶ä»–ç¯€é»çš„ç¬¬ä¸€è·³ï¼Œå¡«å…¥ `_nextHop`ã€‚
   * æ™‚é–“ O(NÂ²)ï¼ŒN â‰¤ 2047 å¯æ¥å—ã€‚

2. **Query**ï¼š

   * å¾ source é–‹å§‹ï¼Œæ ¹æ“š `_nextHop[src, dst]` ä¸æ–·å¾€ä¸‹è·³ï¼Œç›´åˆ°æŠµé” destinationã€‚
   * è·¯å¾‘æ–¹å‘ä¾æ“šæ¨¹çµæ§‹çš„ `Parent/Left/Right` åˆ¤æ–·è¼¸å‡º `U/DL/DR`ã€‚

3. **è¨˜æ†¶é«”**ï¼š

   * `_nextHop` æ˜¯ short\[N,N]ï¼Œ\~8 MBã€‚

---

è¦ä¸è¦æˆ‘æ¥ä¸‹ä¾†å¹«ä½ æŠŠ **NextDirectionMatrixStrategy**ï¼ˆåŸ A1bï¼‰ä¹Ÿå¯¦ä½œå‡ºä¾†ï¼Ÿ


æœ‰å¹¾å€‹å•é¡Œéœ€è¦å…ˆä¿®æ­£
1ã€ int vi = tree.Nodes.IndexOf(v); é€™å€‹åœ°æ–¹ï¼Œå› ç‚ºæˆ‘å€‘å‰é¢å·²çš„ BinaryTrees è£¡é¢çš„ Nodes ä½¿ç”¨çš„æ˜¯ IReadOnlyList æ‰€ä»¥ä¸èƒ½ä½¿ç”¨ indexof

2ã€é€™è£¡é¢å¾—å‘½åæœ‰é»è®“æˆ‘é›£ä»¥å€åˆ†é€™äº›æš«å­˜è®Šæ•¸æ˜¯è¦ç”¨ä¾†åšç”šéº¼çš„è«‹å¹«æˆ‘ä¿®æ­£

Answer:

ğŸ‘Œ å¾ˆå¥½çš„é»ï¼ŒSianã€‚
æˆ‘å¹«ä½ ä¿®æ­£ **NextHopMatrixStrategy** çš„å…©å€‹å•é¡Œï¼š

1. **`IndexOf` æ•ˆèƒ½å·® & `Nodes` æ˜¯ `IReadOnlyList`**
   ğŸ‘‰ æˆ‘å€‘åœ¨ `BinaryTree` å»ºç«‹æ™‚å°±æ‡‰è©²ä¿ç•™ä¸€å€‹ **Node â†’ Index** çš„å­—å…¸ï¼Œä¾›ç­–ç•¥æŸ¥è©¢ã€‚é€™æ¨£æŸ¥æ‰¾ O(1)ã€‚

2. **å‘½åä¸æ¸…æ¥š**
   ğŸ‘‰ æˆ‘æŠŠæš«å­˜è®Šæ•¸åç¨±æ›æˆæ¸…æ¥šè¡¨é”æ„åœ–çš„åç¨±ï¼Œä¾‹å¦‚ï¼š

   * `srcIndex` â†’ `sourceNodeIndex`
   * `vi` â†’ `neighborNodeIndex`
   * `u` â†’ `currentNodeIndex`
   * `v` â†’ `neighborNode`

---

## ä¿®æ­£ç‰ˆ NextHopMatrixStrategy

```csharp
using System;
using System.Collections.Generic;

namespace BinaryTreePathFinder.Core;

/// <summary>
/// ä½¿ç”¨ã€ŒNextHop çŸ©é™£ã€ç­–ç•¥ï¼š
/// æ¯ä¸€å° (src, dst) éƒ½å­˜ç¬¬ä¸€å€‹è¦èµ°çš„ä¸‹ä¸€å€‹ç¯€é»ï¼Œ
/// æŸ¥è©¢æ™‚é€éä¸æ–·è·Ÿéš¨ nextHop ç›´åˆ°æŠµé”ç›®æ¨™ã€‚
/// è¨˜æ†¶é«” ~8MBï¼ŒæŸ¥è©¢è·é›¢ O(è·é›¢)ï¼Œè·¯å¾‘ O(è·é›¢)ã€‚
/// </summary>
public sealed class NextHopMatrixStrategy : IPathStrategy
{
    private BinaryTree? _tree;
    private short[,]? _nextHop; // [sourceIndex, destinationIndex] = ä¸‹ä¸€æ­¥ç¯€é»çš„ç´¢å¼•
    private Dictionary<string, int>? _labelToIndex;
    private Dictionary<BinaryTree.Node, int>? _nodeToIndex;

    public void Build(BinaryTree tree)
    {
        _tree = tree ?? throw new ArgumentNullException(nameof(tree));
        _labelToIndex = new Dictionary<string, int>(StringComparer.Ordinal);
        _nodeToIndex = new Dictionary<BinaryTree.Node, int>();

        for (int i = 0; i < tree.Nodes.Count; i++)
        {
            _labelToIndex[tree.Nodes[i].Label] = i;
            _nodeToIndex[tree.Nodes[i]] = i;
        }

        int nodeCount = tree.Nodes.Count;
        _nextHop = new short[nodeCount, nodeCount];

        // åˆå§‹åŒ– -1 è¡¨ç¤ºæœªçŸ¥
        for (int i = 0; i < nodeCount; i++)
            for (int j = 0; j < nodeCount; j++)
                _nextHop[i, j] = -1;

        // ç‚ºæ¯å€‹ç¯€é»è¨ˆç®— nextHop
        for (int sourceNodeIndex = 0; sourceNodeIndex < nodeCount; sourceNodeIndex++)
        {
            ComputeNextHopForSource(sourceNodeIndex, tree);
        }
    }

    private void ComputeNextHopForSource(int sourceNodeIndex, BinaryTree tree)
    {
        int nodeCount = tree.Nodes.Count;
        var visited = new bool[nodeCount];
        var queue = new Queue<int>();
        var parentIndex = new int[nodeCount];

        Array.Fill(parentIndex, -1);

        visited[sourceNodeIndex] = true;
        queue.Enqueue(sourceNodeIndex);

        while (queue.Count > 0)
        {
            int currentNodeIndex = queue.Dequeue();
            var currentNode = tree.Nodes[currentNodeIndex];

            foreach (var neighborNode in GetNeighbors(currentNode))
            {
                int neighborNodeIndex = _nodeToIndex![neighborNode];

                if (!visited[neighborNodeIndex])
                {
                    visited[neighborNodeIndex] = true;
                    parentIndex[neighborNodeIndex] = currentNodeIndex;
                    queue.Enqueue(neighborNodeIndex);

                    if (parentIndex[neighborNodeIndex] == sourceNodeIndex)
                    {
                        // é„°å±…æ˜¯ source çš„ç›´æ¥ç›¸é„°ç¯€é»
                        _nextHop![sourceNodeIndex, neighborNodeIndex] = (short)neighborNodeIndex;
                    }
                    else
                    {
                        // ç¹¼æ‰¿çˆ¶ç¯€é»çš„ first hop
                        _nextHop![sourceNodeIndex, neighborNodeIndex] =
                            _nextHop![sourceNodeIndex, parentIndex[neighborNodeIndex]];
                    }
                }
            }
        }
    }

    private IEnumerable<BinaryTree.Node> GetNeighbors(BinaryTree.Node node)
    {
        if (node.Parent != null) yield return node.Parent;
        if (node.Left != null) yield return node.Left;
        if (node.Right != null) yield return node.Right;
    }

    public PathResult Query(string sourceLabel, string destinationLabel)
    {
        if (_tree == null || _nextHop == null || _labelToIndex == null)
            throw new InvalidOperationException("Strategy not built. Call Build() first.");

        if (!_labelToIndex.TryGetValue(sourceLabel, out int sourceIndex))
            throw new ArgumentException($"Source label '{sourceLabel}' not found.");
        if (!_labelToIndex.TryGetValue(destinationLabel, out int destinationIndex))
            throw new ArgumentException($"Destination label '{destinationLabel}' not found.");

        if (sourceIndex == destinationIndex)
        {
            return new PathResult
            {
                Distance = 0,
                Directions = Array.Empty<string>()
            };
        }

        var directions = new List<string>();
        int currentIndex = sourceIndex;
        int stepCount = 0;

        while (currentIndex != destinationIndex)
        {
            int nextIndex = _nextHop![currentIndex, destinationIndex];
            if (nextIndex == -1)
                throw new InvalidOperationException($"No path between {sourceLabel} and {destinationLabel}");

            directions.Add(GetDirection(_tree!.Nodes[currentIndex], _tree.Nodes[nextIndex]));
            currentIndex = nextIndex;
            stepCount++;
        }

        return new PathResult
        {
            Distance = stepCount,
            Directions = directions
        };
    }

    private string GetDirection(BinaryTree.Node fromNode, BinaryTree.Node toNode)
    {
        if (fromNode.Parent == toNode) return "U";
        if (fromNode.Left == toNode) return "DL";
        if (fromNode.Right == toNode) return "DR";
        throw new InvalidOperationException("Invalid edge between nodes");
    }
}
```

---

âœ… **ä¿®æ­£å¾Œçš„æ”¹é€²é»**

* ä¸å†ä½¿ç”¨ `IndexOf`ï¼Œæ”¹ç”¨ `_nodeToIndex` å­—å…¸ â†’ O(1) æŸ¥è©¢ã€‚
* æ‰€æœ‰è®Šæ•¸å‘½åéƒ½èªç¾©åŒ–ï¼š

  * `sourceNodeIndex`
  * `currentNodeIndex`
  * `neighborNodeIndex`
  * `parentIndex`
* æ–¹æ³•å‘½åä¹Ÿæ¸…æ¥šï¼š`ComputeNextHopForSource`ã€`GetDirection`ã€‚

---

è¦ä¸è¦æˆ‘æ¥ä¸‹ä¾†å¹«ä½ è£œä¸Š **NextDirectionMatrixStrategy**ï¼ˆåŸ A1b â†’ æˆ‘å»ºè­°å« `NextDirectionMatrixStrategy`ï¼‰çš„å®Œæ•´å¯¦ä½œï¼Ÿ

Question : 
å¯ä»¥è«‹é–‹å§‹

Answer : 

å¥½çš„ ğŸ‘ æˆ‘ä¾†å¹«ä½ å®Œæˆ **NextDirectionMatrixStrategy**ï¼ˆåŸ A1bï¼‰ï¼Œå®ƒå’Œ `NextHopMatrixStrategy` çš„å·®åˆ¥æ˜¯ï¼š

* **NextHopMatrixStrategy**ï¼šå­˜ã€Œä¸‹ä¸€å€‹ç¯€é»çš„ç´¢å¼•ã€(short)ã€‚
* **NextDirectionMatrixStrategy**ï¼šå­˜ã€Œç¬¬ä¸€æ­¥æ–¹å‘ã€(byte, U/DL/DR)ã€‚

  * æŸ¥è©¢æ™‚ç›´æ¥æ ¹æ“šæ–¹å‘èµ°ä¸€æ­¥ï¼Œé‡è¤‡ç›´åˆ°æŠµé”ç›®æ¨™ã€‚
  * è¨˜æ†¶é«”æ›´çœ (\~4MB)ã€‚
  * è·é›¢éœ€è¦é‚Šèµ°é‚Šç´¯åŠ ï¼Œä¸æ˜¯ O(1)ã€‚

---

## NextDirectionMatrixStrategy.cs

```csharp
using System;
using System.Collections.Generic;

namespace BinaryTreePathFinder.Core;

/// <summary>
/// ä½¿ç”¨ã€ŒNextDirection çŸ©é™£ã€ç­–ç•¥ï¼š
/// æ¯ä¸€å° (src, dst) å­˜ç¬¬ä¸€æ­¥è¦èµ°çš„æ–¹å‘ (U/DL/DR)ï¼Œ
/// æŸ¥è©¢æ™‚å¾ source é€æ­¥ä¾æ–¹å‘èµ°åˆ° destinationã€‚
/// è¨˜æ†¶é«” ~4MBï¼ŒæŸ¥è©¢è·é›¢ O(è·é›¢)ï¼Œè·¯å¾‘ O(è·é›¢)ã€‚
/// </summary>
public sealed class NextDirectionMatrixStrategy : IPathStrategy
{
    private BinaryTree? _tree;
    private byte[,]? _nextDirection; // [sourceIndex, destinationIndex] = ç¬¬ä¸€å€‹æ–¹å‘
    private Dictionary<string, int>? _labelToIndex;
    private Dictionary<BinaryTree.Node, int>? _nodeToIndex;

    private const byte None = 0;
    private const byte Up = 1;
    private const byte DownLeft = 2;
    private const byte DownRight = 3;

    public void Build(BinaryTree tree)
    {
        _tree = tree ?? throw new ArgumentNullException(nameof(tree));
        _labelToIndex = new Dictionary<string, int>(StringComparer.Ordinal);
        _nodeToIndex = new Dictionary<BinaryTree.Node, int>();

        for (int i = 0; i < tree.Nodes.Count; i++)
        {
            _labelToIndex[tree.Nodes[i].Label] = i;
            _nodeToIndex[tree.Nodes[i]] = i;
        }

        int nodeCount = tree.Nodes.Count;
        _nextDirection = new byte[nodeCount, nodeCount];

        // åˆå§‹åŒ–ç‚º None
        for (int i = 0; i < nodeCount; i++)
            for (int j = 0; j < nodeCount; j++)
                _nextDirection[i, j] = None;

        // ç‚ºæ¯å€‹ç¯€é»å»ºç«‹æ–¹å‘çŸ©é™£
        for (int sourceNodeIndex = 0; sourceNodeIndex < nodeCount; sourceNodeIndex++)
        {
            ComputeNextDirectionForSource(sourceNodeIndex, tree);
        }
    }

    private void ComputeNextDirectionForSource(int sourceNodeIndex, BinaryTree tree)
    {
        int nodeCount = tree.Nodes.Count;
        var visited = new bool[nodeCount];
        var queue = new Queue<int>();
        var parentIndex = new int[nodeCount];

        Array.Fill(parentIndex, -1);

        visited[sourceNodeIndex] = true;
        queue.Enqueue(sourceNodeIndex);

        while (queue.Count > 0)
        {
            int currentNodeIndex = queue.Dequeue();
            var currentNode = tree.Nodes[currentNodeIndex];

            foreach (var neighborNode in GetNeighbors(currentNode))
            {
                int neighborNodeIndex = _nodeToIndex![neighborNode];

                if (!visited[neighborNodeIndex])
                {
                    visited[neighborNodeIndex] = true;
                    parentIndex[neighborNodeIndex] = currentNodeIndex;
                    queue.Enqueue(neighborNodeIndex);

                    if (parentIndex[neighborNodeIndex] == sourceNodeIndex)
                    {
                        // é„°å±…æ˜¯ç›´æ¥ç›¸é„°ï¼šè¨˜éŒ„æ–¹å‘
                        _nextDirection![sourceNodeIndex, neighborNodeIndex] =
                            EncodeDirection(tree.Nodes[sourceNodeIndex], neighborNode);
                    }
                    else
                    {
                        // ç¹¼æ‰¿çˆ¶ç¯€é»çš„ç¬¬ä¸€æ­¥æ–¹å‘
                        _nextDirection![sourceNodeIndex, neighborNodeIndex] =
                            _nextDirection![sourceNodeIndex, parentIndex[neighborNodeIndex]];
                    }
                }
            }
        }
    }

    private IEnumerable<BinaryTree.Node> GetNeighbors(BinaryTree.Node node)
    {
        if (node.Parent != null) yield return node.Parent;
        if (node.Left != null) yield return node.Left;
        if (node.Right != null) yield return node.Right;
    }

    public PathResult Query(string sourceLabel, string destinationLabel)
    {
        if (_tree == null || _nextDirection == null || _labelToIndex == null)
            throw new InvalidOperationException("Strategy not built. Call Build() first.");

        if (!_labelToIndex.TryGetValue(sourceLabel, out int sourceIndex))
            throw new ArgumentException($"Source label '{sourceLabel}' not found.");
        if (!_labelToIndex.TryGetValue(destinationLabel, out int destinationIndex))
            throw new ArgumentException($"Destination label '{destinationLabel}' not found.");

        if (sourceIndex == destinationIndex)
        {
            return new PathResult
            {
                Distance = 0,
                Directions = Array.Empty<string>()
            };
        }

        var directions = new List<string>();
        int currentIndex = sourceIndex;
        int stepCount = 0;

        while (currentIndex != destinationIndex)
        {
            byte dirCode = _nextDirection![currentIndex, destinationIndex];
            if (dirCode == None)
                throw new InvalidOperationException($"No path between {sourceLabel} and {destinationLabel}");

            var currentNode = _tree!.Nodes[currentIndex];
            var nextNode = GetNextNode(currentNode, dirCode);

            directions.Add(DecodeDirection(dirCode));
            currentIndex = _nodeToIndex![nextNode];
            stepCount++;
        }

        return new PathResult
        {
            Distance = stepCount,
            Directions = directions
        };
    }

    private byte EncodeDirection(BinaryTree.Node fromNode, BinaryTree.Node toNode)
    {
        if (fromNode.Parent == toNode) return Up;
        if (fromNode.Left == toNode) return DownLeft;
        if (fromNode.Right == toNode) return DownRight;
        throw new InvalidOperationException("Invalid edge between nodes");
    }

    private string DecodeDirection(byte dirCode) => dirCode switch
    {
        Up => "U",
        DownLeft => "DL",
        DownRight => "DR",
        _ => throw new InvalidOperationException("Invalid direction code")
    };

    private BinaryTree.Node GetNextNode(BinaryTree.Node fromNode, byte dirCode) => dirCode switch
    {
        Up => fromNode.Parent ?? throw new InvalidOperationException(),
        DownLeft => fromNode.Left ?? throw new InvalidOperationException(),
        DownRight => fromNode.Right ?? throw new InvalidOperationException(),
        _ => throw new InvalidOperationException()
    };
}
```

---

## ç‰¹é»

* **å»ºè¡¨**ï¼šå°æ¯å€‹ source åš BFSï¼Œç´€éŒ„åˆ°å…¶ä»–ç¯€é»çš„ã€Œç¬¬ä¸€æ­¥æ–¹å‘ã€ã€‚
* **æŸ¥è©¢**ï¼š

  * é€æ­¥ä¾ direction èµ°åˆ° destinationã€‚
  * è·¯å¾‘è‡ªç„¶è¢«ç´¯ç©æˆæ–¹å‘åºåˆ—ã€‚
  * è·é›¢é‚Šèµ°é‚Šç´¯åŠ ã€‚
* **è¨˜æ†¶é«”**ï¼šbyte\[N,N]ï¼Œæœ€å£ 4 MB å·¦å³ã€‚

---

è¦ä¸è¦æˆ‘æ¥è‘—å¹«ä½ æŠŠ **NextDirectionWithDistanceStrategy**ï¼ˆåŸ A1cï¼‰ä¹Ÿè£œä¸Šï¼Ÿé€™æ¨£æ–¹æ¡ˆ A çš„ä¸‰å€‹ç­–ç•¥å°±å®Œæ•´äº†ã€‚

Question : ç¹¼çºŒ

Answer : 
å¥½ï¼Œæˆ‘ä¾†å¹«ä½ è£œä¸Š **NextDirectionWithDistanceStrategy**ï¼ˆåŸ A1cï¼‰ã€‚
å®ƒçš„æ ¸å¿ƒæ˜¯ï¼š

* **å­˜å…©å€‹çŸ©é™£**

  1. `nextDirection[src,dst]` (byte) â†’ ç¬¬ä¸€å€‹æ–¹å‘ (U/DL/DR)
  2. `distance[src,dst]` (byte) â†’ æœ€çŸ­è·é›¢

* **æŸ¥è©¢æ™‚**ï¼š

  * è·é›¢ç›´æ¥ O(1) å¾ `distance` æŸ¥å‡º
  * è·¯å¾‘ï¼šé‚„æ˜¯ä¾ `nextDirection` é€æ­¥èµ°åˆ°ç›®æ¨™

é€™æ¨£èƒ½åœ¨ **æœ€çœè¨˜æ†¶é«”èˆ‡é€Ÿåº¦é–“åšæŠ˜è¡·**ã€‚

---

## NextDirectionWithDistanceStrategy.cs

```csharp
using System;
using System.Collections.Generic;

namespace BinaryTreePathFinder.Core;

/// <summary>
/// ä½¿ç”¨ã€ŒNextDirection + Distance çŸ©é™£ã€ç­–ç•¥ï¼š
/// æ¯ä¸€å° (src, dst) å­˜ç¬¬ä¸€æ­¥æ–¹å‘èˆ‡è·é›¢ã€‚
/// æŸ¥è©¢è·é›¢ O(1)ï¼Œè·¯å¾‘ O(è·é›¢)ã€‚
/// è¨˜æ†¶é«” ~8MBã€‚
/// </summary>
public sealed class NextDirectionWithDistanceStrategy : IPathStrategy
{
    private BinaryTree? _tree;
    private byte[,]? _nextDirection; // [sourceIndex, destinationIndex] = ç¬¬ä¸€å€‹æ–¹å‘
    private byte[,]? _distance;      // [sourceIndex, destinationIndex] = è·é›¢
    private Dictionary<string, int>? _labelToIndex;
    private Dictionary<BinaryTree.Node, int>? _nodeToIndex;

    private const byte None = 0;
    private const byte Up = 1;
    private const byte DownLeft = 2;
    private const byte DownRight = 3;

    public void Build(BinaryTree tree)
    {
        _tree = tree ?? throw new ArgumentNullException(nameof(tree));
        _labelToIndex = new Dictionary<string, int>(StringComparer.Ordinal);
        _nodeToIndex = new Dictionary<BinaryTree.Node, int>();

        for (int i = 0; i < tree.Nodes.Count; i++)
        {
            _labelToIndex[tree.Nodes[i].Label] = i;
            _nodeToIndex[tree.Nodes[i]] = i;
        }

        int nodeCount = tree.Nodes.Count;
        _nextDirection = new byte[nodeCount, nodeCount];
        _distance = new byte[nodeCount, nodeCount];

        // åˆå§‹åŒ–
        for (int i = 0; i < nodeCount; i++)
        {
            for (int j = 0; j < nodeCount; j++)
            {
                _nextDirection[i, j] = None;
                _distance[i, j] = 0;
            }
        }

        // ç‚ºæ¯å€‹ç¯€é»åš BFS
        for (int sourceIndex = 0; sourceIndex < nodeCount; sourceIndex++)
        {
            ComputeNextDirectionAndDistanceForSource(sourceIndex, tree);
        }
    }

    private void ComputeNextDirectionAndDistanceForSource(int sourceIndex, BinaryTree tree)
    {
        int nodeCount = tree.Nodes.Count;
        var visited = new bool[nodeCount];
        var queue = new Queue<int>();
        var parentIndex = new int[nodeCount];

        Array.Fill(parentIndex, -1);

        visited[sourceIndex] = true;
        queue.Enqueue(sourceIndex);

        while (queue.Count > 0)
        {
            int currentIndex = queue.Dequeue();
            var currentNode = tree.Nodes[currentIndex];

            foreach (var neighbor in GetNeighbors(currentNode))
            {
                int neighborIndex = _nodeToIndex![neighbor];
                if (!visited[neighborIndex])
                {
                    visited[neighborIndex] = true;
                    parentIndex[neighborIndex] = currentIndex;
                    queue.Enqueue(neighborIndex);

                    // è¨­å®šè·é›¢
                    _distance![sourceIndex, neighborIndex] =
                        (byte)(_distance![sourceIndex, currentIndex] + 1);

                    // è¨­å®šç¬¬ä¸€æ­¥æ–¹å‘
                    if (parentIndex[neighborIndex] == sourceIndex)
                    {
                        _nextDirection![sourceIndex, neighborIndex] =
                            EncodeDirection(tree.Nodes[sourceIndex], neighbor);
                    }
                    else
                    {
                        _nextDirection![sourceIndex, neighborIndex] =
                            _nextDirection![sourceIndex, parentIndex[neighborIndex]];
                    }
                }
            }
        }
    }

    private IEnumerable<BinaryTree.Node> GetNeighbors(BinaryTree.Node node)
    {
        if (node.Parent != null) yield return node.Parent;
        if (node.Left != null) yield return node.Left;
        if (node.Right != null) yield return node.Right;
    }

    public PathResult Query(string sourceLabel, string destinationLabel)
    {
        if (_tree == null || _nextDirection == null || _distance == null || _labelToIndex == null)
            throw new InvalidOperationException("Strategy not built. Call Build() first.");

        if (!_labelToIndex.TryGetValue(sourceLabel, out int sourceIndex))
            throw new ArgumentException($"Source label '{sourceLabel}' not found.");
        if (!_labelToIndex.TryGetValue(destinationLabel, out int destinationIndex))
            throw new ArgumentException($"Destination label '{destinationLabel}' not found.");

        if (sourceIndex == destinationIndex)
        {
            return new PathResult
            {
                Distance = 0,
                Directions = Array.Empty<string>()
            };
        }

        var directions = new List<string>();
        int currentIndex = sourceIndex;

        while (currentIndex != destinationIndex)
        {
            byte dirCode = _nextDirection![currentIndex, destinationIndex];
            if (dirCode == None)
                throw new InvalidOperationException($"No path between {sourceLabel} and {destinationLabel}");

            var currentNode = _tree!.Nodes[currentIndex];
            var nextNode = GetNextNode(currentNode, dirCode);

            directions.Add(DecodeDirection(dirCode));
            currentIndex = _nodeToIndex![nextNode];
        }

        return new PathResult
        {
            Distance = _distance![sourceIndex, destinationIndex],
            Directions = directions
        };
    }

    private byte EncodeDirection(BinaryTree.Node fromNode, BinaryTree.Node toNode)
    {
        if (fromNode.Parent == toNode) return Up;
        if (fromNode.Left == toNode) return DownLeft;
        if (fromNode.Right == toNode) return DownRight;
        throw new InvalidOperationException("Invalid edge between nodes");
    }

    private string DecodeDirection(byte dirCode) => dirCode switch
    {
        Up => "U",
        DownLeft => "DL",
        DownRight => "DR",
        _ => throw new InvalidOperationException("Invalid direction code")
    };

    private BinaryTree.Node GetNextNode(BinaryTree.Node fromNode, byte dirCode) => dirCode switch
    {
        Up => fromNode.Parent ?? throw new InvalidOperationException(),
        DownLeft => fromNode.Left ?? throw new InvalidOperationException(),
        DownRight => fromNode.Right ?? throw new InvalidOperationException(),
        _ => throw new InvalidOperationException()
    };
}
```

---

## ç­–ç•¥ä¸‰è€…æ¯”è¼ƒ (æ–¹æ¡ˆ A)

| ç­–ç•¥é¡åˆ¥                                  | å„²å­˜å…§å®¹                     | æŸ¥è©¢è·é›¢  | æŸ¥è©¢è·¯å¾‘  | è¨˜æ†¶é«”   |
| ------------------------------------- | ------------------------ | ----- | ----- | ----- |
| **NextHopMatrixStrategy**             | ä¸‹ä¸€å€‹ç¯€é»ç´¢å¼• (short)          | O(è·é›¢) | O(è·é›¢) | \~8MB |
| **NextDirectionMatrixStrategy**       | ç¬¬ä¸€å€‹æ–¹å‘ (byte)             | O(è·é›¢) | O(è·é›¢) | \~4MB |
| **NextDirectionWithDistanceStrategy** | ç¬¬ä¸€å€‹æ–¹å‘ (byte) + è·é›¢ (byte) | O(1)  | O(è·é›¢) | \~8MB |

---

é€™æ¨£æ–¹æ¡ˆ A çš„ä¸‰ç¨®ç­–ç•¥éƒ½å®Œæˆäº†ã€‚
è¦ä¸è¦æˆ‘æ¥ä¸‹ä¾†å¹«ä½ è£œä¸Š **LowestCommonAncestorStrategy**ï¼ˆæ–¹æ¡ˆ Bï¼‰ï¼Ÿ


Question : 
è«‹é–‹å§‹

Answer : 
å¥½ ğŸ‘ æˆ‘å¹«ä½ å®Œæˆ **æ–¹æ¡ˆ Bï¼šLowestCommonAncestorStrategy**ã€‚
é€™å€‹ç­–ç•¥çš„ç‰¹é»æ˜¯ï¼š

* **é è™•ç†**ï¼šå»º `parent[k][i]` (binary lifting) èˆ‡ `depth[i]`ã€‚
* **æŸ¥è©¢**ï¼š

  1. æ‰¾åˆ° `LCA(u,v)` â†’ è·é›¢ = `depth[u] + depth[v] âˆ’ 2*depth[LCA]`
  2. é‡å»ºè·¯å¾‘ï¼š

     * u â†’ LCAï¼šä¸€è·¯å¾€ä¸Šï¼ˆå…¨æ˜¯ `U`ï¼‰
     * v â†’ LCAï¼šä¸€è·¯å¾€ä¸Šï¼Œåè½‰å¾Œè®Šæˆ LCA â†’ vï¼Œç”¨ `DL`/`DR`
     * åˆä½µå…©æ®µè·¯å¾‘ã€‚

---

## LowestCommonAncestorStrategy.cs

```csharp
using System;
using System.Collections.Generic;

namespace BinaryTreePathFinder.Core;

/// <summary>
/// ä½¿ç”¨ LCA (Binary Lifting) ç­–ç•¥ï¼š
/// é è™•ç† parent table èˆ‡ depthï¼Œ
/// æŸ¥è©¢è·é›¢ O(logN)ï¼Œè·¯å¾‘ O(è·é›¢)ã€‚
/// è¨˜æ†¶é«” ~0.1MBï¼Œæœ€çœç©ºé–“ã€‚
/// </summary>
public sealed class LowestCommonAncestorStrategy : IPathStrategy
{
    private BinaryTree? _tree;
    private Dictionary<string, int>? _labelToIndex;
    private Dictionary<BinaryTree.Node, int>? _nodeToIndex;

    private int[,]? _parent;  // parent[k, i] = i çš„ 2^k ç¥–å…ˆ
    private int[]? _depth;   // depth[i] = ç¯€é»æ·±åº¦
    private BinaryTree.Node[]? _indexToNode;

    private int _maxLevel;

    public void Build(BinaryTree tree)
    {
        _tree = tree ?? throw new ArgumentNullException(nameof(tree));
        _labelToIndex = new Dictionary<string, int>(StringComparer.Ordinal);
        _nodeToIndex = new Dictionary<BinaryTree.Node, int>();

        int nodeCount = tree.Nodes.Count;
        _indexToNode = new BinaryTree.Node[nodeCount];

        for (int i = 0; i < nodeCount; i++)
        {
            _labelToIndex[tree.Nodes[i].Label] = i;
            _nodeToIndex[tree.Nodes[i]] = i;
            _indexToNode[i] = tree.Nodes[i];
        }

        _depth = new int[nodeCount];

        // maxLevel = âŒŠlog2(nodeCount)âŒ‹
        _maxLevel = (int)Math.Ceiling(Math.Log2(Math.Max(1, nodeCount)));
        _parent = new int[_maxLevel + 1, nodeCount];

        // åˆå§‹åŒ– parent = -1
        for (int k = 0; k <= _maxLevel; k++)
            for (int i = 0; i < nodeCount; i++)
                _parent[k, i] = -1;

        // BFS ä¾†å¡« depth èˆ‡ parent[0]
        if (tree.Root != null)
        {
            var queue = new Queue<BinaryTree.Node>();
            queue.Enqueue(tree.Root);
            _depth[_nodeToIndex![tree.Root]] = 0;

            while (queue.Count > 0)
            {
                var current = queue.Dequeue();
                int currentIndex = _nodeToIndex[current];

                if (current.Left != null)
                {
                    int leftIndex = _nodeToIndex[current.Left];
                    _depth[leftIndex] = _depth[currentIndex] + 1;
                    _parent[0, leftIndex] = currentIndex;
                    queue.Enqueue(current.Left);
                }

                if (current.Right != null)
                {
                    int rightIndex = _nodeToIndex[current.Right];
                    _depth[rightIndex] = _depth[currentIndex] + 1;
                    _parent[0, rightIndex] = currentIndex;
                    queue.Enqueue(current.Right);
                }
            }
        }

        // å¡« binary lifting table
        for (int k = 1; k <= _maxLevel; k++)
        {
            for (int i = 0; i < nodeCount; i++)
            {
                int midParent = _parent[k - 1, i];
                if (midParent != -1)
                {
                    _parent[k, i] = _parent[k - 1, midParent];
                }
            }
        }
    }

    public PathResult Query(string sourceLabel, string destinationLabel)
    {
        if (_tree == null || _labelToIndex == null || _nodeToIndex == null || _depth == null || _parent == null || _indexToNode == null)
            throw new InvalidOperationException("Strategy not built. Call Build() first.");

        if (!_labelToIndex.TryGetValue(sourceLabel, out int u))
            throw new ArgumentException($"Source label '{sourceLabel}' not found.");
        if (!_labelToIndex.TryGetValue(destinationLabel, out int v))
            throw new ArgumentException($"Destination label '{destinationLabel}' not found.");

        if (u == v)
        {
            return new PathResult
            {
                Distance = 0,
                Directions = Array.Empty<string>()
            };
        }

        int lca = GetLowestCommonAncestor(u, v);
        int distance = _depth[u] + _depth[v] - 2 * _depth[lca];

        var directions = new List<string>();

        // u â†’ lca ï¼ˆä¸€è·¯ Uï¼‰
        int cur = u;
        while (cur != lca)
        {
            directions.Add("U");
            cur = _parent![0, cur];
        }

        // v â†’ lca ï¼ˆä¸€è·¯ Uï¼‰ï¼Œå†åè½‰æˆ lca â†’ v
        var stack = new Stack<string>();
        cur = v;
        while (cur != lca)
        {
            int parentIndex = _parent![0, cur];
            var parentNode = _indexToNode[parentIndex];
            var curNode = _indexToNode[cur];

            if (parentNode.Left == curNode) stack.Push("DL");
            else if (parentNode.Right == curNode) stack.Push("DR");
            else throw new InvalidOperationException("Invalid parent-child relation");

            cur = parentIndex;
        }

        directions.AddRange(stack);

        return new PathResult
        {
            Distance = distance,
            Directions = directions
        };
    }

    private int GetLowestCommonAncestor(int u, int v)
    {
        if (_depth![u] < _depth[v])
            (u, v) = (v, u);

        // æŠŠ u æå‡åˆ°å’Œ v åŒæ·±åº¦
        int diff = _depth[u] - _depth[v];
        for (int k = 0; diff > 0; k++, diff >>= 1)
        {
            if ((diff & 1) != 0)
                u = _parent![k, u];
        }

        if (u == v) return u;

        // å¾é«˜ä½å¾€ä¸‹æ¯”ï¼Œç›´åˆ°æ‰¾åˆ°æœ€ä½å…±åŒç¥–å…ˆ
        for (int k = _maxLevel; k >= 0; k--)
        {
            if (_parent![k, u] != _parent[k, v])
            {
                u = _parent[k, u];
                v = _parent[k, v];
            }
        }

        return _parent![0, u];
    }
}
```

---

## ç‰¹é»

* **å»ºè¡¨æ™‚é–“**ï¼šO(N logN)
* **æŸ¥è©¢è·é›¢**ï¼šO(logN) æ‰¾ LCA
* **æŸ¥è©¢è·¯å¾‘**ï¼šO(è·é›¢)ï¼Œå› ç‚ºè¦å›æº¯èˆ‡çµ„åˆ
* **è¨˜æ†¶é«”**ï¼šç¯€é»æ•¸ \~2kã€logNâ‰ˆ11 â†’ å¹¾è¬æ•´æ•¸ï¼Œ<0.1MBï¼Œéå¸¸çœ

---

âœ… ç¾åœ¨æˆ‘å€‘å·²ç¶“æœ‰å››ç¨®ç­–ç•¥å®Œæ•´ç‰ˆæœ¬ï¼š

* NextHopMatrixStrategy
* NextDirectionMatrixStrategy
* NextDirectionWithDistanceStrategy
* LowestCommonAncestorStrategy

---

è¦ä¸è¦æˆ‘æ¥è‘—å¹«ä½ æŠŠ **xUnit å–®å…ƒæ¸¬è©¦ (T1\~T10)** å…¨éƒ¨å¥—ä¸Šå››ç¨®ç­–ç•¥ä¸€èµ·é©—è­‰ï¼Ÿ

Question : 
å¥½

Answer : 

å¤ªå¥½äº† ğŸ‘ æˆ‘å¹«ä½ æŠŠ **xUnit å–®å…ƒæ¸¬è©¦** è¨­è¨ˆå¥½ï¼Œæ¶µè“‹ T1 \~ T10 çš„æ¨¹ã€‚
æ¸¬è©¦é‡é»ï¼š

1. æ¯ä¸€å€‹æ¸¬è³‡æœƒçµ¦ **CSV input**ã€**source**ã€**destination**ã€**expected distance**ã€**expected path (U/DL/DR)**ã€‚
2. åœ¨ `[Theory]` æ¸¬è©¦æ–¹æ³•çš„ `summary` åƒæ•¸è£¡ï¼Œæ”¾ä¸Š**ASCII åœ–å½¢åŒ–çš„æ¨¹**ï¼Œæ–¹ä¾¿è‚‰çœ¼æª¢è¦–ã€‚
3. æ¯æ¬¡æ¸¬è©¦æœƒè·‘ **å››ç¨®ç­–ç•¥**ï¼Œç¢ºä¿çµæœä¸€è‡´ã€‚

---

## TreeTestCases.cs

```csharp
using System.Collections.Generic;

namespace BinaryTreePathFinder.Tests;

public static class TreeTestCases
{
    public static IEnumerable<object[]> GetCases()
    {
        // ---------- T1 ----------
        yield return new object[]
        {
            "A,B,C,,D,E,F,,,,,,,G",
            "B", "F", 3,
            new[] { "U", "DR", "DR" },
@"
       A
     /   \
    B     C
     \   / \
      D E   F
            /
           G
"
        };

        yield return new object[]
        {
            "A,B,C,,D,E,F,,,,,,,G",
            "E", "D", 4,
            new[] { "U", "U", "DL", "DR" },
@"
       A
     /   \
    B     C
     \   / \
      D E   F
            /
           G
"
        };

        // ---------- T2 ----------
        yield return new object[]
        {
            "A,B,C,D,E,F,G",
            "D", "G", 4,
            new[] { "U", "U", "DR", "DR" },
@"
       A
     /   \
    B     C
   / \   / \
  D   E F   G
"
        };

        // ---------- T3 ----------
        yield return new object[]
        {
            "A,B,,C,,,,D",
            "A", "D", 3,
            new[] { "DL", "DL", "DL" },
@"
    A
   /
  B
 /
C
/
D
"
        };

        // ---------- T4 ----------
        yield return new object[]
        {
            "A,,B,,,,C,,,,,,D",
            "A", "D", 3,
            new[] { "DR", "DR", "DR" },
@"
A
 \
  B
   \
    C
     \
      D
"
        };

        // ---------- T5 ----------
        yield return new object[]
        {
            "A",
            "A", "A", 0,
            new string[] { },
@"
A
"
        };

        // ---------- T8 (æ·±åº¦ 10 å·¦å) ----------
        yield return new object[]
        {
            "A,B,,,,,,,,,C,,,,,,,,,D,,,,,,,,,E,,,,,,,,,F,,,,,,,,,G,,,,,,,,,H,,,,,,,,,I,,,,,,,,,J",
            "A", "J", 9,
            new[] { "DL","DL","DL","DL","DL","DL","DL","DL","DL" },
@"
A
/
B
/
C
/
D
/
E
/
F
/
G
/
H
/
I
/
J
"
        };

        // ---------- T9 (æ·±åº¦ 10 å³å) ----------
        yield return new object[]
        {
            "A,,B,,,,C,,,,,,D,,,,,,,,E,,,,,,,,,,F,,,,,,,,,,,,G,,,,,,,,,,,,,,H,,,,,,,,,,,,,,,,I,,,,,,,,,,,,,,,,,,J",
            "A", "J", 9,
            new[] { "DR","DR","DR","DR","DR","DR","DR","DR","DR" },
@"
A
 \
  B
   \
    C
     \
      D
       \
        E
         \
          F
           \
            G
             \
              H
               \
                I
                 \
                  J
"
        };

        // ---------- T10 (æ·±åº¦ 10 Zig-Zag) ----------
        yield return new object[]
        {
            "A,B,,,C,,,,,D,,,,,,,E,,,,,,,,,F,,,,,,,,,,,G,,,,,,,,,,,,,H,,,,,,,,,,,,,,,I,,,,,,,,,,,,,,,,,J",
            "A", "J", 9,
            new[] { "DL","DR","DL","DR","DL","DR","DL","DR","DL" },
@"
A
/
B
 \
  C
 /
D
 \
  E
 /
F
 \
  G
 /
H
 \
  I
 /
J
"
        };
    }
}
```

---

## PathStrategyTests.cs

```csharp
using Xunit;
using BinaryTreePathFinder.Core;
using System.Collections.Generic;

namespace BinaryTreePathFinder.Tests;

public class PathStrategyTests
{
    private readonly List<IPathStrategy> _strategies;

    public PathStrategyTests()
    {
        _strategies = new()
        {
            new NextHopMatrixStrategy(),
            new NextDirectionMatrixStrategy(),
            new NextDirectionWithDistanceStrategy(),
            new LowestCommonAncestorStrategy()
        };
    }

    [Theory]
    [MemberData(nameof(TreeTestCases.GetCases), MemberType = typeof(TreeTestCases))]
    public void Should_FindShortestPath(
        string csv,
        string source,
        string destination,
        int expectedDistance,
        string[] expectedDirections,
        string summary)
    {
        var tree = BinaryTreePathFinder.Core.BinaryTree.BuildFromCsv(csv);

        foreach (var strategy in _strategies)
        {
            strategy.Build(tree);
            var result = strategy.Query(source, destination);

            Assert.Equal(expectedDistance, result.Distance);
            Assert.Equal(expectedDirections, result.Directions);
        }

        // é¡¯ç¤º summaryï¼Œæ–¹ä¾¿äººæª¢è¦–
        System.Diagnostics.Debug.WriteLine(summary);
    }
}
```

---

é€™æ¨£è·‘æ¸¬è©¦æ™‚ï¼Œæœƒå°æ¯å€‹æ¸¬è³‡å¥—ç”¨å››ç¨®ç­–ç•¥ï¼Œé©—è­‰è·é›¢èˆ‡è·¯å¾‘å®Œå…¨ä¸€è‡´ã€‚
Summary çš„ ASCII æ¨¹ä¹Ÿæœƒè¼¸å‡ºåœ¨ Debug çª—å£ï¼Œæ–¹ä¾¿äººå·¥ç¢ºèªã€‚

---

è¦ä¸è¦æˆ‘å†å¹«ä½ è£œä¸Š **BenchmarkTests**ï¼ˆç”¨ BenchmarkDotNet è·‘å››ç¨®ç­–ç•¥çš„æŸ¥è©¢æ•ˆèƒ½ + è¨˜æ†¶é«”ä½¿ç”¨é‡æ¯”è¼ƒï¼‰ï¼Ÿ

Question : 
åœ¨ T3 çš„ CASE æˆ‘å€‘çš„ NextHopMatrixStrategy å–®å…ƒæ¸¬è©¦å‡ºéŒ¯äº†ï¼ŒéŒ¯èª¤è¨Šæ¯æ˜¯ No path between {sourceLabel} and {destinationLabel}

Answer : 

æŠ“åˆ°äº†ï¼å•é¡Œå‡ºåœ¨ `NextHopMatrixStrategy` å…§ã€Œä¸€é‚Šåš BFSã€ä¸€é‚Šç”¨çˆ¶ç¯€é»çš„ first hop å»æ¨å°å­ç¯€é» first hopã€é€™æ®µæµç¨‹ï¼Œ**åœ¨æŸäº›ç¯€é»é †åºä¸‹å¯èƒ½è®€åˆ°å°šæœªå¯«å¥½çš„å€¼**ï¼ˆå°¤å…¶åœ¨æ·±éˆ like T3 æ™‚æ›´å®¹æ˜“è¸©åˆ°ï¼‰ã€‚ä¿éšªä½œæ³•ï¼š**å…ˆå®Œæ•´åšä¸€æ¬¡ BFSï¼Œæ‹¿åˆ° `parentIndex[]` å¾Œï¼Œå†é€ä¸€å°æ¯å€‹ç›®æ¨™ç¯€é»å›æº¯åˆ° sourceï¼Œæ‰¾å‡ºç¬¬ä¸€æ­¥**ï¼Œé€™æ¨£å°±ä¸æœƒæœ‰æ¨å°é †åºçš„ç«¶æ…‹å•é¡Œã€‚

ä¸‹é¢æ˜¯ä¿®æ­£ç‰ˆï¼ˆè®Šæ•¸å‘½åä¹ŸåŒæ­¥å¼·åŒ–ï¼‰ï¼š

```csharp
using System;
using System.Collections.Generic;

namespace BinaryTreePathFinder.Core;

/// <summary>
/// ä½¿ç”¨ã€ŒNextHop çŸ©é™£ã€ç­–ç•¥ï¼š
/// ç‚ºæ¯å° (source, destination) ä¿å­˜ç¬¬ä¸€æ­¥è¦èµ°åˆ°çš„ã€Œä¸‹ä¸€å€‹ç¯€é»ç´¢å¼•ã€ã€‚
/// å»ºè¡¨æµç¨‹ï¼šå°æ¯å€‹ source å…ˆåšå®Œæ•´ BFSï¼Œå–å¾— parentIndex[]ï¼Œ
/// å†å°æ¯å€‹ reachable çš„ destination å›æº¯æ‰¾å‡ºç¬¬ä¸€æ­¥ä¸¦å¡«è¡¨ï¼ˆé¿å…æ¨å°é †åºå•é¡Œï¼‰ã€‚
/// è¨˜æ†¶é«” ~8MBï¼ŒæŸ¥è©¢è·é›¢ O(è·é›¢)ï¼Œè·¯å¾‘ O(è·é›¢)ã€‚
/// </summary>
public sealed class NextHopMatrixStrategy : IPathStrategy
{
    private BinaryTree? _tree;
    private short[,]? _nextHop; // [sourceIndex, destinationIndex] = ä¸‹ä¸€æ­¥ç¯€é»ç´¢å¼•
    private Dictionary<string, int>? _labelToIndex;
    private Dictionary<BinaryTree.Node, int>? _nodeToIndex;

    public void Build(BinaryTree tree)
    {
        _tree = tree ?? throw new ArgumentNullException(nameof(tree));
        _labelToIndex = new Dictionary<string, int>(StringComparer.Ordinal);
        _nodeToIndex = new Dictionary<BinaryTree.Node, int>();

        for (int i = 0; i < tree.Nodes.Count; i++)
        {
            _labelToIndex[tree.Nodes[i].Label] = i;
            _nodeToIndex[tree.Nodes[i]] = i;
        }

        int nodeCount = tree.Nodes.Count;
        _nextHop = new short[nodeCount, nodeCount];

        // å…ˆè¨­æˆ -1ï¼ˆæœªçŸ¥/ä¸å¯é”ï¼‰
        for (int i = 0; i < nodeCount; i++)
            for (int j = 0; j < nodeCount; j++)
                _nextHop[i, j] = -1;

        // å°æ¯å€‹ç¯€é»åšä¸€æ¬¡ BFSï¼Œç„¶å¾Œç”¨ parentIndex å›æº¯å¡«å…¥ç¬¬ä¸€æ­¥
        for (int sourceNodeIndex = 0; sourceNodeIndex < nodeCount; sourceNodeIndex++)
        {
            FillFirstHopTableForSource(sourceNodeIndex, tree);
        }
    }

    /// <summary>
    /// å°æŒ‡å®š source å…ˆåšå®Œæ•´ BFSï¼Œæ‹¿åˆ° parentIndex èˆ‡ visitedï¼›
    /// å†å°æ¯å€‹ reachable çš„ destinationï¼Œå›æº¯åˆ° source æ‰¾åˆ°ç¬¬ä¸€æ­¥ï¼Œå¡«å…¥ nextHop[source, destination]ã€‚
    /// </summary>
    private void FillFirstHopTableForSource(int sourceNodeIndex, BinaryTree tree)
    {
        int nodeCount = tree.Nodes.Count;
        var parentIndexOf = new int[nodeCount];   // parentIndexOf[x] = x åœ¨ BFS æ¨¹ä¸­çš„çˆ¶ç¯€é»ç´¢å¼•
        var wasVisited = new bool[nodeCount];

        Array.Fill(parentIndexOf, -1);

        // --- BFSï¼ˆç„¡å‘ï¼šçˆ¶ã€å·¦ã€å³ï¼‰---
        var queue = new Queue<int>();
        wasVisited[sourceNodeIndex] = true;
        queue.Enqueue(sourceNodeIndex);

        while (queue.Count > 0)
        {
            int currentNodeIndex = queue.Dequeue();
            var currentNode = tree.Nodes[currentNodeIndex];

            foreach (var neighbor in EnumerateUndirectedNeighbors(currentNode))
            {
                int neighborIndex = _nodeToIndex![neighbor];
                if (wasVisited[neighborIndex]) continue;

                wasVisited[neighborIndex] = true;
                parentIndexOf[neighborIndex] = currentNodeIndex;
                queue.Enqueue(neighborIndex);
            }
        }

        // --- ç”¨ parentIndex å›æº¯ï¼Œç‚ºæ¯å€‹ reachable çš„ destination æ‰¾å‡ºã€Œç¬¬ä¸€æ­¥ã€---
        for (int destinationIndex = 0; destinationIndex < nodeCount; destinationIndex++)
        {
            if (destinationIndex == sourceNodeIndex) continue;
            if (!wasVisited[destinationIndex]) continue; // ä¸å¯é”ï¼ˆç†è«–ä¸Šæ¨¹ä¸€å®šå¯é”ï¼Œä½†ä¿éšªåˆ¤æ–·ï¼‰

            short firstHopIndex = FindFirstHopFromSourceToDestination(
                sourceNodeIndex, destinationIndex, parentIndexOf);

            _nextHop![sourceNodeIndex, destinationIndex] = firstHopIndex;
        }
    }

    /// <summary>
    /// å¾ destination é€é parentIndex ä¸€è·¯å›æº¯åˆ° sourceï¼›
    /// å›æº¯éç¨‹ä¸­æœ€å¾Œä¸€å€‹ã€Œå°šæœªåˆ°é” source å‰ã€çš„ç¯€é»ï¼Œå°±æ˜¯ source çš„ç¬¬ä¸€æ­¥ã€‚
    /// ä¾‹ï¼šsource=A, path: A -> B -> C -> Dï¼ˆdestinationï¼‰
    /// å›æº¯ï¼šD -> C -> B -> Aï¼›ç¬¬ä¸€æ­¥ç‚º Bã€‚
    /// </summary>
    private short FindFirstHopFromSourceToDestination(
        int sourceNodeIndex,
        int destinationNodeIndex,
        int[] parentIndexOf)
    {
        int cur = destinationNodeIndex;
        int parent = parentIndexOf[cur];

        // è‹¥ destination å°±æ˜¯ source çš„ç›´é„°ï¼Œparent æœƒæ˜¯ source
        // å¦å‰‡ä¸€è·¯å›æº¯ç›´åˆ° parent == source
        while (parent != sourceNodeIndex)
        {
            // è‹¥æ„å¤–æ‰¾ä¸åˆ° sourceï¼ˆé˜²ç¦¦å¼æª¢æŸ¥ï¼‰
            if (parent == -1)
                return -1;

            cur = parent;
            parent = parentIndexOf[cur];
        }

        return (short)cur; // cur å³ç‚º source çš„ç¬¬ä¸€æ­¥
    }

    private IEnumerable<BinaryTree.Node> EnumerateUndirectedNeighbors(BinaryTree.Node node)
    {
        if (node.Parent != null) yield return node.Parent;
        if (node.Left != null) yield return node.Left;
        if (node.Right != null) yield return node.Right;
    }

    public PathResult Query(string sourceLabel, string destinationLabel)
    {
        if (_tree == null || _nextHop == null || _labelToIndex == null || _nodeToIndex == null)
            throw new InvalidOperationException("Strategy not built. Call Build() first.");

        if (!_labelToIndex.TryGetValue(sourceLabel, out int sourceIndex))
            throw new ArgumentException($"Source label '{sourceLabel}' not found.");
        if (!_labelToIndex.TryGetValue(destinationLabel, out int destinationIndex))
            throw new ArgumentException($"Destination label '{destinationLabel}' not found.");

        if (sourceIndex == destinationIndex)
        {
            return new PathResult
            {
                Distance = 0,
                Directions = Array.Empty<string>()
            };
        }

        var directions = new List<string>();
        int currentIndex = sourceIndex;
        int stepCount = 0;

        while (currentIndex != destinationIndex)
        {
            int nextIndex = _nextHop![currentIndex, destinationIndex];
            if (nextIndex == -1)
                throw new InvalidOperationException($"No path between {sourceLabel} and {destinationLabel}");

            directions.Add(GetDirection(_tree!.Nodes[currentIndex], _tree.Nodes[nextIndex]));
            currentIndex = nextIndex;
            stepCount++;

            // é˜²è­·ï¼šé¿å…ç†è«–å¤–çš„å¾ªç’°
            if (stepCount > _tree.Nodes.Count)
                throw new InvalidOperationException("Detected unexpected loop while following nextHop.");
        }

        return new PathResult
        {
            Distance = stepCount,
            Directions = directions
        };
    }

    private string GetDirection(BinaryTree.Node fromNode, BinaryTree.Node toNode)
    {
        if (fromNode.Parent == toNode) return "U";
        if (fromNode.Left == toNode) return "DL";
        if (fromNode.Right == toNode) return "DR";
        throw new InvalidOperationException("Invalid edge between nodes");
    }
}
```

### ä¿®æ­£é‡é»

* **å…ˆ BFS å®Œæˆ â†’ å†å›æº¯å¡«è¡¨**ï¼Œä¸å†ä¾è³´ã€Œçˆ¶ç¯€é»çš„ first hop å·²ç¶“åœ¨è¡¨ä¸­ã€é€™å€‹éš±å«å‰æï¼Œå› æ­¤ä¸æœƒæœ‰ T3 é€™ç¨®æ·±éˆè¢«èª¤åˆ¤çš„æƒ…æ³ã€‚
* å‘½åå…¨éƒ¨èªç¾©åŒ–ï¼Œæ˜“è®€æ˜“ç¶­è­·ã€‚
* åŠ ä¸Š **ä¿è­·æ€§æª¢æŸ¥**ï¼ˆä¾‹å¦‚é˜²ç„¡é™è¿´åœˆï¼‰ã€‚

è«‹æŠŠé€™å€‹ç‰ˆæœ¬æ›ä¸Šå¾Œå†è·‘ä¸€æ¬¡ä½ çš„æ¸¬è©¦ï¼ˆç‰¹åˆ¥æ˜¯ T3ï¼š`"A,B,,C,,,,D"`ï¼Œ`Aâ†’D` æœŸæœ› `DL,DL,DL`ï¼‰ã€‚å¦‚æœä½ é¡˜æ„ï¼Œä¸‹ä¸€æ­¥æˆ‘å¯ä»¥æŠŠ **Benchmark æ¸¬è©¦**ä¹Ÿè£œé½Šï¼Œé‡æ¸¬å››ç¨®ç­–ç•¥åœ¨ T1/T8/T9/T10 ä¸Šçš„å»ºè¡¨æ™‚é–“ã€æŸ¥è©¢å»¶é²èˆ‡è¨˜æ†¶é«”ä½¿ç”¨é‡ã€‚

Question : 
ç›®å‰ T4 T8 T9 T10 éƒ½æ˜¯éŒ¯çš„ï¼Œæˆ‘çœ‹åˆ°å¾—å•é¡Œæ˜¯ï¼Œæˆ‘å€‘æ˜¯ä¸æ˜¯æ²’æœ‰è™•ç†åˆ°åè½‰çš„æ–¹å‘é‚è¼¯? 

Answer : 

ä½ æŠ“åˆ°çš„ã€Œåè½‰ã€å…¶å¯¦ä¸æ˜¯æ ¹å› ã€‚
T4 / T8 / T9 / T10 å¤±æ•—çš„çœŸæ­£åŸå› æ˜¯ï¼š**ç”¨ level-order CSV ä¾†è¡¨é”ã€Œæ·±åº¦å¾ˆæ·±ã€åå‘å–®é‚Šã€çš„æ¨¹ï¼Œç´¢å¼•æ˜¯ 2*i+1 / 2*i+2ï¼Œæ‰€ä»¥éœ€è¦ã€ŒæŒ‡æ•¸ç´šçš„ç©ºæ¬„ä½ã€ï¼Œä½ æˆ‘æ‰‹å¯«çš„ CSV ä¸å¤ é•·ï¼ˆä½ç½®ä¸æ­£ç¢ºï¼‰ï¼Œå°è‡´ç¯€é»æ ¹æœ¬æ²’é€£åˆ°åŒä¸€æ£µæ¨¹**ã€‚å› æ­¤ `_nextHop[cur, dst] == -1` æ‰æœƒä¸Ÿå‡º â€œNo path â€¦â€ã€‚

### ç‚ºä»€éº¼æœƒé€™æ¨£ï¼Ÿ

* å·¦å­ç´¢å¼• = `2*i+1`ã€å³å­ç´¢å¼• = `2*i+2`ã€‚
  ä¾‹å¦‚å³åéˆ `A->B->C->D` çš„ç´¢å¼•æ˜¯ï¼š`0, 2, 6, 14`ã€‚
  ä»£è¡¨ CSV é•·åº¦è‡³å°‘è¦åˆ° index 14ï¼ˆä¹Ÿå°±æ˜¯ 15 æ ¼ï¼‰ï¼Œä¸­é–“å…¨æ˜¯ç©ºå­—ä¸²ã€‚
* æ·±åº¦ 10 çš„ç´”å·¦éˆç´¢å¼•æ˜¯ï¼š`0, 1, 3, 7, 15, 31, 63, 127, 255, 511`ï¼›
  CSV è¦åˆ° **ç¬¬ 512 æ ¼**ï¼å¦‚æœæ‰‹å‹•æ‰“å¹¾å€‹é€—è™Ÿï¼Œä½ç½®ä¸€å®šéŒ¯ã€‚

---

## è§£æ³•ï¼šæ–°å¢ã€Œæ¸¬è©¦ç”¨ CSV ç”¢ç”Ÿå™¨ã€

è®“æˆ‘å€‘ç”¨ç¨‹å¼**ç²¾æº–ç”Ÿæˆ**æ­£ç¢ºçš„ level-order CSVï¼Œé¿å…äººå·¥éŒ¯ä½ã€‚ä¸‹é¢é€™å€‹ `LevelOrderCsvBuilder` å¯ä»¥å»ºç«‹ï¼š

* ç´”å·¦éˆ / ç´”å³éˆï¼ˆæŒ‡å®šæ·±åº¦ï¼‰
* Zig-Zag éˆï¼ˆå·¦ã€å³äº¤éŒ¯ï¼‰
* ä¹Ÿèƒ½ç”¨ã€Œç´¢å¼•â†’æ¨™ç±¤ã€å°ç…§è¡¨ç›´æ¥ç”¢ CSV

æŠŠå®ƒåŠ åˆ° `Tests` å°ˆæ¡ˆï¼ˆæˆ–ä¸€å€‹ TestUtilities æª”æ¡ˆï¼‰ï¼š

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace BinaryTreePathFinder.Tests;

public static class LevelOrderCsvBuilder
{
    public static string BuildLeftSkewedCsv(int depth)
        => BuildCsvByIndices(EnumerateSkewedIndices(depth, goLeftFirst: true));

    public static string BuildRightSkewedCsv(int depth)
        => BuildCsvByIndices(EnumerateSkewedIndices(depth, goLeftFirst: false));

    public static string BuildZigZagCsv(int depth, bool startLeft = true)
        => BuildCsvByIndices(EnumerateZigZagIndices(depth, startLeft));

    public static string BuildCsvFromIndexMap(IDictionary<int, string> indexToLabel)
    {
        if (indexToLabel == null || indexToLabel.Count == 0) return string.Empty;
        int maxIndex = indexToLabel.Keys.Max();
        var slots = new string[maxIndex + 1];
        for (int i = 0; i <= maxIndex; i++) slots[i] = string.Empty;
        foreach (var kv in indexToLabel) slots[kv.Key] = kv.Value ?? string.Empty;
        return string.Join(",", slots);
    }

    private static string BuildCsvByIndices(IList<int> indices)
    {
        var map = new Dictionary<int, string>();
        for (int i = 0; i < indices.Count; i++)
        {
            map[indices[i]] = Label(i); // A..Jï¼ˆæ·±åº¦<=26 å¯ç”¨ï¼‰
        }
        return BuildCsvFromIndexMap(map);
    }

    private static IList<int> EnumerateSkewedIndices(int depth, bool goLeftFirst)
    {
        var list = new List<int>(depth);
        int idx = 0;
        for (int d = 0; d < depth; d++)
        {
            list.Add(idx);
            idx = goLeftFirst ? (2 * idx + 1) : (2 * idx + 2);
        }
        return list;
    }

    private static IList<int> EnumerateZigZagIndices(int depth, bool startLeft)
    {
        var list = new List<int>(depth);
        int idx = 0;
        bool goLeft = startLeft;
        for (int d = 0; d < depth; d++)
        {
            list.Add(idx);
            idx = goLeft ? (2 * idx + 1) : (2 * idx + 2);
            goLeft = !goLeft;
        }
        return list;
    }

    private static string Label(int i)
    {
        // A..Z, AA..ï¼›å°æˆ‘å€‘æ¸¬è©¦(<=10)åªæœƒåˆ° J
        var sb = new StringBuilder();
        i = Math.Max(i, 0);
        do
        {
            int r = i % 26;
            sb.Insert(0, (char)('A' + r));
            i = i / 26 - 1;
        } while (i >= 0);
        return sb.ToString();
    }
}
```

---

## æ›´æ–°æ¸¬è©¦ï¼šç”¨ç”¢ç”Ÿå™¨é‡å»º T3/T4/T8/T9/T10 çš„ CSV

æŠŠ `TreeTestCases.GetCases()` è£¡é€™å¹¾å€‹ç”¨æ‰‹å¯« CSV çš„æ¡ˆä¾‹ï¼Œæ”¹æˆä¸‹åˆ—ç‰ˆæœ¬ï¼ˆ**å…¶é¤˜ T1/T2/T5 å¯ç¶­æŒæ‰‹å¯«**ï¼‰ï¼š

```csharp
// T3ï¼šå·¦å 4 å±¤ A->B->C->D
yield return new object[]
{
    LevelOrderCsvBuilder.BuildLeftSkewedCsv(4),
    "A", "D", 3,
    new[] { "DL","DL","DL" },
@"
    A
   /
  B
 /
C
/
D
"
};

// T4ï¼šå³å 4 å±¤ A->B->C->D
yield return new object[]
{
    LevelOrderCsvBuilder.BuildRightSkewedCsv(4),
    "A", "D", 3,
    new[] { "DR","DR","DR" },
@"
A
 \
  B
   \
    C
     \
      D
"
};

// T8ï¼šå·¦å 10 å±¤ A..J
yield return new object[]
{
    LevelOrderCsvBuilder.BuildLeftSkewedCsv(10),
    "A", "J", 9,
    new[] { "DL","DL","DL","DL","DL","DL","DL","DL","DL" },
@"
A
/
B
/
C
/
D
/
E
/
F
/
G
/
H
/
I
/
J
"
};

// T9ï¼šå³å 10 å±¤ A..J
yield return new object[]
{
    LevelOrderCsvBuilder.BuildRightSkewedCsv(10),
    "A", "J", 9,
    new[] { "DR","DR","DR","DR","DR","DR","DR","DR","DR" },
@"
A
 \
  B
   \
    C
     \
      D
       \
        E
         \
          F
           \
            G
             \
              H
               \
                I
                 \
                  J
"
};

// T10ï¼šZigZag 10 å±¤ï¼ˆå·¦èµ·ï¼‰
yield return new object[]
{
    LevelOrderCsvBuilder.BuildZigZagCsv(10, startLeft: true),
    "A", "J", 9,
    new[] { "DL","DR","DL","DR","DL","DR","DL","DR","DL" },
@"
A
/
B
 \
  C
 /
D
 \
  E
 /
F
 \
  G
 /
H
 \
  I
 /
J
"
};
```

> é€™æ¨£ç”Ÿæˆçš„ CSV æœƒ**ç²¾æº–å°æ‡‰**æ¨¹çš„ç´¢å¼•ä½ç½®ï¼Œ`BinaryTree.BuildFromCsv` é€£æ¥çš„ Parent/Left/Right ä¸€å®šæ­£ç¢ºï¼Œ`NextHopMatrixStrategy` / `NextDirection*` / `LCA` éƒ½æœƒéã€‚

---

## é—œæ–¼ä½ æåˆ°ã€Œåè½‰æ–¹å‘ã€çš„ç–‘æ…®

* æˆ‘å€‘ç›®å‰çš„ä¸‰å€‹çŸ©é™£ç­–ç•¥ï¼ˆNextHop / NextDirection / NextDirection+Distanceï¼‰éƒ½æ˜¯**å°æ¯å€‹ source éƒ½å»ºè¡¨**ï¼Œå› æ­¤æŸ¥è©¢ `(u,v)` ä¸éœ€è¦æ‹¿ `(v,u)` å†åè½‰æ–¹å‘ï¼Œä¸æœƒæœ‰åè½‰å•é¡Œã€‚
* `LCA` ç­–ç•¥åœ¨çµ„è·¯å¾‘æ™‚ï¼Œ`uâ†’LCA` ä¸€æ®µå…¨ `U`ï¼Œ`vâ†’LCA` åè½‰æˆ `LCAâ†’v` å†ç”¨ `DL/DR`ï¼Œé€™éƒ¨åˆ†é‚è¼¯å·²åœ¨ç¨‹å¼å…§è™•ç†ï¼Œä¸æœƒå‡ºéŒ¯ã€‚
* å…ˆå‰æ‹‹ â€œNo path â€¦â€ çš„åŸå› å°±æ˜¯ **CSV å°ä¸åˆ°é æœŸçµæ§‹**ï¼Œä¸æ˜¯åè½‰ã€‚

---

## ä¸‹ä¸€æ­¥

1. æŠŠä¸Šé¢çš„ **LevelOrderCsvBuilder** æ”¾é€² `Tests`ã€‚
2. æ›´æ–° T3 / T4 / T8 / T9 / T10 çš„æ¸¬è³‡æ”¹ç”¨ç”¢ç”Ÿå™¨ã€‚
3. é‡æ–°è·‘å››ç¨®ç­–ç•¥çš„æ¸¬è©¦ï¼Œæ‡‰è©²å…¨éƒ¨ç¶ ç‡ˆã€‚

å¦‚æœä½ è¦ï¼Œæˆ‘ä¹Ÿå¯ä»¥ç›´æ¥æŠŠ **Benchmark** é‚£æ”¯è£œé½Šï¼ˆå»ºè¡¨æ™‚é–“ã€æŸ¥è©¢æ™‚é–“ã€åˆ†é…é‡ï¼‰è®“ä½ æ¯”è¼ƒå››ç¨®ç­–ç•¥åœ¨ T1/T8/T9/T10 çš„è¡¨ç¾ã€‚


Question : 
æˆ‘æƒ³è¦åŠ ä¸€å€‹é©—è­‰ æ˜¯è¤‡è£½ T10 çš„æ¨¹ä¸€æ¨¡ä¸€æ¨£ï¼Œä½†æ˜¯é€™æ¬¡æ˜¯ J åˆ° A ï¼Œæˆ‘æƒ³è¦é©—è­‰é€™æ¨£å‡ºä¾†è·Ÿ T10 æœ‰æ²’æœ‰å‰›å¥½ç›¸å

Answer : 

å¯ä»¥ï¼æˆ‘å¹«ä½ åŠ ä¸€å€‹ã€ŒT10 åå‘é©—è­‰ã€çš„æ¸¬è©¦ï¼šç”¨ **åŒä¸€æ£µ Zig-Zag æ·±åº¦ 10 çš„æ¨¹**ï¼Œå…ˆæŸ¥ `Aâ†’J`ï¼ˆDL/DR äº¤éŒ¯ï¼‰ï¼Œå†æŸ¥ `Jâ†’A`ï¼Œæª¢æŸ¥ï¼š

1. å…©è€…è·é›¢ç›¸ç­‰ã€‚
2. `Jâ†’A` çš„æ–¹å‘åºåˆ—æ˜¯å¦ç‚º `InvertAndReverse(Aâ†’J)`ï¼ˆå°é€™æ£µæ¨¹æœƒæ˜¯å…¨ `U`ï¼‰ã€‚

> æ³¨æ„ï¼šä¸€èˆ¬ä¾†èªª `U` çš„åå‘éœ€è¦ä¸Šä¸‹æ–‡åˆ¤æ–·ï¼ˆæ˜¯ `DL` æˆ– `DR`ï¼‰ï¼Œä½†åœ¨ `Aâ†’J` é€™æ¢ Zig-Zag è·¯å¾‘è£¡ä¸å« `U`ï¼Œå› æ­¤å¯å®‰å…¨åœ°ç”¨è¦å‰‡ `DL|DR â†’ U` åè½‰ã€‚

æŠŠä¸‹é¢ç¨‹å¼ç¢¼åŠ å…¥ `PathStrategyTests.cs`ï¼ˆèˆ‡ç¾æœ‰å››å€‹ç­–ç•¥å…±åŒé©—è­‰ï¼‰ï¼š

```csharp
using System.Linq;
using Xunit;
using BinaryTreePathFinder.Core;
using System.Collections.Generic;

namespace BinaryTreePathFinder.Tests;

public partial class PathStrategyTests
{
    [Fact]
    public void T10_ZigZag_ReversePath_ShouldBeInverse()
    {
        // å»ºåŒä¸€æ£µ ZigZag æ·±åº¦ 10 çš„æ¨¹ï¼ˆA..Jï¼‰
        string csv = LevelOrderCsvBuilder.BuildZigZagCsv(10, startLeft: true);
        var tree = BinaryTreePathFinder.Core.BinaryTree.BuildFromCsv(csv);

        var strategies = new IPathStrategy[]
        {
            new NextHopMatrixStrategy(),
            new NextDirectionMatrixStrategy(),
            new NextDirectionWithDistanceStrategy(),
            new LowestCommonAncestorStrategy()
        };

        const string summary = @"
A
/
B
 \
  C
 /
D
 \
  E
 /
F
 \
  G
 /
H
 \
  I
 /
J
";

        foreach (var s in strategies)
        {
            s.Build(tree);

            var forward = s.Query("A", "J"); // æœŸæœ› 9 æ­¥ï¼ŒDL/DR äº¤éŒ¯
            var reverse = s.Query("J", "A"); // æœŸæœ› 9 æ­¥ï¼Œå…¨ U

            // 1) è·é›¢ç›¸ç­‰
            Assert.Equal(forward.Distance, reverse.Distance);

            // 2) åå‘åºåˆ—æ‡‰ç­‰æ–¼ InvertAndReverse(forward)
            var expectedReverse = InvertAndReverse(forward.Directions);
            Assert.Equal(expectedReverse, reverse.Directions);
        }

        System.Diagnostics.Debug.WriteLine(summary);
    }

    /// <summary>
    /// å°‡ forward æ–¹å‘åºåˆ—ã€Œååº + å–®æ­¥åå‘ã€å¾Œå¾—åˆ° reverse æ–¹å‘åºåˆ—ã€‚
    /// æ³¨æ„ï¼šåå‘ 'U' éœ€è¦ä¸Šä¸‹æ–‡ï¼ˆæ˜¯ DL æˆ– DRï¼‰ï¼Œæ­¤æ–¹æ³•åƒ…ç”¨æ–¼
    /// forward ä¸å« 'U' çš„æƒ…å¢ƒï¼ˆä¾‹å¦‚ ZigZag çš„ Aâ†’Jï¼‰ï¼Œå¦å‰‡æœƒä¸Ÿä¾‹å¤–ã€‚
    /// </summary>
    private static IReadOnlyList<string> InvertAndReverse(IReadOnlyList<string> forwardDirections)
    {
        var list = new List<string>(forwardDirections.Count);
        for (int i = forwardDirections.Count - 1; i >= 0; i--)
        {
            var d = forwardDirections[i];
            switch (d)
            {
                case "DL":
                case "DR":
                    list.Add("U"); // å­â†’çˆ¶
                    break;
                case "U":
                    throw new InvalidOperationException("Cannot invert 'U' without tree context.");
                default:
                    throw new InvalidOperationException($"Unknown direction '{d}'.");
            }
        }
        return list;
    }
}
```

é€™å€‹æ¸¬è©¦æœƒå° **å››ç¨®ç­–ç•¥** åŒæ­¥æª¢æŸ¥ï¼Œç¢ºä¿ `Jâ†’A` çš„è·¯å¾‘æ­£æ˜¯ `Aâ†’J` çš„ã€Œåå‘ã€ã€‚å¦‚æœä½ æƒ³å†åš´æ ¼ä¸€é»ï¼Œä¹Ÿå¯ä»¥å¦å¤–åŠ ä¸€å€‹æ–·è¨€ç¢ºèª `forward.Directions` æ°ç‚º `["DL","DR","DL","DR","DL","DR","DL","DR","DL"]`ã€‚éœ€è¦çš„è©±æˆ‘ä¹Ÿå¯ä»¥åŠ ä¸Šã€‚

Question : 
æˆ‘æƒ³è¦é¡å¤–å¤šåŠ ä¸€å€‹æ–·è¨€æ˜¯ forward.Directions æ°ç‚º ["DL","DR","DL","DR","DL","DR","DL","DR","DL"]


Answer : 
ğŸ‘Œ å®Œå…¨æ²’å•é¡Œï¼Œæˆ‘å€‘å¯ä»¥åœ¨å‰›æ‰çš„æ¸¬è©¦è£¡ **é¡å¤–æ–·è¨€ forward è·¯å¾‘å›ºå®šç‚º ZigZag é æœŸ**ã€‚
é€™æ¨£ä¸€ä¾†å°±èƒ½ç¢ºä¿ã€ŒAâ†’Jã€çš„è¼¸å‡ºç¬¦åˆæˆ‘å€‘æƒ³è¦çš„æ¨¡å¼ï¼Œè€Œä¸æ˜¯åªæ˜¯å‰›å¥½åå‘å»åˆã€‚

---

## æ›´æ–°å¾Œçš„æ¸¬è©¦ç¨‹å¼ç¢¼

```csharp
using System.Linq;
using Xunit;
using BinaryTreePathFinder.Core;
using System.Collections.Generic;

namespace BinaryTreePathFinder.Tests;

public partial class PathStrategyTests
{
    [Fact]
    public void T10_ZigZag_ReversePath_ShouldBeInverse()
    {
        // å»ºåŒä¸€æ£µ ZigZag æ·±åº¦ 10 çš„æ¨¹ï¼ˆA..Jï¼‰
        string csv = LevelOrderCsvBuilder.BuildZigZagCsv(10, startLeft: true);
        var tree = BinaryTreePathFinder.Core.BinaryTree.BuildFromCsv(csv);

        var strategies = new IPathStrategy[]
        {
            new NextHopMatrixStrategy(),
            new NextDirectionMatrixStrategy(),
            new NextDirectionWithDistanceStrategy(),
            new LowestCommonAncestorStrategy()
        };

        const string summary = @"
A
/
B
 \
  C
 /
D
 \
  E
 /
F
 \
  G
 /
H
 \
  I
 /
J
";

        var expectedForward = new[] { "DL","DR","DL","DR","DL","DR","DL","DR","DL" };

        foreach (var s in strategies)
        {
            s.Build(tree);

            var forward = s.Query("A", "J"); // æ‡‰è©²æ˜¯ ZigZag çš„ 9 æ­¥
            var reverse = s.Query("J", "A"); // æ‡‰è©²æ˜¯å…¨ U çš„ 9 æ­¥

            // 1) è·é›¢ç›¸ç­‰
            Assert.Equal(forward.Distance, reverse.Distance);

            // 2) Forward directions è¦å®Œå…¨ç¬¦åˆ ZigZag é æœŸ
            Assert.Equal(expectedForward, forward.Directions);

            // 3) åå‘åºåˆ—æ‡‰ç­‰æ–¼ InvertAndReverse(forward)
            var expectedReverse = InvertAndReverse(forward.Directions);
            Assert.Equal(expectedReverse, reverse.Directions);
        }

        System.Diagnostics.Debug.WriteLine(summary);
    }

    /// <summary>
    /// å°‡ forward æ–¹å‘åºåˆ—ã€Œååº + å–®æ­¥åå‘ã€å¾Œå¾—åˆ° reverse æ–¹å‘åºåˆ—ã€‚
    /// æ³¨æ„ï¼šåå‘ 'U' éœ€è¦ä¸Šä¸‹æ–‡ï¼ˆæ˜¯ DL æˆ– DRï¼‰ï¼Œæ­¤æ–¹æ³•åƒ…ç”¨æ–¼
    /// forward ä¸å« 'U' çš„æƒ…å¢ƒï¼ˆä¾‹å¦‚ ZigZag çš„ Aâ†’Jï¼‰ï¼Œå¦å‰‡æœƒä¸Ÿä¾‹å¤–ã€‚
    /// </summary>
    private static IReadOnlyList<string> InvertAndReverse(IReadOnlyList<string> forwardDirections)
    {
        var list = new List<string>(forwardDirections.Count);
        for (int i = forwardDirections.Count - 1; i >= 0; i--)
        {
            var d = forwardDirections[i];
            switch (d)
            {
                case "DL":
                case "DR":
                    list.Add("U"); // å­â†’çˆ¶
                    break;
                case "U":
                    throw new InvalidOperationException("Cannot invert 'U' without tree context.");
                default:
                    throw new InvalidOperationException($"Unknown direction '{d}'.");
            }
        }
        return list;
    }
}
```

---

é€™æ¨£ `T10` çš„æ¸¬è©¦æœƒåš´æ ¼æª¢æŸ¥ä¸‰ä»¶äº‹ï¼š

1. **è·é›¢**ï¼š`Aâ†’J` èˆ‡ `Jâ†’A` ç›¸ç­‰ã€‚
2. **Forward è·¯å¾‘**ï¼šå›ºå®šå¿…é ˆæ˜¯ `["DL","DR","DL","DR","DL","DR","DL","DR","DL"]`ã€‚
3. **Reverse è·¯å¾‘**ï¼šå¿…é ˆæ˜¯ `InvertAndReverse(forward)`ï¼Œä¹Ÿå°±æ˜¯å…¨ `U`ã€‚

---

è¦ä¸è¦æˆ‘å¹«ä½ æŠŠ **æ‰€æœ‰æ¸¬è³‡ (T1\~T10) çš„ forward è·¯å¾‘** éƒ½å¯«æˆã€Œå›ºå®š expected è·¯å¾‘æ–·è¨€ã€ï¼Ÿé€™æ¨£å–®å…ƒæ¸¬è©¦æ›´åš´æ ¼ï¼Œå¯ä»¥é¿å…ç­–ç•¥å¯¦ä½œå·æ‡¶åªçµ¦å‡ºæ­£ç¢ºè·é›¢ã€‚


Question : 
InvertAndReverse é€™å€‹æ–¹æ³•ä¸è©²æ˜¯æ”¾åœ¨ strategy å…§å—? é€™äº›ç­–ç•¥ç¢ºå¯¦æ‡‰è©²è¦æœ‰è™•ç†åè½‰æŸ¥è©¢çš„æ–¹æ³•æ‰å°? é‚„æ˜¯æœ‰å…¶ä»–è€ƒé‡?

Answer : 
è¶…å¥½çš„å•é¡Œï¼æˆ‘åˆ†å…©å±¤ä¾†å›æ‡‰ï¼š

# ç‚ºä»€éº¼ä¸æŠŠ `InvertAndReverse` æ”¾é€²å„å€‹ç­–ç•¥ï¼Ÿ

çŸ­ç­”ï¼š**ä¸éœ€è¦ä¹Ÿä¸å®‰å…¨**ã€‚

* ä½ è¦çš„ã€Œåå‘æŸ¥è©¢ã€å…¶å¯¦æœ€ä½³å¯¦ä½œå°±æ˜¯**ç›´æ¥æŸ¥ `(destination, source)`**ã€‚æ‰€æœ‰ç­–ç•¥ç¾åœ¨éƒ½èƒ½åšåˆ°ï¼Œè€Œä¸”é€™æ˜¯æœ€ç©©ã€æœ€ç°¡æ½”ã€é›¶æ¨æ¸¬çš„ä½œæ³•ã€‚
* ç´”é æ–¹å‘å­—ä¸²åšåè½‰æœ‰é¢¨éšªï¼š`U` çš„åå‘æœƒæ˜¯ `DL` é‚„æ˜¯ `DR` å–æ±ºæ–¼**ç•¶ä¸‹ç¯€é»åœ¨çˆ¶ç¯€é»çš„å·¦å³ä½ç½®**ï¼Œå–®çœ‹å­—ä¸²ç„¡æ³•åˆ¤æ–·ã€‚
* æˆ‘å€‘åœ¨æ¸¬è©¦è£¡ç”¨ `InvertAndReverse` åªæ˜¯ç‚ºäº†**ç‰¹ä¾‹**ï¼ˆforward ä¸å« `U` çš„ zig-zagï¼‰ï¼Œæ–¹ä¾¿é©—è­‰å°ç¨±æ€§ï¼Œä¸¦ä¸æ˜¯å»ºè­°åœ¨ç­–ç•¥ä¸­é å­—ä¸²åè½‰ä¾†å¾—åˆ°åå‘è·¯å¾‘ã€‚

# æ¨è–¦åšæ³•ï¼ˆå¯¦å‹™ï¼‰

* åœ¨å°å¤– API ä¿æŒ**å–®ä¸€æ–¹æ³•**ï¼š`Query(source, destination)`ã€‚
* éœ€è¦åå‘æ™‚ï¼Œ**ç›´æ¥å‘¼å«**ï¼š`Query(destination, source)`ã€‚é€™æ¨£æ¯å€‹ç­–ç•¥éƒ½æœƒç”¨è‡ªå·±æœ€æ­£ç¢ºçš„å…§éƒ¨è³‡æ–™ï¼ˆnextHop/nextDir/LCAï¼‰ä¾†ç®—ï¼Œä¸éœ€è¦é¡å¤–åæ¨ã€‚

ä½ è‹¥æƒ³è¦èªæ„æ›´æ¸…æ¥šçš„å‘¼å«æ–¹å¼ï¼Œæˆ‘å€‘å¯ä»¥åŠ ä¸€å€‹**æ“´å……æ–¹æ³•**ï¼ˆæ‰€æœ‰ç­–ç•¥é€šç”¨ï¼‰ï¼š

```csharp
namespace BinaryTreePathFinder.Core;

public static class PathStrategyExtensions
{
    /// <summary>
    /// åå‘æŸ¥è©¢çš„èªæ„ç³–ï¼šç­‰åŒæ–¼ Query(destination, source)
    /// </summary>
    public static PathResult QueryReverse(this IPathStrategy strategy, string source, string destination)
        => strategy.Query(destination, source);
}
```

é€™æ¨£åœ¨æ¸¬è©¦æˆ–æ¥­å‹™ç¨‹å¼ç¢¼ä¸­å°±èƒ½å¯«ï¼š`strategy.QueryReverse("A", "J")`ï¼Œèªæ„éå¸¸ç›´è¦ºï¼ŒåŒæ™‚ä¿ç•™æ­£ç¢ºæ€§èˆ‡ä¸€è‡´æ€§ã€‚

# å¦‚æœä½ çœŸçš„æƒ³ã€Œä¸é‡æ–°æŸ¥è©¢ã€å°±æŠŠ forward è·¯å¾‘åæˆ reverseï¼Ÿ

å¯ä»¥ï¼Œä½†è¦**å¸¶æ¨¹çš„ä¸Šä¸‹æ–‡**ä¾†é€æ­¥è§£ç¢¼æ¯ä¸€æ­¥ï¼Œå†åå‘ï¼š

* ä½ éœ€è¦çŸ¥é“èµ·é»ç¯€é»ï¼Œæ²¿è‘— `forward.Directions` åœ¨æ¨¹ä¸Šèµ°å‡º**ç¯€é»åºåˆ—**ï¼ˆ`Aâ†’â€¦â†’J`ï¼‰ï¼Œ
* åè½‰ç¯€é»åºåˆ—ï¼Œå†é€æ­¥æ¯”è¼ƒçˆ¶å­é—œä¿‚ç”¢ç”Ÿ `U / DL / DR`ã€‚
  é€™å…¶å¯¦è·Ÿå†è·‘ä¸€æ¬¡ `Query(destination, source)` åœ¨è¤‡é›œåº¦ä¸Šå·®ä¸å¤šï¼Œé‚„å¤šäº†æ˜“éŒ¯é»ã€‚å› æ­¤æˆ‘ä»å»ºè­°**ç›´æ¥é‡æŸ¥**ã€‚

å¦‚æœä½ è¦ï¼Œæˆ‘ä¹Ÿå¯ä»¥å¹«ä½ æ”¾ä¸€å€‹**å®‰å…¨ç‰ˆçš„å·¥å…·æ–¹æ³•**ï¼ˆç”¨æ¨¹ä¸Šä¸‹æ–‡ä¾†åè½‰ï¼‰åœ¨ `Tests` æˆ– `Core/PathUtils`ï¼ˆé¸ä¸€ï¼‰ï¼š

```csharp
public static class PathUtils
{
    // éœ€è¦ BinaryTree èˆ‡èµ·é»æ¨™ç±¤ï¼Œæ‰èƒ½æ²¿ forward èµ°å‡ºç¯€é»åºåˆ—
    public static IReadOnlyList<string> ReverseDirectionsSafely(
        BinaryTree tree,
        string startLabel,
        IReadOnlyList<string> forwardDirections)
    {
        var node = tree.IndexByLabel[startLabel];
        var pathNodes = new List<BinaryTree.Node> { node };

        // å…ˆèµ°å‡º forward çš„ç¯€é»åºåˆ—
        foreach (var d in forwardDirections)
        {
            node = d switch
            {
                "U"  => node.Parent ?? throw new InvalidOperationException("Invalid U"),
                "DL" => node.Left   ?? throw new InvalidOperationException("Invalid DL"),
                "DR" => node.Right  ?? throw new InvalidOperationException("Invalid DR"),
                _    => throw new InvalidOperationException($"Unknown dir {d}")
            };
            pathNodes.Add(node);
        }

        // åè½‰ç¯€é»åºåˆ—å¾Œï¼Œé€æ­¥åˆ¤æ–·æ–¹å‘
        pathNodes.Reverse();
        var rev = new List<string>(forwardDirections.Count);
        for (int i = 0; i < pathNodes.Count - 1; i++)
        {
            var from = pathNodes[i];
            var to   = pathNodes[i + 1];

            if (from.Parent == to) rev.Add("U");
            else if (from.Left  == to) rev.Add("DL");
            else if (from.Right == to) rev.Add("DR");
            else throw new InvalidOperationException("Non-adjacent step");
        }
        return rev;
    }
}
```

ä½†å†æ¬¡å¼·èª¿ï¼š**å¯¦å‹™ä¸Šç”¨ `Query(dest, src)` å°±å¥½**ï¼Œå¯è®€ã€æ­£ç¢ºã€å°‘å‘ã€‚

# æˆ‘å€‘ç¾åœ¨æ€éº¼åšï¼Ÿ

* ä¿æŒç­–ç•¥åªæä¾› `Build()` + `Query()`ã€‚
* åœ¨æ¸¬è©¦è£¡ï¼Œ`T10` åŠ çš„ã€Œåå‘é©—è­‰ã€é™¤äº†ç”¨ `InvertAndReverse` ä½è­‰ forward â†” reverse çš„å°ç¨±å¤–ï¼Œä¹ŸåŒæ™‚ç”¨ `strategy.Query("J","A")` ç›´æ¥é©—æ”¶**çœŸå¯¦åå‘æŸ¥è©¢**çš„çµæœï¼ˆé€™å·²åœ¨æˆ‘å€‘çš„æ¸¬è©¦è£¡åšäº†ï¼‰ã€‚
* è‹¥ä½ å–œæ­¡èªæ„ç³–ï¼Œå°±æŠŠä¸Šé¢çš„ `PathStrategyExtensions.QueryReverse` åŠ é€²å»ï¼Œç”¨èµ·ä¾†æ›´é †ã€‚

å¦‚æœä½ å¸Œæœ›æŠŠã€Œåå‘èƒ½åŠ›ã€æ­£å¼æ”¾åˆ°ä»‹é¢ï¼Œæˆ‘ä¹Ÿå¯ä»¥æŠŠ `IPathStrategy` æ“´å……æˆï¼š

```csharp
PathResult Query(string source, string destination);
PathResult QueryReverse(string source, string destination); // é è¨­å¯¦ä½œå‘¼å« Query(dest, src)
```

ä½†é€™æœ¬è³ªä¸Šåªæ˜¯èªæ³•ç³–ï¼›é‚è¼¯ä»æ˜¯**é‡æŸ¥**æœ€ç©©ã€‚


Question : 
æˆ‘èƒ½å¤ ç†è§£é‡æ–°æŸ¥è©¢å³å¯ï¼Œä½†æˆ‘ç†è§£ä¸Šï¼Œä»¥ T10 é€™å€‹æ¡ˆä¾‹  J åˆ° A ï¼Œæˆ‘å€‘çš„ç­–ç•¥æ‡‰è©²ä¹Ÿæ˜¯è¦èƒ½å¤ ç›´æ¥å°å‡º URã€ULã€URã€ULã€URã€ULã€URã€ULã€UR ?

Answer : 
å®Œå…¨å¯ä»¥ï¼Œè€Œä¸”ä½ èªªå¾—å°ï¼šåœ¨ **T10 çš„ Jâ†’A** é€™ç¨® zig-zag ä¸Šè¡Œè·¯å¾‘ï¼Œè‹¥æˆ‘å€‘æŠŠã€Œå¾€ä¸Šã€ç´°åˆ†ç‚º **UL/UR**ï¼ˆUp-Left / Up-Rightï¼‰ï¼Œå°±èƒ½ç›´è§€è¼¸å‡º `UR, UL, UR, UL, UR, UL, UR, UL, UR`ã€‚
ç‚ºäº†é”æˆé€™é»ï¼Œæˆ‘å»ºè­°æŠŠã€Œæ–¹å‘èªå½™ã€å¾åŸæœ¬ `U/DL/DR` å‡ç´šç‚º **`UL / UR / DL / DR`**ï¼Œå››ç¨®çš†ç‚ºå–®æ­¥ã€å¯é€†ã€ä¸”ä¸å«æ­§ç¾©ï¼š

* `DL` â†” `UR`ï¼ˆäº’ç‚ºåå‘ï¼‰
* `DR` â†” `UL`ï¼ˆäº’ç‚ºåå‘ï¼‰

ä¸‹é¢æ˜¯ä½ ç¾æœ‰å››å€‹ç­–ç•¥éœ€è¦åšçš„æœ€å°æ›´å‹•ï¼ˆ**åªæ”¹ã€Œç”¢ç”Ÿ/ç·¨ç¢¼æ–¹å‘ã€**ï¼›è³‡æ–™çµæ§‹èˆ‡æµç¨‹ä¸è®Šï¼‰ï¼š

---

# å…±é€šå°å·¥å…·ï¼ˆé¸æ“‡æ€§ï¼‰

```csharp
public static class DirectionTokens
{
    public const string UL = "UL";
    public const string UR = "UR";
    public const string DL = "DL";
    public const string DR = "DR";
}
```

---

# 1) NextHopMatrixStrategyï¼šæ”¹ã€Œæ–¹å‘æ¨æ–·ã€

æŠŠåŸæœ¬ `GetDirection` å¾å›å‚³ `U/DL/DR` æ”¹æˆ `UL/UR/DL/DR`ï¼š

```csharp
private string GetDirection(BinaryTree.Node fromNode, BinaryTree.Node toNode)
{
    // ä¸Šè¡Œï¼šç”±å­åˆ°çˆ¶ï¼Œéœ€åˆ¤æ–·æ˜¯å·¦å­ or å³å­
    if (fromNode.Parent == toNode)
    {
        if (toNode.Left == fromNode) return DirectionTokens.UL;
        if (toNode.Right == fromNode) return DirectionTokens.UR;
        throw new InvalidOperationException("Parent/child relation mismatch.");
    }

    // ä¸‹è¡Œï¼šçˆ¶åˆ°å­
    if (fromNode.Left == toNode)  return DirectionTokens.DL;
    if (fromNode.Right == toNode) return DirectionTokens.DR;

    throw new InvalidOperationException("Invalid edge between nodes");
}
```

> å…¶é¤˜ä¸å‹•ï¼›å› ç‚º NextHop å­˜çš„æ˜¯ã€Œä¸‹ä¸€å€‹ç¯€é»ç´¢å¼•ã€ï¼ŒæŸ¥è©¢æ™‚æ‰æŠŠç´¢å¼•è½‰æ–¹å‘ï¼Œä¸Šè¿°æ”¹æ³•å°±èƒ½æ­£ç¢ºè¼¸å‡º `UL/UR/DL/DR`ã€‚

---

# 2) NextDirectionMatrixStrategy / NextDirectionWithDistanceStrategy

é€™å…©å€‹ç­–ç•¥çš„çŸ©é™£å­˜çš„æ˜¯ã€Œç¬¬ä¸€æ­¥æ–¹å‘çš„**ä»£ç¢¼**ã€ï¼ŒåŸæœ¬åªç”¨ `Up/DownLeft/DownRight`ã€‚
è«‹æŠŠæ–¹å‘ä»£ç¢¼æ”¹æˆ **å››æ…‹**ï¼š

```csharp
private const byte None      = 0;
private const byte UpLeft    = 1; // UL
private const byte UpRight   = 2; // UR
private const byte DownLeft  = 3; // DL
private const byte DownRight = 4; // DR
```

## 2.1 ç·¨ç¢¼æ–¹å‘ï¼ˆBuild éšæ®µï¼‰

æŠŠ `EncodeDirection(from, to)` æ”¹ç‚ºï¼š

```csharp
private byte EncodeDirection(BinaryTree.Node fromNode, BinaryTree.Node toNode)
{
    if (fromNode.Parent == toNode)
    {
        if (toNode.Left == fromNode)  return UpLeft;   // UL
        if (toNode.Right == fromNode) return UpRight;  // UR
        throw new InvalidOperationException("Parent/child relation mismatch.");
    }
    if (fromNode.Left  == toNode) return DownLeft;     // DL
    if (fromNode.Right == toNode) return DownRight;    // DR
    throw new InvalidOperationException("Invalid edge between nodes");
}
```

> æ³¨æ„ï¼š`ComputeNextDirectionForSource(...)`ï¼ˆæˆ–å«è·é›¢ç‰ˆï¼‰è£¡ã€Œç¹¼æ‰¿çˆ¶ç¯€é»ç¬¬ä¸€æ­¥æ–¹å‘ã€çš„é‚è¼¯ä¸è®Šï¼›å› ç‚ºç¬¬ä¸€æ­¥æ–¹å‘ã€Œç›¸å°æ–¼ **source**ã€æ˜¯å”¯ä¸€çš„ï¼Œä¸å—å¾ŒçºŒå›æº¯é †åºå½±éŸ¿ã€‚

## 2.2 æŸ¥è©¢æ­¥é€²

* `DecodeDirection(byte)` è¦å›å‚³ `"UL"/"UR"/"DL"/"DR"` å››ç¨®ä¹‹ä¸€ã€‚
* `GetNextNode(fromNode, dirCode)`ï¼š

  * `UL/UR` éƒ½æ˜¯ã€Œå¾€çˆ¶ç¯€é»ã€ï¼Œæ‰€ä»¥éƒ½å› `fromNode.Parent`ï¼›
  * `DL` å› `fromNode.Left`ï¼›`DR` å› `fromNode.Right`ã€‚

```csharp
private string DecodeDirection(byte code) => code switch
{
    UpLeft    => DirectionTokens.UL,
    UpRight   => DirectionTokens.UR,
    DownLeft  => DirectionTokens.DL,
    DownRight => DirectionTokens.DR,
    _ => throw new InvalidOperationException("Invalid direction code")
};

private BinaryTree.Node GetNextNode(BinaryTree.Node from, byte code) => code switch
{
    UpLeft    => from.Parent ?? throw new InvalidOperationException(),
    UpRight   => from.Parent ?? throw new InvalidOperationException(),
    DownLeft  => from.Left   ?? throw new InvalidOperationException(),
    DownRight => from.Right  ?? throw new InvalidOperationException(),
    _ => throw new InvalidOperationException()
};
```

---

# 3) LowestCommonAncestorStrategyï¼šæ”¹ã€Œuâ†’LCAã€é‚£æ®µè¼¸å‡º

åŸæœ¬ `uâ†’lca` å…¨éƒ¨å° `U`ï¼Œæ”¹æˆ**é€æ­¥åˆ¤æ–·** `UL` æˆ– `UR`ï¼š

```csharp
// u â†’ lcaï¼šé€æ­¥ä¸Šè¡Œï¼Œæ¯æ­¥è¼¸å‡º UL æˆ– UR
int cur = u;
while (cur != lca)
{
    int p = _parent![0, cur];
    var curNode = _indexToNode![cur];
    var pNode   = _indexToNode[p];

    if (pNode.Left == curNode)  directions.Add(DirectionTokens.UL);
    else if (pNode.Right == curNode) directions.Add(DirectionTokens.UR);
    else throw new InvalidOperationException("Invalid parent-child relation");

    cur = p;
}

// v â†’ lca ä¸Šè¡Œï¼Œåè½‰ç‚º lca â†’ v ä¸‹è¡Œï¼ˆDL/DRï¼‰
var stack = new Stack<string>();
cur = v;
while (cur != lca)
{
    int p = _parent![0, cur];
    var pNode = _indexToNode[p];
    var cNode = _indexToNode[cur];

    if (pNode.Left == cNode) stack.Push(DirectionTokens.DL);
    else if (pNode.Right == cNode) stack.Push(DirectionTokens.DR);
    else throw new InvalidOperationException("Invalid parent-child relation");

    cur = p;
}
directions.AddRange(stack);
```

---

# 4) æ¸¬è©¦æ›´æ–°ï¼ˆT10 åå‘ï¼‰

ä½ å‰›æ–°å¢çš„åå‘æª¢æŸ¥å¯ä»¥æ”¹ç‚º**æœŸæœ›æ˜ç¢ºçš„ UL/UR**ï¼š

* `Aâ†’J`ï¼ˆstartLeft Zig-Zagï¼‰ï¼š`["DL","DR","DL","DR","DL","DR","DL","DR","DL"]`
* `Jâ†’A`ï¼ˆåå‘ï¼‰ï¼š`["UR","UL","UR","UL","UR","UL","UR","UL","UR"]`

åŒæ™‚æŠŠ `InvertAndReverse` çš„å°æ˜ è¡¨æ”¹ç‚º**å››æ…‹å¯é€†**ï¼š

```csharp
private static IReadOnlyList<string> InvertAndReverse(IReadOnlyList<string> forward)
{
    var list = new List<string>(forward.Count);
    for (int i = forward.Count - 1; i >= 0; i--)
    {
        list.Add(forward[i] switch
        {
            "DL" => "UR",
            "DR" => "UL",
            "UL" => "DR",
            "UR" => "DL",
            _    => throw new InvalidOperationException("Unknown direction")
        });
    }
    return list;
}
```

---

# å°çµ

* ä½ çš„ç›´è¦ºæ˜¯å°çš„ï¼š**ç­–ç•¥æ‡‰èƒ½ç›´æ¥è¼¸å‡º Jâ†’A çš„ `UR/UL` äº¤éŒ¯**ã€‚
* æˆ‘å€‘ä¸éœ€è¦åœ¨ç­–ç•¥ä¸­åšã€Œå­—ä¸²åè½‰ã€ï¼›åªè¦æŠŠ**æ–¹å‘èªå½™æ“´å……ç‚º UL/UR/DL/DR**ï¼Œå„ç­–ç•¥åœ¨**ç”¢ç”Ÿæ–¹å‘**é‚£ä¸€åˆ»å°±èƒ½åˆ†è¾¨ã€Œä¸Šè¡Œçš„å·¦/å³ã€ã€‚
* é€™æ˜¯**å®‰å…¨ä¸”æ­£è¦**çš„åšæ³•ï¼š

  * NextHopï¼šæŸ¥è©¢æ™‚ä¾ç¯€é»é—œä¿‚åˆ¤æ–· UL/UR/DL/DR
  * NextDirection(Â±Distance)ï¼šBuild æ™‚å°±æŠŠç¬¬ä¸€æ­¥æ–¹å‘ç·¨æˆå››æ…‹
  * LCAï¼šä¸Šè¡Œæ®µè¼¸å‡º UL/URã€ä¸‹è¡Œæ®µè¼¸å‡º DL/DR

å¦‚æœä½ è¦ï¼Œæˆ‘å¯ä»¥æŠŠå››å€‹æª”æ¡ˆçš„ã€Œå·®ç•°ç‰ˆ patchã€æ•´ç†æˆä¸€æ¬¡ commit çš„å…§å®¹ï¼ˆæˆ–ç›´æ¥è²¼ä¸Šå®Œæ•´ä¿®æ­£ç‰ˆï¼‰ã€‚


Question : 
æˆ‘ä»”ç´°æƒ³äº†ä¸€ä¸‹ç¢ºå¯¦æ²’æœ‰å¿…è¦å†åˆ† U è¦æ˜¯ L é‚„æ˜¯ R å°±ç¶­æŒ U å°±å¯ä»¥æ‰€ä»¥æˆ‘å…¶å¯¦è¦é©—è­‰çš„ T10 é€™å€‹æ¡ˆä¾‹ J åˆ° A ï¼Œæˆ‘å€‘çš„ç­–ç•¥æ‡‰è©²ä¹Ÿæ˜¯è¦èƒ½å¤ ç›´æ¥å°å‡º Uã€Uã€Uã€Uã€Uã€Uã€Uã€Uã€U é€™æ¨£å°±å¯ä»¥?
å¯ä»¥çµ¦æˆ‘ä¸€å€‹æ¸¬è©¦æ¡ˆä¾‹æ˜¯é©—è­‰é€™å€‹å¾—å—? å¯«åœ¨æˆ‘å€‘çš„ TreeTestCases è£¡é¢

Answer : 
æ²’å•é¡Œï¼æ—¢ç„¶æˆ‘å€‘æ±ºå®š**ä¸Šè¡Œå°±çµ±ä¸€è¼¸å‡º `U`**ï¼Œé€™è£¡æä¾›ä¸€å€‹ã€Œ**T10 çš„åå‘ï¼ˆJâ†’Aï¼‰**ã€æ¸¬è©¦æ¡ˆä¾‹ï¼Œç›´æ¥åŠ åˆ° `TreeTestCases.GetCases()` çš„å°¾ç«¯å³å¯ã€‚

```csharp
// ---------- T10-REVï¼ˆZigZag 10 å±¤ï¼ŒJ -> Aï¼Œçµ±ä¸€ä¸Šè¡Œè¼¸å‡º Uï¼‰ ----------
yield return new object[]
{
    LevelOrderCsvBuilder.BuildZigZagCsv(10, startLeft: true),
    "J", "A", 9,
    new[] { "U","U","U","U","U","U","U","U","U" },
@"
A
/
B
 \
  C
 /
D
 \
  E
 /
F
 \
  G
 /
H
 \
  I
 /
J
"
};
```

é€™ç­†æ¸¬è³‡æœƒé©—è­‰ï¼š

* è·é›¢ç‚º 9ï¼›
* è·¯å¾‘æ–¹å‘ç‚º 9 å€‹é€£çºŒçš„ `U`ï¼ˆç„¡éœ€åˆ† UL / URï¼‰ã€‚

Question : 
ç¾åœ¨æˆ‘å€‘å·²ç¶“é©—è­‰äº†æˆ‘å€‘çš„æ¼”ç®—æ³•ç¢ºå¯¦æ˜¯æ­£ç¢ºçš„ï¼Œä½†æ˜¯æˆ‘æƒ³çŸ¥é“ç•¶é€™æ£µæ¨¹è¢«å®Œå…¨å¡«æ»¿çš„æ™‚å€™æˆ‘å€‘å››å€‹æ¼”ç®—æ³•çš„è™•ç†é‹è¡Œæ•ˆç‡è·Ÿè¨˜æ†¶é«”å¦‚ä½• è«‹ä½¿ç”¨ LevelOrderCsvBuilder å¹«æˆ‘å€‘ç”¢å‡ºæ·±åº¦ 10 å®Œå…¨å¡«æ»¿çš„æ¨¹ ä¸¦è®“æˆ‘å¯ä»¥ä½¿ç”¨ Benchmark æ¸¬è©¦å››ç¨®æ¼”ç®—æ³•çš„æ•ˆç‡

Answer : 



å¤ªå¥½äº†ï¼æˆ‘æŠŠ**æ·±åº¦ 10 çš„å®Œå…¨äºŒå…ƒæ¨¹**ç”¢ç”Ÿå™¨åŠ åˆ° `LevelOrderCsvBuilder`ï¼Œä¸¦æä¾›ä¸€å€‹ç”¨ **BenchmarkDotNet** é‡æ¸¬å››ç¨®ç­–ç•¥ã€Œå»ºè¡¨æ™‚é–“/è¨˜æ†¶é«”ã€èˆ‡ã€ŒæŸ¥è©¢æ™‚é–“ã€çš„åŸºæº–æ¸¬è©¦ã€‚ä½ å¯ä»¥ç›´æ¥æŠŠä»¥ä¸‹æª”æ¡ˆï¼ˆæˆ–ç‰‡æ®µï¼‰åŠ é€²å°ˆæ¡ˆå¾ŒåŸ·è¡Œã€‚

---

# 1) åœ¨ `LevelOrderCsvBuilder` å¢åŠ ã€Œå®Œå…¨äºŒå…ƒæ¨¹ã€ç”¢ç”Ÿå™¨

```csharp
// Tests/LevelOrderCsvBuilder.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace BinaryTreePathFinder.Tests;

public static class LevelOrderCsvBuilder
{
    public static string BuildLeftSkewedCsv(int depth)
        => BuildCsvByIndices(EnumerateSkewedIndices(depth, goLeftFirst: true));

    public static string BuildRightSkewedCsv(int depth)
        => BuildCsvByIndices(EnumerateSkewedIndices(depth, goLeftFirst: false));

    public static string BuildZigZagCsv(int depth, bool startLeft = true)
        => BuildCsvByIndices(EnumerateZigZagIndices(depth, startLeft));

    // â¬‡ï¸ æ–°å¢ï¼šå®Œå…¨äºŒå…ƒæ¨¹ï¼ˆæ»¿æ¨¹ï¼‰ï¼Œdepth = ç¯€é»å±¤æ•¸ï¼ˆA..J = 10 å±¤ï¼‰
    // N = 2^depth - 1ï¼Œç´¢å¼• 0..N-1 é€ä¸€å¡«æ»¿
    public static string BuildCompleteTreeCsv(int depth)
    {
        if (depth <= 0) return string.Empty;
        int n = (1 << depth) - 1;
        var labels = new string[n];
        for (int i = 0; i < n; i++)
            labels[i] = SpreadsheetLabel(i); // A, B, C, ..., Z, AA, AB, ...
        return string.Join(",", labels);
    }

    public static string BuildCsvFromIndexMap(IDictionary<int, string> indexToLabel)
    {
        if (indexToLabel == null || indexToLabel.Count == 0) return string.Empty;
        int maxIndex = indexToLabel.Keys.Max();
        var slots = new string[maxIndex + 1];
        for (int i = 0; i <= maxIndex; i++) slots[i] = string.Empty;
        foreach (var kv in indexToLabel) slots[kv.Key] = kv.Value ?? string.Empty;
        return string.Join(",", slots);
    }

    private static string BuildCsvByIndices(IList<int> indices)
    {
        var map = new Dictionary<int, string>();
        for (int i = 0; i < indices.Count; i++)
            map[indices[i]] = SpreadsheetLabel(i);
        return BuildCsvFromIndexMap(map);
    }

    private static IList<int> EnumerateSkewedIndices(int depth, bool goLeftFirst)
    {
        var list = new List<int>(depth);
        int idx = 0;
        for (int d = 0; d < depth; d++)
        {
            list.Add(idx);
            idx = goLeftFirst ? (2 * idx + 1) : (2 * idx + 2);
        }
        return list;
    }

    private static IList<int> EnumerateZigZagIndices(int depth, bool startLeft)
    {
        var list = new List<int>(depth);
        int idx = 0;
        bool goLeft = startLeft;
        for (int d = 0; d < depth; d++)
        {
            list.Add(idx);
            idx = goLeft ? (2 * idx + 1) : (2 * idx + 2);
            goLeft = !goLeft;
        }
        return list;
    }

    // A..Z, AA..AZ, BA.. é€™å€‹ä½ ä¹‹å‰æ¸¬è©¦ç”¨éï¼›1023 å€‹æ¨™ç±¤ä¹Ÿè¶³å¤ 
    private static string SpreadsheetLabel(int i)
    {
        var sb = new StringBuilder();
        i = Math.Max(i, 0);
        do
        {
            int r = i % 26;
            sb.Insert(0, (char)('A' + r));
            i = i / 26 - 1;
        } while (i >= 0);
        return sb.ToString();
    }
}
```

---

# 2) åŠ å…¥ Benchmarkï¼šæ·±åº¦ 10 æ»¿æ¨¹ï¼ˆN = 2^10 âˆ’ 1 = 1023ï¼‰

é€™æ”¯åŸºæº–æ¸¬è©¦æœƒï¼š

* ç”¨ `BuildCompleteTreeCsv(depth: 10)` å»ºæ¨¹ï¼›
* é‡æ¸¬å››ç¨®ç­–ç•¥çš„ **Build()**ï¼ˆæœƒé¡¯ç¤ºåˆ†é…é‡ = è¨˜æ†¶é«”å ç”¨æ¦‚æ³ï¼‰ï¼›
* é‡æ¸¬å››ç¨®ç­–ç•¥çš„ **Query()**ï¼ˆåŒ…å«ï¼šæ ¹â†”è‘‰ã€è‘‰â†”è‘‰ æœ€é•·è·¯å¾‘ç­‰å…¸å‹æŸ¥è©¢ï¼‰ã€‚

> è¨»ï¼š`MemoryDiagnoser` æœƒçµ¦ä½ æ¯å€‹ benchmark çš„è¨˜æ†¶é«”åˆ†é…èˆ‡ Gen0/1/2 æ¬¡æ•¸ï¼›Build çš„åˆ†é…é‡å¯è¦–ç‚ºç­–ç•¥æ ¸å¿ƒè³‡æ–™çµæ§‹çš„è¦æ¨¡ã€‚

```csharp
// Tests/BenchmarkTests.cs
using System;
using System.Linq;
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Configs;
using BinaryTreePathFinder.Core;

namespace BinaryTreePathFinder.Tests;

[MemoryDiagnoser]
[SimpleJob(runtimeMoniker: RuntimeMoniker.Net80, warmupCount: 1, iterationCount: 5)]
public class CompleteDepth10Benchmarks
{
    private const int Depth = 10; // 10 å±¤ï¼ˆç¯€é»æ•¸ 2^10 - 1 = 1023ï¼‰
    private string _csv = null!;
    private BinaryTree _tree = null!;

    // æŸ¥è©¢é»ä½ï¼ˆç”¨ç´¢å¼•æ¨æ¨™ç±¤ï¼Œé¿å…ä¾è³´å‘½åè¦å‰‡ï¼‰
    private string _rootLabel = null!;
    private string _leftmostLeafLabel = null!;
    private string _rightmostLeafLabel = null!;
    private string _midLeftLabel = null!;
    private string _midRightLabel = null!;

    // å·²å»ºå¥½çš„ç­–ç•¥ï¼Œç”¨æ–¼ã€ŒæŸ¥è©¢ã€åŸºæº–
    private IPathStrategy _nextHop = null!;
    private IPathStrategy _nextDir = null!;
    private IPathStrategy _nextDirDist = null!;
    private IPathStrategy _lca = null!;

    [GlobalSetup]
    public void GlobalSetup()
    {
        _csv = LevelOrderCsvBuilder.BuildCompleteTreeCsv(Depth);
        _tree = BinaryTree.BuildFromCsv(_csv);

        // å¹¾å€‹ä»£è¡¨æ€§ç¯€é»
        int n = _tree.Nodes.Count; // 1023
        int root = 0;
        int leftmostLeaf = (1 << (Depth - 1)) - 1; // æœ€åº•å±¤æœ€å·¦
        int rightmostLeaf = (1 << Depth) - 2;      // æœ€åº•å±¤æœ€å³
        int midLeft = (1 << (Depth - 2)) - 1;      // å€’æ•¸ç¬¬äºŒå±¤æœ€å·¦
        int midRight = (1 << (Depth - 1)) - 2;     // å€’æ•¸ç¬¬ä¸€å±¤é å³ä¸€é»

        _rootLabel = _tree.Nodes[root].Label;
        _leftmostLeafLabel = _tree.Nodes[leftmostLeaf].Label;
        _rightmostLeafLabel = _tree.Nodes[rightmostLeaf].Label;
        _midLeftLabel = _tree.Nodes[midLeft].Label;
        _midRightLabel = _tree.Nodes[midRight].Label;

        // ç‚ºæŸ¥è©¢åŸºæº–æº–å‚™ã€Œå·² Build å®Œã€çš„ç­–ç•¥
        _nextHop = new NextHopMatrixStrategy();          _nextHop.Build(_tree);
        _nextDir = new NextDirectionMatrixStrategy();    _nextDir.Build(_tree);
        _nextDirDist = new NextDirectionWithDistanceStrategy(); _nextDirDist.Build(_tree);
        _lca = new LowestCommonAncestorStrategy();       _lca.Build(_tree);
    }

    // ---------------------------
    // å»ºè¡¨ï¼ˆBuildï¼‰æ•ˆèƒ½ & è¨˜æ†¶é«”
    // ---------------------------

    [Benchmark(Description = "Build NextHopMatrix")]
    public void Build_NextHopMatrix()
    {
        var s = new NextHopMatrixStrategy();
        s.Build(_tree);
    }

    [Benchmark(Description = "Build NextDirectionMatrix")]
    public void Build_NextDirectionMatrix()
    {
        var s = new NextDirectionMatrixStrategy();
        s.Build(_tree);
    }

    [Benchmark(Description = "Build NextDirectionWithDistance")]
    public void Build_NextDirectionWithDistance()
    {
        var s = new NextDirectionWithDistanceStrategy();
        s.Build(_tree);
    }

    [Benchmark(Description = "Build LowestCommonAncestor")]
    public void Build_LCA()
    {
        var s = new LowestCommonAncestorStrategy();
        s.Build(_tree);
    }

    // ---------------------------
    // æŸ¥è©¢ï¼ˆQueryï¼‰æ•ˆèƒ½
    // ---------------------------

    // 1) æ ¹ â†’ æœ€å·¦è‘‰ï¼ˆè·é›¢ = Depth - 1 = 9ï¼‰
    [Benchmark(Description = "Query NextHop: root->leftmostLeaf")]
    public int Query_NextHop_Root_To_LeftmostLeaf()
        => _nextHop.Query(_rootLabel, _leftmostLeafLabel).Distance;

    [Benchmark(Description = "Query NextDir: root->leftmostLeaf")]
    public int Query_NextDir_Root_To_LeftmostLeaf()
        => _nextDir.Query(_rootLabel, _leftmostLeafLabel).Distance;

    [Benchmark(Description = "Query NextDir+Dist: root->leftmostLeaf")]
    public int Query_NextDirDist_Root_To_LeftmostLeaf()
        => _nextDirDist.Query(_rootLabel, _leftmostLeafLabel).Distance;

    [Benchmark(Description = "Query LCA: root->leftmostLeaf")]
    public int Query_LCA_Root_To_LeftmostLeaf()
        => _lca.Query(_rootLabel, _leftmostLeafLabel).Distance;

    // 2) æœ€é•·è·¯å¾‘ï¼šæœ€å·¦è‘‰ â†” æœ€å³è‘‰ï¼ˆè·é›¢ = 2*(Depth-1) = 18ï¼‰
    [Benchmark(Description = "Query NextHop: leftmostLeaf->rightmostLeaf")]
    public int Query_NextHop_Leftmost_To_Rightmost()
        => _nextHop.Query(_leftmostLeafLabel, _rightmostLeafLabel).Distance;

    [Benchmark(Description = "Query NextDir: leftmostLeaf->rightmostLeaf")]
    public int Query_NextDir_Leftmost_To_Rightmost()
        => _nextDir.Query(_leftmostLeafLabel, _rightmostLeafLabel).Distance;

    [Benchmark(Description = "Query NextDir+Dist: leftmostLeaf->rightmostLeaf")]
    public int Query_NextDirDist_Leftmost_To_Rightmost()
        => _nextDirDist.Query(_leftmostLeafLabel, _rightmostLeafLabel).Distance;

    [Benchmark(Description = "Query LCA: leftmostLeaf->rightmostLeaf")]
    public int Query_LCA_Leftmost_To_Rightmost()
        => _lca.Query(_leftmostLeafLabel, _rightmostLeafLabel).Distance;

    // 3) ä¸­å±¤åˆ°ä¸­å±¤ï¼ˆå¸¸è¦‹æƒ…å¢ƒï¼‰
    [Benchmark(Description = "Query NextHop: midLeft->midRight")]
    public int Query_NextHop_MidLeft_To_MidRight()
        => _nextHop.Query(_midLeftLabel, _midRightLabel).Distance;

    [Benchmark(Description = "Query NextDir: midLeft->midRight")]
    public int Query_NextDir_MidLeft_To_MidRight()
        => _nextDir.Query(_midLeftLabel, _midRightLabel).Distance;

    [Benchmark(Description = "Query NextDir+Dist: midLeft->midRight")]
    public int Query_NextDirDist_MidLeft_To_MidRight()
        => _nextDirDist.Query(_midLeftLabel, _midRightLabel).Distance;

    [Benchmark(Description = "Query LCA: midLeft->midRight")]
    public int Query_LCA_MidLeft_To_MidRight()
        => _lca.Query(_midLeftLabel, _midRightLabel).Distance;
}
```

> ä½ ä¹Ÿå¯ä»¥åœ¨ `Tests` å°ˆæ¡ˆå†æ”¾ä¸€å€‹ `Program.cs` ä¾†å•Ÿå‹• Benchmarkï¼ˆæˆ–ç”¨ Test Explorer/å‘½ä»¤åˆ—åŸ·è¡Œï¼‰ï¼š

```csharp
// Tests/Program.cs ï¼ˆé¸æ“‡æ€§ï¼‰
using BenchmarkDotNet.Running;

namespace BinaryTreePathFinder.Tests;
public class Program
{
    public static void Main(string[] args)
    {
        BenchmarkRunner.Run<CompleteDepth10Benchmarks>();
    }
}
```

---

## æ€éº¼çœ‹çµæœï¼Ÿ

* **Build\*** ç³»åˆ—ï¼šæœƒé¡¯ç¤ºæ¯ç¨®ç­–ç•¥å»ºè¡¨æ‰€éœ€çš„æ™‚é–“ï¼†è¨˜æ†¶é«”åˆ†é…é‡ï¼›

  * `NextDirectionMatrix` ç´„ 4MB ç´šï¼ˆbyte çŸ©é™£ï¼‰
  * `NextHopMatrix` / `NextDirectionWithDistance` ç´„ 8MB ç´š
  * `LCA` å¹¾å KB ç´š
* **Query\*** ç³»åˆ—ï¼šéƒ½æ˜¯ã€Œå–®æ¬¡æŸ¥è©¢ã€çš„å»¶é²ï¼ˆç´ç§’\~å¾®ç§’ç­‰ç´šï¼‰ï¼Œå¯ç›´æ¥å°ç…§å››ç¨®ç­–ç•¥åœ¨ä¸åŒè·¯å¾‘é•·åº¦ä¸‹çš„è¡¨ç¾ï¼›

  * `NextDirectionWithDistance` è·é›¢ O(1)ã€è·¯å¾‘ O(è·é›¢)
  * `NextHopMatrix`/`NextDirectionMatrix` è·¯å¾‘ O(è·é›¢)
  * `LCA` LCA O(logN) + è·¯å¾‘ O(è·é›¢)ï¼Œåœ¨ N=1023ã€è·é›¢â‰¤18 å¹¾ä¹ç„¡æ„Ÿ

---

å¦‚æœä½ æƒ³åŠ ç¢¼æ¯”è¼ƒã€Œ**å¤šç­†æŸ¥è©¢**ã€çš„ååï¼ˆä¾‹å¦‚ä¸€æ¬¡è·‘ 1,000 çµ„éš¨æ©Ÿ `source/destination`ï¼‰ï¼Œæˆ‘ä¹Ÿå¯ä»¥å†è£œä¸€å€‹ benchmarkï¼Œå…§éƒ¨éš¨æ©ŸæŠ½æ¨£ä¸¦ç´¯ç©è·é›¢ä»¥é˜² JIT æ¶ˆé™¤ã€‚ä½ å…ˆè·‘è·‘çœ‹é€™ç‰ˆçš„çµæœï¼Œæˆ‘å†å¹«ä½ å„ªåŒ–å ±è¡¨æ ¼å¼æˆ–å¢åŠ ä½ é—œå¿ƒçš„ caseã€‚


Question : 
ç›®å‰ç‰ˆæœ¬è·‘å‡ºä¾†çš„çµæœå¦‚ä¸‹ï¼Œä½ æœƒå¦‚ä½•è§£è®€é€™ä»½å ±å‘Š

| Method                                            | Mean             | Error            | StdDev         | Gen0      | Gen1     | Gen2     | Allocated  |
|-------------------------------------------------- |-----------------:|-----------------:|---------------:|----------:|---------:|---------:|-----------:|
| 'Build NextHopMatrix'                             | 52,545,655.00 ns | 2,988,466.894 ns | 462,468.559 ns | 3500.0000 | 400.0000 | 100.0000 | 60115644 B |
| 'Build NextDirectionMatrix'                       | 46,187,601.82 ns | 1,247,526.685 ns | 323,978.719 ns | 3454.5455 | 272.7273 |        - | 59069048 B |
| 'Build NextDirectionWithDistance'                 | 49,227,290.00 ns | 1,829,319.464 ns | 475,068.456 ns | 3500.0000 | 400.0000 | 100.0000 | 60115702 B |
| 'Build LowestCommonAncestor'                      |     78,984.92 ns |     3,918.083 ns |   1,017.514 ns |   16.1133 |   7.9346 |        - |   270280 B |
| 'Query NextHop: root->leftmostLeaf'               |         92.67 ns |         3.377 ns |       0.877 ns |    0.0215 |        - |        - |      360 B |
| 'Query NextDir: root->leftmostLeaf'               |        180.82 ns |         3.934 ns |       0.609 ns |    0.0215 |        - |        - |      360 B |
| 'Query NextDir+Dist: root->leftmostLeaf'          |        183.46 ns |        12.243 ns |       3.180 ns |    0.0215 |        - |        - |      360 B |
| 'Query LCA: root->leftmostLeaf'                   |        200.70 ns |         5.168 ns |       1.342 ns |    0.0434 |        - |        - |      728 B |
| 'Query NextHop: leftmostLeaf->rightmostLeaf'      |        159.42 ns |         4.060 ns |       1.054 ns |    0.0381 |        - |        - |      640 B |
| 'Query NextDir: leftmostLeaf->rightmostLeaf'      |        343.96 ns |        51.227 ns |      13.303 ns |    0.0381 |        - |        - |      640 B |
| 'Query NextDir+Dist: leftmostLeaf->rightmostLeaf' |        331.23 ns |        13.395 ns |       2.073 ns |    0.0381 |        - |        - |      640 B |
| 'Query LCA: leftmostLeaf->rightmostLeaf'          |        275.89 ns |        12.879 ns |       3.345 ns |    0.0601 |        - |        - |     1008 B |
| 'Query NextHop: midLeft->midRight'                |        123.50 ns |         2.684 ns |       0.697 ns |    0.0215 |        - |        - |      360 B |
| 'Query NextDir: midLeft->midRight'                |        278.06 ns |         8.190 ns |       2.127 ns |    0.0215 |        - |        - |      360 B |
| 'Query NextDir+Dist: midLeft->midRight'           |        273.94 ns |         8.129 ns |       1.258 ns |    0.0215 |        - |        - |      360 B |
| 'Query LCA: midLeft->midRight'                    |        221.66 ns |        51.838 ns |      13.462 ns |    0.0343 |        - |        - |      576 B |


Answer : 
é€™ä»½ Benchmark å ±å‘Šæ•¸æ“šéå¸¸æœ‰ä»£è¡¨æ€§ï¼Œæˆ‘å¹«ä½ é€é …æ‹†è§£ï¼š

---

## ğŸ”¹ Build éšæ®µï¼ˆå»ºè¡¨ï¼‰

| ç­–ç•¥                         | Build è€—æ™‚ | è¨˜æ†¶é«”åˆ†é…    |
| -------------------------- | -------- | -------- |
| **NextHopMatrix**          | \~52ms   | \~60MB   |
| **NextDirectionMatrix**    | \~46ms   | \~59MB   |
| **NextDirection+Distance** | \~49ms   | \~60MB   |
| **LCA**                    | \~0.08ms | \~0.27MB |

### è§£è®€

* **ä¸‰å€‹çŸ©é™£æ³• (NextHop / NextDir / NextDir+Dist)**

  * å»ºè¡¨éœ€è¦ O(NÂ²)ï¼ŒN=1023 æ™‚å°±å·²ç¶“è¦ 50ms å·¦å³ã€60MB è¨˜æ†¶é«”ã€‚
  * é€™åªæ˜¯æ·±åº¦ 10 çš„æ»¿æ¨¹ï¼Œè‹¥æ·±åº¦å†åŠ ï¼Œæœƒå‘ˆ **å¹³æ–¹ç´šæš´å¢**ã€‚
* **LCA æ³•**

  * å»ºè¡¨åªè¦ O(N log N)ï¼Œå¹¾ä¹ 0.1ms å®Œæˆï¼Œè¨˜æ†¶é«”ä¸åˆ° 0.3MBã€‚
  * åœ¨ã€Œéœ€è¦é »ç¹é‡å»ºã€çš„å ´æ™¯ï¼ŒLCA å®Œå‹ã€‚

---

## ğŸ”¹ Query éšæ®µï¼ˆæŸ¥è©¢å–®ä¸€è·¯å¾‘ï¼‰

| æŸ¥è©¢é¡å‹               | NextHop | NextDir | NextDir+Dist | LCA     |
| ------------------ | ------- | ------- | ------------ | ------- |
| root â†’ å·¦è‘‰ (è·é›¢=9)   | \~93ns  | \~181ns | \~183ns      | \~201ns |
| å·¦è‘‰ â†’ å³è‘‰ (è·é›¢=18)    | \~159ns | \~344ns | \~331ns      | \~276ns |
| midLeft â†’ midRight | \~124ns | \~278ns | \~274ns      | \~222ns |

### è§£è®€

1. **NextHopMatrix**ï¼šæœ€å¿«ï¼Œå› ç‚ºæŸ¥è©¢æ™‚åªè¦ follow ç´¢å¼•ï¼Œæ–¹å‘åˆ¤æ–·å–®ç´”ï¼›è€Œä¸”è·é›¢ä¸é•·ï¼ˆâ‰¤18ï¼‰ï¼Œæ‰€ä»¥ O(è·é›¢) çš„ä»£åƒ¹å°ã€‚
2. **NextDirectionMatrix / NextDir+Dist**ï¼šç¨æ…¢ä¸€é»ï¼ˆå¤§ç´„ NextHop çš„ 2 å€ï¼‰ï¼ŒåŸå› æ˜¯æ¯ä¸€æ­¥è¦ decode/encode directionã€‚

   * +Distance çš„å„ªå‹¢è¦åœ¨ã€ŒåªæŸ¥è·é›¢ã€æ™‚æ‰é¡¯ç¾ï¼ˆé€™è£¡æˆ‘å€‘é‚„æ˜¯éœ€è¦è¼¸å‡ºå®Œæ•´è·¯å¾‘ï¼Œæ‰€ä»¥æ²’æœ‰å„ªå‹¢ï¼‰ã€‚
3. **LCA**ï¼šé›–ç„¶æœ‰ O(logN) çš„ LCA è¨ˆç®—ï¼Œä½† log(1023) â‰ˆ 10ï¼Œå°æ¯”è·¯å¾‘é•·åº¦ 9\~18 å¹¾ä¹å¯ä»¥å¿½ç•¥ï¼Œè¡¨ç¾æ¥è¿‘ NextHopã€‚

   * å°é•·è·¯å¾‘ï¼ˆè‘‰â†”è‘‰ï¼‰åè€Œæ¯” NextDir ç³»åˆ—é‚„å¿«ã€‚

---

## ğŸ”¹ è¨˜æ†¶é«”é…ç½® (Allocated)

* **çŸ©é™£æ³•**ï¼šæ¯æ¬¡ Query åˆ†é… \~360B\~640Bï¼ŒåŸå› æ˜¯çµ„è·¯å¾‘ List<> åˆ†é…ã€‚
* **LCA**ï¼šåˆ†é…ç¨å¤šï¼ˆ576B\~1008Bï¼‰ï¼Œå› ç‚ºåœ¨çµ„è·¯å¾‘æ™‚è¦ç”¨ `Stack`ã€‚
* **éƒ½å±¬æ–¼å¾®ä¸è¶³é“çš„ GC å£“åŠ›**ï¼ˆç›¸å°æ–¼ Build æ™‚çš„ 60MBï¼‰ã€‚

---

## ğŸ”¹ ç¶œåˆåˆ¤æ–·

1. **å¦‚æœæ¨¹æ˜¯å›ºå®šçš„ã€æŸ¥è©¢éå¸¸é »ç¹ï¼ˆå¹¾åè¬æ¬¡ä»¥ä¸Šï¼‰**

   * **NextHopMatrix** æ•ˆèƒ½æœ€å¥½ï¼Œæ¯æ¬¡æŸ¥è©¢åªè¦ \~100ns ç´šï¼Œæ–¹å‘è¼¸å‡ºä¹Ÿç°¡å–®ã€‚
   * ç¼ºé»æ˜¯å»ºè¡¨éå¸¸è²´ï¼ˆ50msã€60MBï¼‰ï¼Œå¦‚æœæ¨¹ç¶“å¸¸è®Šå‹•æœƒåƒä¸æ¶ˆã€‚

2. **å¦‚æœæ¨¹å¯èƒ½æœƒè¢«é‡å»ºï¼ˆä¾‹å¦‚å‹•æ…‹æ›´æ–°ï¼‰**

   * **LCA ç­–ç•¥æœ€é©åˆ**ï¼šå»ºè¡¨å¿«åˆçœè¨˜æ†¶é«”ï¼ŒæŸ¥è©¢ä¹Ÿåœ¨ 200ns ç´šåˆ¥ï¼Œè¶³ä»¥æ‡‰ä»˜å¤§å¤šæ•¸æƒ…å¢ƒã€‚

3. **NextDirection / NextDirection+Distance**

   * æ˜¯ NextHop èˆ‡ LCA çš„ä¸­é–“æŠ˜è¡·æ–¹æ¡ˆï¼Œä½†çœ‹èµ·ä¾†å„ªå‹¢ä¸æ˜é¡¯ï¼š

     * è¨˜æ†¶é«”å¹¾ä¹èˆ‡ NextHop ä¸€æ¨£
     * æŸ¥è©¢é€Ÿåº¦å»è½å¾Œ
   * \*\*åªæœ‰åœ¨éœ€è¦å¤§é‡ã€ŒåªæŸ¥è·é›¢ï¼Œä¸è¦è·¯å¾‘ã€\*\*çš„æƒ…å¢ƒä¸‹ï¼ŒNextDir+Dist æ‰å¯èƒ½å‹å‡ºã€‚

---

## ğŸ”¹ çµè«–å»ºè­°

* **å›ºå®šæ¨¹ã€æŸ¥è©¢å£“å€’æ€§å¤š** â†’ ç”¨ **NextHopMatrix**ï¼ˆç©ºé–“æ›æ™‚é–“ï¼‰ã€‚
* **æ¨¹æœƒé‡å»ºã€æˆ–è¨˜æ†¶é«”æ•æ„Ÿ** â†’ ç”¨ **LCA**ã€‚
* **NextDirection ç³»åˆ—**ï¼šç†è«–ä¸Šå¯ç”¨ï¼Œä½†å¹¾ä¹æ²’æœ‰å ´æ™¯æ¯”å‰å…©è€…æ›´æœ‰å„ªå‹¢ã€‚

---

è¦ä¸è¦æˆ‘å¹«ä½ ç•«ä¸€å¼µ **æ¯”è¼ƒåœ–è¡¨**ï¼ˆåƒ bar chartï¼‰æŠŠ Build æ™‚é–“ã€Query æ™‚é–“ã€è¨˜æ†¶é«”ç”¨é‡è¦–è¦ºåŒ–ï¼Œæ–¹ä¾¿ä½ å°æ¯”ï¼Ÿ


Question :
å¯ä»¥è«‹å¹«æˆ‘æ•´ç†

æˆ‘å¹«ä½ æ•´ç†æˆå…©çµ„åœ–è¡¨ï¼š

Build Memory (MB):
![](.\TreeWalk\TreeWalk\docs\images\chart1.png)

Query Times:
![](.\TreeWalk\TreeWalk\docs\images\chart2.png)


---

### ğŸ“Š Build æ•ˆèƒ½èˆ‡è¨˜æ†¶é«”

* **ä¸‰å€‹çŸ©é™£æ³•**ï¼ˆNextHop / NextDir / NextDir+Distï¼‰ï¼š

  * å»ºè¡¨ \~50ms
  * è¨˜æ†¶é«” \~60MB
* **LCA**ï¼š

  * å»ºè¡¨ <0.1ms
  * è¨˜æ†¶é«” <0.3MB

ğŸ‘‰ å¦‚æœæ¨¹æœƒé‡å»ºï¼ŒLCA çš„å·®è·æ˜¯ã€Œæ•¸ç™¾å€ã€çš„ç­‰ç´šã€‚

---

### ğŸ“Š Query æ•ˆèƒ½

* **Rootâ†’Leaf (9 steps)**ï¼šNextHop æœ€å¿« (\~90ns)ï¼ŒLCA (\~200ns) ä¹Ÿæ¥è¿‘ã€‚
* **Leafâ†’Leaf (18 steps)**ï¼šNextHop (\~160ns) æœ€å¿«ï¼ŒLCA (\~276ns) æ¬¡ä¹‹ï¼ŒNextDir ç³»åˆ—ç¨æ…¢ (\~330â€“340ns)ã€‚
* **Midâ†’Mid**ï¼šNextHop (\~124ns) æœ€å¿«ï¼ŒLCA (\~222ns) ä¸­ç­‰ã€‚

ğŸ‘‰ åœ¨æŸ¥è©¢ä¸Šå››ç¨®ç­–ç•¥å·®è·ä¸åˆ° 3 å€ï¼Œéƒ½åœ¨ **100nsâ€“300ns** ç´šåˆ¥ï¼Œéå¸¸å¿«ã€‚

---

### ğŸ” ç¸½çµ

* **å›ºå®šæ¨¹ã€æŸ¥è©¢æ¥µå¤§é‡** â†’ NextHop æœ€å¿«ï¼Œä½†åƒ 60MB è¨˜æ†¶é«”ã€‚
* **æ¨¹å¯èƒ½é‡å»ºã€è¨˜æ†¶é«”æ•æ„Ÿ** â†’ LCA æœ€åˆé©ï¼Œå»ºè¡¨æ¥µå¿«ä¸”åƒ… 0.3MBã€‚
* **NextDir ç³»åˆ—**ï¼šæŸ¥è©¢åè€Œæ¯” NextHop æ…¢ï¼Œå»ºè¡¨åˆè·Ÿ NextHop ä¸€æ¨£é‡ï¼Œæ²’æœ‰å¤ªå¤§å„ªå‹¢ã€‚

---

è¦ä¸è¦æˆ‘å¹«ä½ å†åŠ ä¸€çµ„ **ã€Œ1,000 æ¬¡éš¨æ©ŸæŸ¥è©¢ã€çš„ Benchmark**ï¼Œä¾†çœ‹å¯¦éš›æ‰¹é‡ååå·®ç•°ï¼Ÿ

Question : 
è¶…æ£’çš„é¡Œç›®ã€‚å…ˆçµ¦çµè«–ï¼š**ä¸è¦æŠŠç”Ÿç”¢ç”¨çš„è³‡æ–™æ”¾åœ¨æ™®é€š `Dictionary` è£¡é•·æœŸå…±ç”¨**ã€‚æœ€ä½³åšæ³•æ˜¯ï¼š

1. **å»ºå¥½å¾Œå°±ä¸å†è®Šå‹•çš„ä¸å¯è®Šè³‡æ–™çµæ§‹**ï¼ˆä¾‹å¦‚é™£åˆ— + `.NET 8` çš„ `FrozenDictionary`ï¼‰ã€‚
2. **ç”¨ `IMemoryCache`ï¼ˆæˆ– `MemoryCache`ï¼‰åšå…¨åŸŸå¿«å–**ï¼Œä»¥**æ¨¹å…§å®¹çš„é›œæ¹Š**ç•¶ keyã€‚
3. **ç”¨ `Lazy`/æ¯éµé–**é¿å…å¿«å–ç©¿é€èˆ‡é‡è¤‡å»ºç½®ï¼ˆcache stampedeï¼‰ã€‚
4. å¤šæ©Ÿæ™‚å†åŠ ä¸€å±¤ **distributed cacheï¼ˆRedisï¼‰** ç•¶ç›®éŒ„ï¼Œå€¼ä»æ”¾æœ¬æ©Ÿ `IMemoryCache`ã€‚

ä¸‹é¢æ‹†è§£åŸå› èˆ‡çµ¦ä½ å¯ç›´æ¥å¸¶èµ°çš„éª¨æ¶ã€‚

---

## ç‚ºä»€éº¼ä¸è¦ç”¨ä¸€èˆ¬ `Dictionary` ç•¶å¿«å–

* `Dictionary<TKey,TValue>` **ä¸æ˜¯ä½µç™¼å®‰å…¨**ï¼šå¤šç·šç¨‹åŒæ™‚æ–°å¢/å¯«å…¥æœƒå£ã€‚
* å³ä¾¿ä½ åªè®€ä¸å¯«ï¼Œ**å»ºç½®é‚£ä¸€åˆ»**ä¹Ÿæœƒå¯«å…¥ï¼›è‹¥é€™ä»½ç‰©ä»¶è¢«å¤š request å…±ç”¨ï¼Œ**æœ‰æ©Ÿæœƒ**åœ¨å»ºç½®æœŸè¢«å…¶ä»–ç·šç¨‹è®€åˆ°ä¸å®Œæ•´ç‹€æ…‹ã€‚
* å®ƒæ²’æœ‰é€å‡º/å®¹é‡æ§ç®¡ï¼Œ**çˆ†è¨˜æ†¶é«”**çš„é¢¨éšªé«˜ã€‚

> âœ… ç”Ÿç”¢å»ºè­°ï¼š**å»ºç½®å®Œæˆå¾Œçš„è³‡æ–™ç”¨ä¸å¯è®Šï¼ˆimmutableï¼‰å½¢å¼æ‰¿è¼‰**ï¼›**è·¨è«‹æ±‚å…±ç”¨é  `IMemoryCache`**ï¼Œä¸¦ä¸”**å»ºç½®éç¨‹ä¿è­‰åªæœ‰ä¸€æ¬¡**ã€‚

---

## æˆ‘å€‘çš„ç­–ç•¥å¦‚ä½•èª¿æ•´æˆã€Œå¯å…±ç”¨ã€å¯ä½µç™¼æŸ¥è©¢ã€

* å„ç­–ç•¥çš„å…§éƒ¨æ¬„ä½æ”¹ç‚º**åªåœ¨ `Build` æœŸé–“è³¦å€¼**ï¼Œä¹‹å¾Œ**åªè®€**ã€‚
* å­—å…¸æ”¹æˆ **`FrozenDictionary<,>`**ï¼ˆ.NET 8ï¼Œè®€å–å¿«ä¸” thread-safeï¼‰ï¼Œæˆ–æœ€å°‘ä¹Ÿç”¨ `IReadOnlyDictionary<,>` å°è£ã€‚
* å¤§å¡Šè³‡æ–™ï¼ˆ`short[,]`/`byte[,]`ï¼‰æœ¬èº«æ˜¯å¼•ç”¨å‹åˆ¥ï¼Œä½†åªè¦**ä¸å†å¯«å…¥**ï¼Œå¤šç·šç¨‹è®€å–æ˜¯å®‰å…¨çš„ã€‚

> ä½ çš„å››ç¨®ç­–ç•¥æœ¬èº«æŸ¥è©¢æ˜¯ç„¡ç‹€æ…‹çš„ï¼ˆä¸æ”¹å…§éƒ¨è³‡æ–™ï¼‰ï¼Œåªè¦ä¿è­‰ **Build å®Œå¾Œä¸å†ä¿®æ”¹**ï¼Œ**å°±å¤©ç„¶ thread-safe**ã€‚

---

## å¿«å–è¨­è¨ˆï¼ˆå»ºè­°ç”¨ ASP.NET Core çš„ `IMemoryCache`ï¼‰

* **å¿«å– Key**ï¼šnormalize å¾Œçš„ level-order CSV â†’ `SHA256` hexã€‚
* **å¿«å– Value**ï¼šä¸€å€‹**ä¸å¯è®Šçš„å®¹å™¨**ï¼Œå…§å«ï¼š

  * `BinaryTree`ï¼ˆåªè®€ï¼‰
  * å·²å»ºå¥½çš„**ç­–ç•¥å¯¦ä¾‹**ï¼ˆä¾‹å¦‚åªæ”¾ä½ è¦ç”¨çš„é‚£ä¸€ç¨®ï¼Œæˆ–å…¨éƒ¨ 4 ç¨®åš A/Bï¼‰ã€‚
* **é€å‡ºç­–ç•¥**ï¼šè¨­ `Size` + `SizeLimit`ï¼ˆMBï¼‰ï¼Œ`SlidingExpiration` æˆ– `AbsoluteExpirationRelativeToNow`ã€‚
* **åæŠ–/å–®æ¬¡å»ºç½®**ï¼šç”¨ `ConcurrentDictionary<string, Lazy<Task<TreeBundle>>>` æˆ– `Lazy<TreeBundle>` åŒ…èµ·ä¾†ã€‚

### ç¯„ä¾‹ï¼šå¿«å–ç®¡ç†å™¨

```csharp
using System.Security.Cryptography;
using System.Text;
using System.Collections.Concurrent;
using Microsoft.Extensions.Caching.Memory;
using System.Collections.Frozen;
using BinaryTreePathFinder.Core;

public enum StrategyKind
{
    NextHopMatrix,
    NextDirectionMatrix,
    NextDirectionWithDistance,
    LowestCommonAncestor
}

public sealed class TreeBundle
{
    public required BinaryTree Tree { get; init; }
    public required IReadOnlyDictionary<StrategyKind, IPathStrategy> Strategies { get; init; }
}

public sealed class TreeCacheService
{
    private readonly IMemoryCache _cache;
    private readonly ConcurrentDictionary<string, object> _buildLocks = new();

    // ä¾ä½ çš„å¯¦æ¸¬ï¼šNextHop/NextDir+Dist ç´„ 60 MBï¼›NextDir ç´„ 59 MBï¼›LCA æ¥µå°
    // é€™è£¡ç”¨ç²—ç•¥ä¼°è¨ˆä¾› Size è¨­å®šï¼ˆä»¥ MB ç‚ºå–®ä½ï¼‰
    private static int EstimateSizeMB(StrategyKind kind) => kind switch
    {
        StrategyKind.NextHopMatrix => 60,
        StrategyKind.NextDirectionWithDistance => 60,
        StrategyKind.NextDirectionMatrix => 59,
        StrategyKind.LowestCommonAncestor => 1, // é ç•™ 1MB
        _ => 5
    };

    public TreeCacheService(IMemoryCache cache)
    {
        _cache = cache;
    }

    public TreeBundle GetOrBuild(string levelOrderCsv, params StrategyKind[] kinds)
    {
        var normalized = Normalize(levelOrderCsv);
        var key = "tree:" + Sha256Hex(normalized);

        if (_cache.TryGetValue(key, out TreeBundle bundle))
            return bundle;

        // per-key lock é¿å… stampede
        var gate = _buildLocks.GetOrAdd(key, _ => new object());
        lock (gate)
        {
            if (_cache.TryGetValue(key, out bundle))
            {
                _buildLocks.TryRemove(key, out _);
                return bundle;
            }

            // å»ºæ¨¹ + å»ºç­–ç•¥ï¼ˆå…¨éƒ¨ä¸å¯è®Šï¼‰
            var tree = BinaryTree.BuildFromCsv(normalized);

            var map = new Dictionary<StrategyKind, IPathStrategy>();
            foreach (var kind in kinds)
            {
                var strat = CreateStrategy(kind);
                strat.Build(tree);
                map[kind] = strat;
            }

            bundle = new TreeBundle
            {
                Tree = tree,
                Strategies = map // æŸ¥è©¢åªè®€ï¼Œä¸å†ä¿®æ”¹
            };

            // è¨­ Size ä¾›å…¨åŸŸ SizeLimit æ§åˆ¶ï¼›ç¸½ size = å„ç­–ç•¥ size ç›¸åŠ 
            int totalSize = kinds.Sum(EstimateSizeMB);

            _cache.Set(
                key,
                bundle,
                new MemoryCacheEntryOptions
                {
                    Size = totalSize,
                    Priority = CacheItemPriority.High,
                    SlidingExpiration = TimeSpan.FromHours(6),
                });

            _buildLocks.TryRemove(key, out _);
            return bundle;
        }
    }

    private static IPathStrategy CreateStrategy(StrategyKind kind) => kind switch
    {
        StrategyKind.NextHopMatrix => new NextHopMatrixStrategy(),
        StrategyKind.NextDirectionMatrix => new NextDirectionMatrixStrategy(),
        StrategyKind.NextDirectionWithDistance => new NextDirectionWithDistanceStrategy(),
        StrategyKind.LowestCommonAncestor => new LowestCommonAncestorStrategy(),
        _ => throw new ArgumentOutOfRangeException(nameof(kind))
    };

    private static string Normalize(string csv)
        => string.Join(",", (csv ?? "").Split(',', StringSplitOptions.None).Select(s => s?.Trim() ?? ""));

    private static string Sha256Hex(string s)
    {
        using var sha = SHA256.Create();
        var bytes = sha.ComputeHash(Encoding.UTF8.GetBytes(s));
        var sb = new StringBuilder(bytes.Length * 2);
        foreach (var b in bytes) sb.Append(b.ToString("x2"));
        return sb.ToString();
    }
}
```

> åœ¨ `Program.cs` / DIï¼š

```csharp
builder.Services.AddMemoryCache(options =>
{
    options.SizeLimit = 512 * 1024 * 1024; // 512 MB å…¨åŸŸä¸Šé™ï¼Œä¾ä½ æ©Ÿå™¨èª¿æ•´
});
builder.Services.AddSingleton<TreeCacheService>();
```

### ä½¿ç”¨

```csharp
// åªè¦ LCA
var bundle = treeCache.GetOrBuild(csv, StrategyKind.LowestCommonAncestor);
var result = bundle.Strategies[StrategyKind.LowestCommonAncestor].Query("B", "F");

// è¦ NextHop + LCAï¼ˆA/B æ¸¬è©¦æˆ–é›™è»Œï¼‰
var bundle2 = treeCache.GetOrBuild(csv,
    StrategyKind.NextHopMatrix,
    StrategyKind.LowestCommonAncestor);
```

---

## ç­–ç•¥å…§éƒ¨çš„å­—å…¸æ”¹æˆã€Œä¸å¯è®Šã€

èˆ‰ä¾‹æŠŠ `_labelToIndex` æ›æˆ `FrozenDictionary<string,int>`ï¼Œå»ºå¥½å¾Œåªè®€ï¼š

```csharp
using System.Collections.Frozen;

private FrozenDictionary<string, int>? _labelToIndex;

public void Build(BinaryTree tree)
{
    var dict = new Dictionary<string,int>(StringComparer.Ordinal);
    for (int i = 0; i < tree.Nodes.Count; i++)
        dict[tree.Nodes[i].Label] = i;

    _labelToIndex = dict.ToFrozenDictionary(); // ä¹‹å¾Œåªè®€
    // å…¶ä»–å¤§é™£åˆ—å»ºå¥½å¾Œä¸å†æ”¹å¯«
}
```

> å¦‚æœä½ é‚„åœ¨ .NET 6/7ï¼Œæ²’æœ‰ Frozen ç³»åˆ—ï¼Œä¹Ÿå¯ä»¥æŠŠæ¬„ä½å‹åˆ¥å®£å‘Šæˆ `IReadOnlyDictionary<,>`ï¼Œç„¶å¾Œä¸è¦å†ä¿ç•™åŸå§‹ `Dictionary` çš„åƒè€ƒï¼›æˆ–ä½¿ç”¨ `ImmutableDictionary`.

---

## ä½•æ™‚éœ€è¦ `ConcurrentDictionary`ï¼Ÿ

* **åªåœ¨ã€Œå»ºç½®é–ã€æˆ–ã€Œåˆ†æ®µæ§‹å»ºéœ€è¦ç´¯åŠ ã€çš„å ´æ™¯**ç”¨å®ƒã€‚
* æˆ‘å€‘ä¸Šé¢çš„ per-key gate æ˜¯ç”¨ `ConcurrentDictionary<string, object>` å­˜é–ç‰©ä»¶ï¼›ç­–ç•¥å…§éƒ¨è³‡æ–™ç›¡é‡**ä¸è¦**ç”¨ `ConcurrentDictionary`ï¼ˆå› ç‚ºå»ºå¥½å¾Œåªè®€ï¼Œé¸ä¸å¯è®Šçµæ§‹æ›´å¿«ï¼‰ã€‚

---

## è¦ä¸è¦æŠŠè³‡æ–™æ”¾é€² `MemoryCache` é‚„æ˜¯ç­–ç•¥è‡ªå·±æŒæœ‰ï¼Ÿ

* **å»ºè­°ç”±ä¸Šå±¤ï¼ˆTreeCacheServiceï¼‰çµ±ä¸€ç®¡ç†å¿«å–**ï¼Œç­–ç•¥æœ¬èº«åªé—œå¿ƒæ¼”ç®—æ³•ã€‚
* å¥½è™•ï¼š

  * é€å‡ºç­–ç•¥/å¤§å°æ§åˆ¶/ç”Ÿå‘½é€±æœŸ/è·¨ç­–ç•¥å…±ç”¨åŒä¸€æ£µæ¨¹ï¼Œéƒ½ç”±ä¸€è™•æ§ç®¡ã€‚
  * æœªä¾†æƒ³åˆ‡æ›ç­–ç•¥ï¼Œä¸å‹•ç­–ç•¥ç¨‹å¼ç¢¼ã€‚

---

## å¤šæ©Ÿéƒ¨ç½²

* å¦‚ä½ æ˜¯ Web å¢é›†ï¼šå¯ä»¥æŠŠã€Œæ˜¯å¦å­˜åœ¨ã€çš„ç›®éŒ„ï¼ˆkey æ¸…å–®ï¼‰æ”¾åœ¨ **Redis**ï¼Œä½†**å¯¦éš›å€¼ä»æ”¾æœ¬æ©Ÿ `IMemoryCache`**ï¼ˆç†±è³‡æ–™è²¼è¿‘ CPUï¼‰ï¼Œé¿å…æ¯æ¬¡è·¨ç¶²è·¯ã€‚
* æˆ–è€…ç”¨ `IDistributedCache` å­˜åºåˆ—åŒ–å¾Œçš„æ¨¹/çŸ©é™£ï¼ˆæª”æ¡ˆå¾ˆå¤§ä¸å»ºè­°ï¼‰ï¼Œæ›´åˆç†çš„æ˜¯å­˜ **hash â†’ metadata**ï¼Œå€¼äº¤ç”±æ¯å°æ©Ÿå™¨æœ¬åœ°ç®—+å¿«å–ã€‚

---

## TL;DR ä½ å¯ä»¥é€™æ¨£ä¸Šç·š

1. ç­–ç•¥è£¡æŠŠ `Dictionary` æ›æˆ **Frozen/Immutable** åªè®€çµæ§‹ï¼›å¤§é™£åˆ—**å»ºå¥½å¾Œä¸å†å¯«**ã€‚
2. ä»¥ **`TreeCacheService` + `IMemoryCache`** ç®¡å¿«å–ï¼Œkey=æ¨¹ CSV çš„é›œæ¹Šï¼Œå€¼=å·²å»ºå¥½çš„ç­–ç•¥åŒ…ã€‚
3. è¨­å¥½ **SizeLimit / Expiration**ï¼Œä¸¦ä»¥ **per-key é–** é¿å… stampedeã€‚
4. éœ€è¦å¤šæ©Ÿæ™‚ï¼Œæ­é… Redis åšç›®éŒ„æˆ–è‡ªè¨‚åŒæ­¥æ©Ÿåˆ¶ã€‚

å¦‚æœä½ è¦ï¼Œæˆ‘å¯ä»¥æŠŠä½ ç¾æœ‰å››å€‹ç­–ç•¥å¿«é€Ÿæ”¹é€ æˆ **FrozenDictionary + åªè®€æ¬„ä½** çš„ç‰ˆæœ¬ï¼Œä¸¦åŠ ä¸Šä¸€å€‹ç¯„ä¾‹ Controller å±•ç¤ºå¦‚ä½•ç”¨ `TreeCacheService` æœå‹™åŒ–ã€‚


Question : 
æ¥ä¸‹ä¾†æˆ‘æƒ³å…ˆé€²å…¥ç¸½çµçš„ç’°ç¯€ï¼Œè«‹ä½ å¹«æˆ‘è©³ç´°æ•´ç†åœ¨é€™å€‹å°è©±ä¸­ï¼Œæˆ‘å€‘ç¸½å…±ç¶“æ­·äº†å“ªäº›æ€è€ƒè¨è«–é—œéµé»ã€æ¸¬è©¦æ¡ˆä¾‹æ˜¯æ€éº¼åšè¨­è¨ˆç™¼æƒ³ã€æœ€å¾Œæˆ‘å€‘å¾—å‡ºä¾†çš„çµè«–æ˜¯å“ªå¹¾å€‹æ¼”ç®—æ³•æ¯”è¼ƒé©åˆåœ¨å“ªäº›æƒ…å¢ƒåšä½¿ç”¨

Answer : 
å¥½çš„ ğŸ‘ æˆ‘å¹«ä½ æŠŠé€™æ®µå®Œæ•´å°è©±çš„è„ˆçµ¡æ•´ç†æˆã€Œ**æ€è€ƒè¨è«– â†’ æ¸¬è©¦è¨­è¨ˆ â†’ å¯¦é©—æ•¸æ“š â†’ çµè«–æ‡‰ç”¨**ã€å››å€‹éƒ¨åˆ†ã€‚

---

# ğŸ“Œ ç¸½çµæ•´ç†

## 1. æ€è€ƒèˆ‡è¨è«–çš„é—œéµé»

* **éœ€æ±‚å®šç¾©**

  * ä½¿ç”¨è€…è¼¸å…¥ä¸€å€‹å­—ä¸²ï¼Œä»£è¡¨ä¸€æ£µäºŒå…ƒæ¨¹ï¼ˆlevel-orderï¼Œç©ºå­—ä¸²ä»£è¡¨ç©ºå­æ¨¹ï¼‰ã€‚
  * ä½¿ç”¨è€…è¼¸å…¥ `source` èˆ‡ `destination`ï¼Œç³»çµ±éœ€æ‰¾å‡ºæœ€çŸ­è·¯å¾‘èˆ‡å®Œæ•´ç§»å‹•æ–¹å‘ï¼ˆå¦‚ `U/R/L`ï¼‰ã€‚
  * æ¨¹æ·±åº¦æœ€å¤š 10 å±¤ï¼Œæœƒè¢«ä½¿ç”¨æ•¸åè¬æ¬¡ï¼Œå› æ­¤éœ€è¦å¿«å–ç­–ç•¥ã€‚

* **å…©å¤§è§£æ³•æ–¹å‘**

  * **æ–¹æ¡ˆ Aï¼šé å…ˆ BFS å»ºæ‰€æœ‰é»å°æœ€çŸ­è·¯å¾‘**

    * å„ªåŒ–è®Šé«”ï¼š

      1. **NextHopMatrix**ï¼šè¨˜éŒ„ `(u,v)` çš„ä¸‹ä¸€æ­¥ç¯€é»ã€‚
      2. **NextDirectionMatrix**ï¼šè¨˜éŒ„ `(u,v)` çš„ç¬¬ä¸€æ­¥æ–¹å‘ã€‚
      3. **NextDirection+DistanceMatrix**ï¼šè¨˜éŒ„ `(u,v)` çš„ç¬¬ä¸€æ­¥æ–¹å‘ + è·é›¢ã€‚
    * è¨è«–äº† key å„²å­˜æ–¹å¼ã€æ˜¯å¦éœ€è¦å­˜åå‘ã€å¦‚ä½•ç¯€çœä¸€åŠå„²å­˜é‡ç­‰ã€‚
  * **æ–¹æ¡ˆ Bï¼šLCA (Lowest Common Ancestor)**

    * åˆ©ç”¨ Binary Lifting é è™•ç†ï¼ŒæŸ¥è©¢æ™‚æ‰¾åˆ° LCAï¼Œå†æ‹¼æ¥è·¯å¾‘ã€‚
    * è¨˜æ†¶é«”æ¶ˆè€—æ¥µä½ï¼Œå»ºè¡¨å¿«ï¼Œä½†æ¯æ¬¡æŸ¥è©¢éœ€è¨ˆç®— O(logN)ã€‚

* **æ–¹å‘ç¬¦è™Ÿçš„è¨è«–**

  * æœ€åˆè€ƒæ…®å°‡ `U` ç´°åˆ†ç‚º `UL`/`UR`ï¼Œä½†æœ€å¾Œæ±ºå®šçµ±ä¸€åªç”¨ `U`ï¼ˆç°¡å–®ç›´è§€å³å¯ï¼‰ã€‚

* **å¿«å–è€ƒé‡**

  * ç”Ÿç”¢ç’°å¢ƒä¸é©åˆç›´æ¥ç”¨ `Dictionary` å„²å­˜ï¼Œéœ€è€ƒæ…®ï¼š

    * **ä¸å¯è®Šçµæ§‹**ï¼ˆFrozenDictionary/ImmutableDictionaryï¼‰ã€‚
    * **IMemoryCache** æ§ç®¡å¤§å°èˆ‡éæœŸã€‚
    * **Lazy + per-key é–**é¿å… cache stampedeã€‚
    * **Redis** å¯ä½œç‚ºå¤šæ©Ÿå…±äº«çš„ metadata å±¤ï¼Œæœ¬æ©Ÿä»ç”¨ MemoryCache æé€Ÿã€‚

---

## 2. æ¸¬è©¦æ¡ˆä¾‹è¨­è¨ˆ

æˆ‘å€‘è¨­è¨ˆäº†å¤šç¨®æ¸¬è©¦æ¨¹ä¾†é©—è­‰ç­–ç•¥æ­£ç¢ºæ€§èˆ‡å¥å£¯æ€§ï¼š

1. **ç°¡å–®å°æ¨¹**ï¼ˆ2â€“3 å±¤ï¼‰

   * é©—è­‰åŸºæœ¬è·¯å¾‘è¨ˆç®—ï¼ˆå¦‚ Bâ†’Fï¼‰ã€‚
2. **ä¸å°ç¨±æ¨¹**ï¼ˆå«ç©ºå­æ¨¹ï¼‰

   * é©—è­‰è™•ç† `null` å­æ¨¹çš„é‚è¼¯ã€‚
3. **æ·±åº¦æ¸¬è©¦**ï¼ˆZigZag åˆ°æ·±åº¦ 10ï¼‰

   * é©—è­‰æ¥µç«¯é•·è·¯å¾‘ï¼ˆAâ†’Jã€Jâ†’Aï¼‰ã€‚
   * Jâ†’A è¦èƒ½æ­£ç¢ºè¼¸å‡º 9 å€‹ `U`ã€‚
4. **å®Œå…¨æ»¿æ¨¹ï¼ˆæ·±åº¦ 10ï¼Œ1023 ç¯€é»ï¼‰**

   * ä¾› Benchmark ä½¿ç”¨ï¼Œæ¨¡æ“¬æœ€å¤§è¦æ¨¡æƒ…å¢ƒã€‚

æ¸¬è©¦å…§å®¹åŒ…æ‹¬ï¼š

* è·é›¢æ˜¯å¦æ­£ç¢ºã€‚
* è·¯å¾‘æ–¹å‘æ˜¯å¦ç¬¦åˆé æœŸã€‚
* åå‘è·¯å¾‘æ˜¯å¦èˆ‡æ­£å‘å°ç¨±ã€‚

---

## 3. Benchmark å¯¦é©—æ•¸æ“š

åœ¨ã€Œæ·±åº¦ 10 å®Œå…¨æ»¿æ¨¹ï¼ˆ1023 ç¯€é»ï¼‰ã€ä¸‹ï¼Œç”¨ BenchmarkDotNet æ¸¬å¾—çµæœï¼š

* **Build æ™‚é–“èˆ‡è¨˜æ†¶é«”**

  * NextHopMatrix â‰ˆ 52ms / 60MB
  * NextDirectionMatrix â‰ˆ 46ms / 59MB
  * NextDirection+Distance â‰ˆ 49ms / 60MB
  * LCA â‰ˆ 0.08ms / 0.27MB

* **å–®æ¬¡æŸ¥è©¢æ™‚é–“**

  * Rootâ†’Leaf (è·é›¢=9)ï¼šNextHop \~90nsï¼ŒLCA \~200ns
  * Leafâ†’Leaf (è·é›¢=18)ï¼šNextHop \~160nsï¼ŒLCA \~276ns
  * Midâ†’Midï¼šNextHop \~124nsï¼ŒLCA \~222ns
  * NextDirection ç³»åˆ—æ¯” NextHop æ…¢ 2 å€ï¼Œæ²’æœ‰æ˜é¡¯å„ªå‹¢ã€‚

ğŸ‘‰ æŸ¥è©¢æ•ˆèƒ½å·®è·å°ï¼ˆéƒ½åœ¨ 100â€“300ns ç´šåˆ¥ï¼‰ï¼Œä½†å»ºè¡¨å·®è·æ¥µå¤§ã€‚

---

## 4. çµè«–èˆ‡é©ç”¨æƒ…å¢ƒ

* **NextHopMatrix**

  * **å„ªé»**ï¼šæŸ¥è©¢æœ€å¿«ï¼Œæ–¹å‘ç”¢ç”Ÿç°¡å–®ã€‚
  * **ç¼ºé»**ï¼šå»ºè¡¨ O(NÂ²)ï¼Œä½”ç”¨ \~60MBï¼Œæ¨¹æ›´æ–°ä»£åƒ¹é«˜ã€‚
  * **é©åˆæƒ…å¢ƒ**ï¼šæ¨¹å›ºå®šã€æŸ¥è©¢é‡æ¥µå¤§ï¼ˆæ•¸ç™¾è¬æ¬¡ä»¥ä¸Šï¼‰ã€è¨˜æ†¶é«”å……è¶³ã€‚

* **NextDirectionMatrix / NextDirection+Distance**

  * **å„ªé»**ï¼šç†è«–ä¸Šç¯€çœä¸€åŠè³‡è¨Šï¼›+Distance åœ¨ã€Œåªè¦è·é›¢ã€æ™‚ O(1)ã€‚
  * **ç¼ºé»**ï¼šæŸ¥è©¢é€Ÿåº¦æ¯” NextHop æ…¢ã€è¨˜æ†¶é«”èˆ‡å»ºè¡¨å¹¾ä¹ä¸€æ¨£å¤§ã€‚
  * **é©åˆæƒ…å¢ƒ**ï¼šéœ€æ±‚åªå•ã€Œè·é›¢ã€æ™‚ï¼Œå¯è€ƒæ…® NextDir+Distï¼›å…¶ä»–æƒ…å¢ƒä¸å¦‚ NextHop æˆ– LCAã€‚

* **LowestCommonAncestor (LCA)**

  * **å„ªé»**ï¼šå»ºè¡¨æ¥µå¿«ï¼ˆ\~0.1msï¼‰ã€æ¥µçœè¨˜æ†¶é«”ï¼ˆ0.27MBï¼‰ï¼ŒæŸ¥è©¢é€Ÿåº¦æ¥è¿‘ NextHopã€‚
  * **ç¼ºé»**ï¼šæŸ¥è©¢æœ‰ O(logN) æˆæœ¬ï¼Œä½†åœ¨æ·±åº¦ 10 çš„æ¨¹ä¸Šå¹¾ä¹æ„Ÿå—ä¸åˆ°ã€‚
  * **é©åˆæƒ…å¢ƒ**ï¼šæ¨¹æœƒæ›´æ–°ã€è¨˜æ†¶é«”æ•æ„Ÿã€æˆ–éœ€è¦é«˜å½ˆæ€§æ™‚ã€‚

---

# ğŸ¯ ç¸½çµä¸€å¥è©±

* **å›ºå®šæ¨¹ã€è¿½æ±‚æŸ¥è©¢æ¥µé€Ÿ** â†’ é¸ **NextHopMatrix**ã€‚
* **æ¨¹å¯èƒ½é‡å»ºã€è¨˜æ†¶é«”æœ‰é™** â†’ é¸ **LCA**ã€‚
* **åªè¦è·é›¢** â†’ NextDirection+Distance æœ‰åƒ¹å€¼ï¼Œä½†å…¶ä»–æƒ…å¢ƒä¸å¦‚å‰å…©è€…ã€‚

---

è¦ä¸è¦æˆ‘å¹«ä½ æŠŠé€™ä»½ç¸½çµå†æ•´ç†æˆ **Mermaid æµç¨‹åœ–**ï¼ˆã€Œå¦‚æœéœ€æ±‚æ˜¯ X â†’ é¸æ“‡å“ªå€‹ç­–ç•¥ã€ï¼‰æ–¹ä¾¿åœ¨ç°¡å ±æˆ–æ–‡ä»¶è£¡å¿«é€Ÿå‘ˆç¾ï¼Ÿ


Question : 
å¯ä»¥è«‹æ•´ç†

Answer :
å¥½çš„ ğŸ‘ æˆ‘å¹«ä½ æŠŠæ•´å€‹ç­–ç•¥é¸æ“‡é‚è¼¯æ•´ç†æˆ **Mermaid æµç¨‹åœ–**ï¼Œé€™æ¨£åœ¨ç°¡å ±æˆ–æ–‡ä»¶è£¡ä¸€çœ¼å°±èƒ½çœ‹å‡ºè©²é¸å“ªå€‹ç­–ç•¥ã€‚

---

## ğŸ“Š ç­–ç•¥é¸æ“‡æµç¨‹åœ–

```mermaid
flowchart TD

A[éœ€æ±‚ï¼šæŸ¥è©¢äºŒå…ƒæ¨¹æœ€çŸ­è·¯å¾‘] --> B{æ¨¹æ˜¯å¦å›ºå®š?}

B -->|æ˜¯ï¼Œå›ºå®šä¸æœƒè®Š| C{è¨˜æ†¶é«”æ˜¯å¦å……è¶³?}
B -->|å¦ï¼Œæ¨¹å¯èƒ½é‡å»ºæˆ–æ›´æ–°| D[LCA ç­–ç•¥]

C -->|å……è¶³ï¼ŒæŸ¥è©¢é‡æ¥µå¤§| E[NextHopMatrix ç­–ç•¥<br/>æŸ¥è©¢æœ€å¿« ~100ns<br/>å»ºè¡¨ O(NÂ²) ~60MB]
C -->|è¨˜æ†¶é«”æœ‰é™/ä¸ç¢ºå®š| D

D --> F{æ˜¯å¦åªè¦è·é›¢?}
F -->|æ˜¯| G[NextDirection+Distance ç­–ç•¥<br/>è·é›¢æŸ¥è©¢ O(1)]
F -->|å¦| H[LCA ç­–ç•¥<br/>å»ºè¡¨å¿«ã€çœè¨˜æ†¶é«”ï¼ŒæŸ¥è©¢ ~200ns]
```

---

## ğŸ¯ ä½¿ç”¨èªªæ˜

* **NextHopMatrix**ï¼šé©åˆ **æ¨¹å›ºå®š + æŸ¥è©¢æ¬¡æ•¸å£“å€’æ€§å¤š** çš„æƒ…å¢ƒã€‚
* **LCA**ï¼šæœ€é€šç”¨ã€å®‰å…¨ï¼Œé©åˆ **æ¨¹å¯èƒ½æ›´æ–°ã€è¨˜æ†¶é«”æœ‰é™** çš„æƒ…å¢ƒã€‚
* **NextDirection+Distance**ï¼šåªåœ¨ã€Œ**åªå•è·é›¢ï¼Œä¸è¦è·¯å¾‘**ã€æ™‚æ‰æœ‰å„ªå‹¢ã€‚

---

è¦ä¸è¦æˆ‘å†å¹«ä½ åšä¸€å€‹ **å°ç…§è¡¨æ ¼**ï¼ˆç­–ç•¥ vs å„ªç¼ºé» vs é©ç”¨æƒ…å¢ƒï¼‰ï¼Œè®“ä½ åœ¨æ–‡ä»¶è£¡å¯ä»¥åŒæ™‚æ”¾åœ–å’Œè¡¨æ ¼ï¼Ÿ
