
Question : 我想要針對一個市面上的遊戲 Dead by Daylight 來做一些演算法研究的討論，假設我們現在想要模擬寫出這個遊戲的演算法，可以先請你幫我研究一下這個遊戲的規則嗎?

Answer : 
好的，我先幫你整理一下 **Dead by Daylight (DBD)** 的遊戲規則，讓我們之後討論演算法模擬有一個完整的基礎。以下我會分成幾個部分：

---

## 1. 遊戲基本結構

* **非對稱對抗**：4 名倖存者 (Survivors) vs 1 名殺手 (Killer)。
* **目標**：

  * 倖存者：啟動 5 台發電機，開啟出口門並逃生。
  * 殺手：阻止倖存者逃脫，將他們掛上鉤子並最終犧牲。

---

## 2. 倖存者規則

* **主要行為**：

  * 修理發電機：需要累積進度條 (多次中斷可繼續)。
  * 治療：可幫自己或隊友治療。
  * 躲藏：可進入櫃子、潛行避免被發現。
  * 拯救：從鉤子上救下隊友。
  * 逃生：透過出口門或最後一名倖存者時的「活板門 (Hatch)」。

* **失敗風險**：

  * 修機失敗（QTE 技術檢查失敗）會發出聲音提示殺手。
  * 被殺手攻擊兩次會倒地，再被抓起掛鉤。

---

## 3. 殺手規則

* **主要行為**：

  * 追逐倖存者：移動速度快於倖存者。
  * 攻擊：一次攻擊讓倖存者受傷，第二次使其倒地。
  * 抓取：可直接從修機、翻窗、櫃子中抓人。
  * 掛鉤：將倒地倖存者掛到特定地點的鉤子上。

* **技能特色**：每個殺手有獨特能力（如陷阱、隱形、傳送等）。

---

## 4. 胜利/失敗條件

* **倖存者勝利**：

  * 修好至少 5 台發電機 → 開門 → 至少一人逃脫。
  * 或最後一人能從活板門逃脫。

* **殺手勝利**：

  * 將全部倖存者犧牲（掛鉤多次直至死亡）或阻止逃脫。

---

## 5. 遊戲核心系統

* **修機進度**：每台需要一定時間，4 人合作可加速。
* **技能檢查 (Skill Check)**：隨機觸發的 QTE，失敗會倒退進度並暴露位置。
* **心跳範圍 (Terror Radius)**：倖存者聽到心跳聲代表殺手在附近。
* **地圖限制**：有一定大小，內含障礙物、窗戶、櫃子、板子（可放倒阻礙殺手）。

---

## 6. 可模擬的演算法重點

如果我們要研究演算法，可以針對以下幾個方向：

1. **倖存者行為決策**

   * 何時修機 / 何時躲藏 / 何時救人 / 何時逃跑。
   * 可用 **狀態機 (FSM)** 或 **強化學習 (RL)** 模擬。

2. **殺手追擊策略**

   * 最短路徑（BFS / A\*）找人。
   * 追擊中判斷繞道 vs 直線。

3. **地圖生成 & 平衡性**

   * 演算法可模擬板子、窗戶、發電機位置隨機化。

4. **遊戲勝率平衡**

   * 計算倖存者和殺手在不同策略下的勝率。

---

要不要我幫你把這些規則轉成 **演算法建模用的狀態圖 / 流程圖**，讓之後模擬比較有結構化的參考？

Question : 
先縮小一點規模，我們現在要做一個 POC 版本的鬼抓人遊戲，想要先了解製作出這樣的遊戲架構會需要考慮哪些東西
以下是我現在想到的遊戲規則限制，我們先來確認一下還有沒有遺漏的部分
1、回合制遊戲，總共 100 回合，由鬼先行動，因為分成兩種角色，所以每一回合所有類型的角色都會同時移動，e.g. 第一回合，鬼先行動，若場上有 2 個鬼，都會移動一步。
2、是一個平面地圖，由二維陣列所組成，點與點之間的距離相同。
3、角色與隊伍
    生存者隊
        - 1 ~ 3 位
    鬼隊
        - 2 ~ 5 位

4、移動方式與條件
    - 因為是二維陣列，所以移動方式可以是，上、下、左、右、左上、左下、右上、右下。
    - 一次只能移動一步

5、地圖要素
    - 有 >= 2 的逃脫出口
    - 有限邊界的地圖，因為只有 100 回合，

6、勝利條件
    生存者隊 
        - 當生存者移動到逃脫出口時，生存者隊 + 1 分，同時該名生存者從地圖上移出，逃脫出口保留 (也就是說一個逃脫出口可以使用多次)
        - 當到 100 回合結束時還有生存者仍未移動到逃脫出口則算生存者隊失敗。
    
    鬼隊
        - 當鬼移動到跟生存者同一個點時代表生存者被捕獲，鬼隊 + 1 分，該名被捕或生存者從地圖上移出，鬼則保留在地圖上。
        - 當 100 回合結束前，場上已沒有生存者則算鬼隊獲勝，或是 100 回合到時場上還有生存者也算鬼隊獲勝。

7、行為
    生存者 
        - 以最近出口為逃脫選擇
        - 會盡量避開鬼
        - 生存者彼此不會共享視野
    鬼
        - 以最近的生存者為追捕對象
        - 鬼彼此不會共享視野

8、起始
    - 鬼或是生存者都要距離逃脫出口有一定的距離

Answer:
太好了，我把你列的規則整理成「可直接實作的 POC 規格」，同時把常見會遺漏的細節都補齊（包含同格衝突、同回合先後、距離定義、視野與資訊、出生距離、逃脫/捕獲判定的優先序等）。你可以直接依這版做程式與測試；若要改參數，只需調整常數即可。

# POC 規格（建議預設值）

## 0. 坐標與距離

* 地圖：`W x H` 的二維整數格（建議預設 `W=H=30`，日後可用 10–50 做壓測）。
* 座標系：左上 `(0,0)`，向右 `x+1`，向下 `y+1`。
* 可移動鄰居：8 向（上、下、左、右、左上、右上、左下、右下）。
* **移動成本**：八方向皆為 `1`（Chebyshev metric），**距離**定義為 `max(|dx|,|dy|)`。

## 1. 迴合流程與先後

* 總回合 `T_max = 100`，**每回合分兩個 Phase**：

  1. **鬼行動 Phase**：所有鬼**同時**決定並移動 1 步。

     * 鬼移動完成後，立即結算**捕獲**（見 §4）。
  2. **生存者行動 Phase**：所有生存者**同時**決定並移動 1 步。

     * 生存者移動完成後，立即結算**逃脫與被捕**（見 §4）。
* 如在任何時間點「場上無生存者」，遊戲立刻結束（鬼勝）。

## 2. 隊伍與人數

* 生存者：`1 ~ 3` 位。
* 鬼：`2 ~ 5` 位。

> 兩陣營人數可參數化；測試時建議常用 `(Survivors=3, Killers=3)`。

## 3. 地圖要素

* **出口**：`>= 2` 個出口格。建議預設在邊界上、互相間距離盡量分散（例如四角或邊緣均勻取點）。
* **邊界**：不可越界。
* **障礙**：POC 先無障礙；日後可加入牆/不可通行格。

## 4. 勝負與計分

* **生存者得分**：生存者在生存者 Phase 結束時，若站在出口格 → 該生存者**立刻逃脫 +1 分**，從地圖移除；出口仍可重複使用。
* **鬼得分（捕獲）**：

  * **鬼 Phase 結束時**：若任何鬼**最終停留格**恰為**某生存者的當前位置** → 該生存者被捕，**+1 分**並移除。
  * **生存者 Phase 結束時**：若任何生存者**最終停留格**恰為**某鬼的當前位置** → 該生存者被捕，**+1 分**並移除。
* **終局**：

  * 於 `T_max` 前場上無生存者 → 鬼勝。
  * 到 `T_max` 仍有任一生存者未逃脫 → 鬼勝。
  * 生存者並無「全員逃脫才勝」的條件；本 POC 定義**只要結束仍有人未逃**就判鬼勝（符合你列的規則）。

## 5. 同格衝突與占位規則（關鍵補齊）

* **鬼-鬼**：可同格（不阻擋彼此）。
* **生存者-生存者**：預設**不可同格**。同回合若多名生存者選擇同一目的格，**以穩定 tie-breaker** 解決：

  * 依生存者 `Id`（或出生順序）由小到大，依序「鎖定」該格；後來者若衝突則**改為保留原地不動**（或挑次佳候選格，見 §7 策略可選擇）。
* **鬼-生存者**：允許同格，並依 §4 的時點規則結算捕獲。

## 6. 起始配置（出生規則）

* 參數：

  * `D_exit_min`：任一單位（鬼/生存者）到任一出口的最小初始距離（Chebyshev）。建議預設 `D_exit_min = 8`。
  * `D_enemy_min`：初始時敵我間最小距離（避免一出生就被秒抓）。建議 `D_enemy_min = 4`。
  * `D_ally_min`：同陣營最小距離（避免卡位）。建議 `D_ally_min = 2`。
* 生成步驟（無障礙版）：

  1. 先放出口（邊界均勻）。
  2. 以隨機或固定種子抽樣生存者位置，直到滿足 `D_exit_min`/`D_enemy_min`/`D_ally_min`。
  3. 以同樣規則放置鬼。
  4. 若抽樣次數上限仍無解，放寬距離（逐步 -1）直至可行。

## 7. 行為與目標選擇（可直接實作的簡化 AI）

### 7.1 生存者策略（最近出口 + 盡量避鬼）

* **資訊模型（POC 版本）**：**完全資訊**環境，但「不共享視野」解釋為：**決策函式在程式上以單一個體為單位，不讀取其他生存者的「內部暫存狀態」**；位置仍可讀取。

  > 後續可切換為「感知半徑 `R_sight`」模式（只看得到距離 ≤ `R_sight` 的敵/出口）。POC 預設先全知，方便驗證基準。
* **目標出口**：以 Chebyshev 距離選最近出口；若距離相同，選擇 `Id` 較小的出口（穩定性）。
* **每步評分函式（八鄰居中擇優）**：
  對每個候選格 `n` 計算

  ```
  score(n) = α * (-dist_to_target_exit(n))
           + β * (min_dist_to_any_killer(n))
           + γ * (-ally_conflict_penalty(n))
  ```

  * `dist_to_target_exit`：Chebyshev 距離。
  * `min_dist_to_any_killer`：離最近鬼的距離（越大越安全）。
  * `ally_conflict_penalty(n)`：若其他生存者也瞄準 `n`，可加一個預估懲罰（POC 先設 0；靠 §5 的 tie-breaker 解）。
  * 建議預設係數：`α=1.0, β=0.6, γ=0`（可 A/B 測）。
* **不可行動**：越界或被占據規則不允許（同隊同格）者捨棄。若無可行步，**原地不動**。

### 7.2 鬼策略（最近生存者為追捕目標）

* **目標生存者**：取距離最近者；若有多名距離相同，取 `Id` 最小者（穩定性）。
* **每步評分函式**：

  ```
  score(n) = - dist_to_target_survivor(n)
  ```

  同距離時備選 tie-breaker：優先讓 `dx`/`dy` 絕對值較大的方向（加快收斂），再以方向序或 `Id` 穩定化。
* **鬼可同格**，不需考慮同隊衝突。

## 8. 事件結算的**精確順序**（避免同回合判定歧義）

**在同一回合 t：**

1. **鬼 Phase**
   a. 各鬼基於「回合開始狀態」同時決策目標格。
   b. 同時移動到各自目標格（可同格）。
   c. **捕獲判定 #1**：對每名生存者 `S`，若有任一鬼的**最終格** == `S` 的**當前格** → `S` 被捕，立刻移除並鬼得分。
2. **生存者 Phase**（只對仍存活者）
   a. 各生存者基於「鬼已移動後的狀態」同時決策目標格。
   b. 依 §5 的同隊衝突規則決定最終停留格（衝突者可能留在原地）。
   c. **逃脫判定**：在出口格的生存者 → 立刻逃脫 +1 分並移除。
   d. **捕獲判定 #2**：剩餘仍在場的生存者中，若其**最終格** == 任一鬼的**當前格** → 被捕 +1 分並移除。
3. **終局檢查**：若無生存者 → 立即結束（鬼勝）；若 `t == T_max` 且仍有生存者 → 鬼勝；否則 `t++` 進入下一回合。

> 這個順序明確處理了「同回合同格」與「先到出口 vs 被抓」的爭議：
>
> * 鬼先行，有機會在生存者起步前**先抓**到。
> * 生存者移動後若落在出口就在捕獲前先**逃脫**；但逃脫後仍留在場的生存者，若與鬼同格就會被抓（公平且易測）。

## 9. 複雜度控制與可擴充點

* **可調參數**：`W,H,T_max,D_exit_min,D_enemy_min,D_ally_min, α,β,γ`、出口數量與位置、起點抽樣種子。
* **可選功能（下一步）**：

  * 加入障礙、牆、可破壞板；A\* 取代鄰居打分。
  * 有限視野 `R_sight` + 聲音/心跳提示模型。
  * 多目標協作（生存者間策略多樣化），或鬼之間包夾策略。
  * 不同角色移速/技能（衝刺、短距傳送等）。

## 10. 事件日誌與可視化（便於驗證）

* 每回合輸出：回合數、各角色 `(id, from -> to)`、捕獲/逃脫事件、當前比分。
* 地圖快照（簡易字元地圖）：`S`（生存者 id 小字）、`K`（鬼 id）、`E`（出口）、`.`（空地）。
* 建議附上固定隨機種子重跑測試，確保 determinism。

---

# 極簡主迴圈（偽碼）

```text
state = init(W,H, exits, survivors, killers, constraints)
for t in 1..T_max:
  # Phase K
  K_moves = plan_all_killers(state)
  state = apply_moves_allow_overlap(state, K_moves)
  state = resolve_kill_captures(state)   # 捕獲判定 #1
  if no_survivor(state): break

  # Phase S
  S_moves = plan_all_survivors(state)
  S_moves = resolve_survivor_conflicts(S_moves, state)  # 同隊衝突
  state = apply_moves_no_overlap_for_survivors(state, S_moves)
  state = resolve_escapes(state)         # 逃脫
  state = resolve_kill_captures(state)   # 捕獲判定 #2
  log_round(state)

  if no_survivor(state): break

winner = "Killer" if survivors_left(state) == 0 or t == T_max else "Killer" # 本規則下到時仍有人==鬼勝
```

---

如果你 OK，我下一步可以直接給你一份 **C# 版的資料模型與可跑的核心迴圈（含單元測試雛型）**，把上述規則都落成程式（地圖、角色、移動決策、衝突處理、事件日誌）。你只要決定是否先走「完全資訊」版本，或要同時上「有限視野 `R_sight`」參數。


Question : 
關於規則，我列出幾個我想修改的地方

0. 坐標與距離
- 地圖 : 預設 50 * 50 ，日後調整可能會往上調，因為地圖太小會很快結束

5.同格衝突與占位規則（關鍵補齊）
- 所有角色都不可同格

Answer : 

收到！我把你要改的兩點整合進整體規格，並把「不可同格」帶來的連鎖影響一次補齊（含衝突處理、抓捕判定、swap 衝突等），這版可以直接拿去實作。

# 變更重點

## 0. 座標與距離（更新）

* 地圖大小：預設 **50×50**（左上 `(0,0)`，右下 `(49,49)`）。
* 鄰接：八方向皆可走（上/下/左/右/左上/右上/左下/右下）。
* 距離：**Chebyshev**（一步=1）。

## 5. 同格衝突與占位（重大更新：**所有角色不可同格**）

* **任意時刻的「最終狀態」不得有同格**（鬼-鬼、鬼-生存者、生存者-生存者都不行）。
* **抓捕如何不違反不可同格？**

  * 把「抓捕」定義為**嘗試進入對方所在格**時發生的事件，**事件處理會移除被抓的一方**，因此**回合結束時不會同格**。
  * 結論：**可觸發抓捕，但不會留下同格狀態**。

---

# 完整回合流程（套用不可同格）

每回合 t 仍分兩個 Phase，鬼先、生存者後：

## A. 鬼 Phase（同步決策與移動）

1. **所有鬼同時選一步目標格**（基於回合開始的棋盤）。
2. **衝突檢查與解決（鬼-鬼、鬼-鬼 swap、跟隨衝突）**

   * **Vertex 衝突**：多隻鬼要進入同一格 → 以**穩定優先序**決定誰能進（建議：「距離目標生存者更近者優先；再以 Id 較小者優先」），**後位者改為原地不動**。
   * **Edge（對向交換）衝突**：鬼A 要從 X→Y，同時鬼B 要從 Y→X → **禁止交換**，兩者都**原地不動**（簡化 MAPF 規則）。
   * **跟隨衝突**（X→Y、Z→X 鏈狀追尾）：若導致最終同格或交換，**低優先序者原地不動**。
3. **抓捕判定 #1（鬼主動）**

   * 若**某鬼的最終目標格 = 某生存者當前格** → **觸發抓捕**：

     * 該生存者**被移除**、鬼**進入該格**、鬼隊 +1 分。
     * 這筆移動合法，結束後不會同格。
4. 應用所有合法移動，更新棋盤。
5. 若場上已無生存者 → 遊戲立即結束（鬼勝）。

## B. 生存者 Phase（同步決策與移動）

1. **所有存活生存者同時選一步目標格**（基於鬼 Phase 後的棋盤）。
2. **衝突檢查與解決（生-生、edge/swap、跟隨）**

   * **生-生同格衝突**：多人生要進同一格 → 以**穩定優先序**（建議固定 Id 由小到大）決定**唯一能進者**，其餘**原地不動**。
   * **Edge swap**：兩名生存者互換 → **禁止**，兩者**原地不動**。
   * **跟隨衝突**：同上，低優先序者**原地**。
   * **對鬼佔據格**：若目標格目前有鬼 → **允許嘗試**，但將觸發抓捕（見下一步）。
3. **逃脫判定**

   * 最終停於出口格者 → **立刻逃脫**、自場上移除、生存者隊 +1 分。
4. **抓捕判定 #2（生動入鬼格）**

   * 過了逃脫判定後，若仍有生存者**最終停在某鬼所在格** → **觸發抓捕**：

     * 該生存者**被移除**、鬼**保持原位**、鬼隊 +1 分。
5. 若場上無生存者 → 立即結束（鬼勝）。
6. 若 t==100 且仍有任一生存者未逃 → 鬼勝；否則進下一回合。

> 關鍵：**抓捕是“嘗試進入對方所在格”的事件**，移除被抓的一方後，**終態**沒有同格，完全符合「不可同格」。

---

# AI 決策（在不可同格下的調整）

## 生存者

* 目標：最近出口（Chebyshev）。
* 評分函式（挑 8 鄰居合法步）：

  ```
  score(n) = α * (-dist_to_exit(n))
           + β * min_dist_to_any_killer(n)
           + γ * (-潛在同隊衝突風險(n))
  ```

  建議係數：α=1.0, β=0.6, γ=0.2。
* **非法步**（越界、被同隊預計占用且自己優先序較低、Edge swap、跟隨造成衝突）→ 捨棄；若全非法 → 原地。

## 鬼

* 目標：最近生存者（同距離取 Id 小者）。
* 評分：`-dist_to_target(n)`；同距離 tie-breaker 可固定方向序或偏向減少 max(|dx|,|dy|) 的方向。
* 同隊衝突與 swap 依上節規則處理。

---

# 起始與間距（沿用但提醒「不可同格」）

* 初始隨機放置時，務必檢查所有單位互不重疊，並滿足：

  * `D_exit_min`（建議 8）
  * `D_enemy_min`（建議 4）
  * `D_ally_min`（建議 2）
* 若抽樣上限仍無解 → 逐步放寬距離直到可行。

---

# 事件與日誌（驗證不可同格）

* 於每個 Phase 結束後斷言：**棋盤上無任意同格**。
* Log 需標示：

  * 決策步（含被拒絕原因：越界/同隊衝突/edge-swap）
  * 抓捕事件（誰嘗試進入誰、在哪個 Phase）
  * 逃脫事件與比分
* 可視化：50×50 ASCII/PNG，每回合一幀即可驗證不重疊。

---

# 極簡偽碼（更新版）

```text
for t in 1..100:
  # Killer Phase
  K_moves = plan_killers(state)
  K_moves = resolve_conflicts_no_overlap(K_moves)   # 禁同格+禁swap
  apply_moves(state, K_moves)
  resolve_kill_captures_by_killers(state)           # 鬼嘗試進入生 -> 生移除, 鬼佔格
  assert no_overlaps(state)
  if no_survivor: break

  # Survivor Phase
  S_moves = plan_survivors(state)
  S_moves = resolve_conflicts_no_overlap(S_moves)    # 禁同格+禁swap
  apply_moves(state, S_moves)
  resolve_escapes(state)                             # 先逃脫
  resolve_kill_captures_by_tiles(state)              # 生在鬼格 -> 生移除, 鬼不動
  assert no_overlaps(state)
  if no_survivor: break

# 終局：若提前清空 -> 鬼勝；若 t=100 且仍有人存活 -> 鬼勝；否則下一回合
```

---

如果這版 OK，我可以下一步直接給你 **C# 可跑的 POC（資料模型、規則引擎、衝突解算器、單元測試）**，已內建「不可同格」與「edge-swap 禁止」的 MAPF 簡化規則，方便你後續擴充到障礙與 A\*。要我直接開寫嗎？


Question : 
接著我想要討論生存者的策略，幫我分析 DFS 或是 BFS 演算法跟我們目前的生存者逃脫策略有相關嗎? 如果不相關的話選哪一種演算法比較好呢?

Answer : 
結論先說：**DFS 幾乎不相關、BFS 有部分相關但不夠用**。
在我們這個「動態對手 + 同格不可重疊 + 八方向一步」的 POC 裡，**最佳做法是：把 BFS 當作每回合的「距離/風險場 (distance/threat field)」建構工具，再用打分決策**；若之後加障礙或權重，再升級為 **A\***（或 D\* Lite / LPA\* 等增量路徑規劃）。

---

# 為什麼 DFS 不適合？

* **DFS 不保證最短路徑**，而逃生目標是「盡快到出口、還要避鬼」；DFS 可能走很深的繞路。
* DFS 對「動態威脅」沒有天然優勢；它偏探索，不是規劃最短／最安全路徑的演算法。

# BFS 的「部分相關」

* 在**無權重、每步成本=1**（我們採 Chebyshev、一步=1）下，**BFS 可給你到出口的最短步數**（若暫時忽略鬼與隊友阻擋）。
* 但我們的環境是**動態與多智能體**：鬼會移動、同隊會卡位、不可同格與禁止交換（edge-swap）——**單純 BFS 路徑常常下個回合就失效**。

---

# 建議的生存者決策（簡單好用、可直接落地）

## 1) 每回合重建兩張場（用 BFS 做多源擴散）

* **Exit Distance Field `D_exit`**：以所有出口為起點做**多源 BFS**，得到每格到最近出口的最短步數。
* **Killer Distance/Threat Field `D_killer`**：以所有鬼為起點做**多源 BFS**，得到每格離最近鬼的最短步數，或進一步做**威脅場**（距離越近分數越低）。

  * 50×50 規模，兩次 BFS 每回合跑一次非常輕、省心，也容易除錯。

## 2) 一步式打分（我的 POC 建議）

對於生存者「當前格的 8 個候選步」做打分，挑最高分那步（若皆非法則原地）：

```
score(cell) = α * (- D_exit[cell])
            + β *  f_safety(D_killer[cell])
            + γ *  f_flow(cell)   // 減少與隊友衝突、避免swap
```

* `f_safety`：可以用 `+D_killer[cell]`（離鬼越遠越好），或用非線性衰減如 `log(1 + D_killer)`/ 分段懲罰（例如距離≤2 給巨大負分）。
* `f_flow`：對「被多名生存者同時瞄準」的格、或會觸發 edge-swap 的格，給懲罰，降低卡位機率。
* **參數建議**（可 A/B 測）：`α=1.0, β=0.8~1.2, γ=0.1~0.3`。
* **好處**：穩定、可解釋、成本低、面對動態對手時**每回合重算、自然再規劃**。

> 小技巧：你也可以直接把 `score = - D_exit + λ * D_killer`（最簡版），先跑通驗證，再逐步加 flow 與懲罰。

## 3) 為何不直接用「BFS 路徑」？

* 直接用 BFS 算一條到出口的最短路，**下回合可能被鬼/隊友封死**；你又得整條重算，還要處理路徑失效與 swap 衝突。
* 用「**場 + 一步打分**」每回合**局部決策**，在動態環境更穩定。

---

# 什麼時候要用 A\* / D\*？

* **當地圖加入障礙/牆**，且你希望路線更平滑、更少回頭：

  * 用 **A\***（啟發式=Chebyshev 距離）比 BFS 更快找最短路。
  * 若鬼/障礙會改變或地圖很大、你不想每回合重算全圖：用 **D\* Lite / LPA\*** 這類**增量式**路徑規劃更有效率。
* **多智能體協作**（多名生存者彼此避讓）：可考慮 **Cooperative A\*** 或 **CBS (Conflict-Based Search)**；但 POC 階段不必，成本高很多。

---

# 實作建議（落到你現在的專案）

1. **每回合**先用兩次多源 BFS 產生 `D_exit` 與 `D_killer`。
2. 生存者逐一對 8 鄰居做 `score`（過濾越界/同隊占用/edge-swap 會觸發者）。
3. 以最高分為目標步；若衝突，按你定的 tie-breaker（Id 小者先）保留，其他人原地。
4. 紀錄「因流量/衝突被擋」的次數，之後可用來調整 `γ` 或加入「繞行懲罰折減」。

---

# TL;DR

* **DFS：不適合。**
* **BFS：適合作為「距離/威脅場」的建構工具**，每回合重算，再用**一步打分**做動態決策。
* **若有障礙或要更聰明**，升級為 **A\***（甚至 D\* Lite/LPA\*）。
* 50×50 的規模下，這套法簡單、快、穩、好驗證，超適合 POC。

如果你想，我可以直接給你 **C# 的 `BuildDistanceFieldByBFS(...)` 與 `ChooseBestStep(...)`** 兩個方法範本，嵌進你現有的回合引擎就能跑。


Question : 
我想要先針對 DFS 以及 BFS 演算法在此次需求上的應用做進一步探討，我想了解
1、為甚麼 DFS 不保證最短路徑?
2、為甚麼 BFS 部分相關，考量的點你有提到 「環境是動態與多智能體」，我可以理解成因為計算的結果並不能重複利用嗎?

Answer : 
好，我幫你把這兩點拆開來講，並且跟你的 **鬼抓人生存者策略需求**做對照。

---

## 1. 為什麼 DFS 不保證最短路徑？

* **DFS 的特性**

  * DFS（深度優先搜尋）會沿著一條路徑「一路走到底」，直到不能走或到達目標，再回頭換另一條路。
  * 它的重點是**探索完整路徑空間**，而不是優先尋找「步數最少的路徑」。
  * 舉例：如果出口距離只有 3 步，但 DFS 先走了一條 20 步的深路，找到的第一個解就是 20 步，DFS 並不會自動保證「回頭再找短的」。

* **應用到本需求**

  * 生存者要「逃脫」其實是要最少步數到出口（同時要安全），DFS 會走出「可能能逃，但繞遠路」的解，這不符需求。
  * 所以 DFS 更適合用在「是否存在一條路」的驗證，而不是「找到最短或最佳路徑」。

---

## 2. 為什麼 BFS 部分相關？

* **BFS 的特性**

  * BFS（廣度優先搜尋）是「分層往外擴展」，遇到目標時，保證這條路徑是**最短步數解**。
  * 所以如果我們把出口當作目標，BFS 算出來的步數距離就是「到出口的最短路」。

* **為什麼只「部分相關」**

  * 你的環境是 **動態 + 多智能體**：

    1. **動態性**：鬼每回合都在移動，BFS 算的路徑下一回合就可能失效（出口還在，但路線的「安全性」變了）。
    2. **多智能體**：生存者之間「不能同格」，鬼也在移動堵路。這代表 BFS 得出的路線不一定能實際執行（例如下一步被隊友卡住，或鬼剛好走進來）。

* **你理解的「計算結果不能重複利用」是對的，但更精確的說法是**：

  * BFS 計算的「靜態最短路」只對**當前回合靜態環境**有效。
  * 下一回合環境改變（鬼換位置、隊友站位不同），之前的 BFS 結果**失效或需要重算**。
  * 所以在這種需求裡，BFS 常常要「每回合重跑一次」，僅用來提供當下的「最近出口距離」或「離鬼的距離」。

---

## 小結

1. **DFS**：只能回答「有沒有路」，但不能保證「路是不是最短」，所以不符合「生存者要最短、安全逃脫」的需求。
2. **BFS**：可以保證最短路，但只在靜態環境裡有效。在動態多智能體的場景裡，BFS 的結果必須**每回合重算**，否則就不可靠。

---

要不要我接著幫你做一個小範例（用 5x5 地圖 + 鬼/出口的簡單配置），展示 DFS 找到「繞遠路」、BFS 找到「最短路」的差異，並解釋為什麼下一回合就要重算？


Question : 
這邊足夠我了解 BFS 以及 DFS 在本次需求的適用性了，接著我想要往下探討所建議的生存者決策，我需要詳細解說這個部分

Answer : 
太好了，往下我把「生存者決策」拆成可直接實作的幾個模組，涵蓋：距離/威脅場的建構、一步打分的設計、不可同格下的衝突解算、幾個關鍵情境的特別規則、參數調校與效能/測試建議。整體思路：**每回合重算兩張場（出口距離場 + 鬼威脅場），對 8 個鄰居做打分擇優，再進行不可同格的衝突解算**。

---

# 1) 場（Field）建構：兩個多源 BFS

在 50×50 地圖上，兩次多源 BFS 每回合跑一次很輕鬆（O(WH)）。

**D\_exit：出口距離場**

* 以所有出口為起點做多源 BFS，得到每格到最近出口的 Chebyshev 最短步數。
* 代表「**越小越接近出口**」。

**D\_killer：鬼威脅場**

* 以所有鬼為起點做多源 BFS，得到每格到最近鬼的最短步數。
* 代表「**越大越安全**」。

（可選）**T\_margin：安全邊際場**

* 直覺定義：`T_margin(cell) = D_killer[cell] - D_exit[cell]`

  > 正值：我們理論上比鬼更快到這格/穿過此區域；負值：風險較高。
* 可作為打分中額外特徵（見 §2）。

---

# 2) 一步打分（Scoring）——從 8 鄰居挑一步

對當前生存者位置 `p` 的 8 個合法鄰居 `n`（含「原地不動」作為第 9 候選，避免被動撞上衝突）計算：

```
score(n) = α * (- D_exit[n])
         + β *  safety(D_killer[n])
         + γ *  flow_penalty(n)
         + ω *  margin_boost(T_margin[n])
         + φ *  special_rules(n)   // 近身、最後回合、出口相鄰等
```

### 推薦的子函式

* `safety(d)`: 距離越遠分數越高。線性即可，或以「近距離重懲、遠距離平緩」的分段/對數：

  * 例：`safety(d) = { -∞ (d ≤ 1), -C (d = 2), d  (d ≥ 3) }`
* `flow_penalty(n)`: 降低同隊擠壓/卡位。POC 兩種做法擇一：

  1. **簡版**：`flow_penalty = 0`，把衝突完全交給解算器處理（較簡單）。
  2. **改善版**：對「距離最近隊友 ≤ 1 或 2」給小幅負分，降低朝擁擠區移動的傾向。
* `margin_boost(m)`: 將 `T_margin` 拉成分數（正值加分，負值給小懲罰）。
* `special_rules(n)`：幾個對逃脫很有用的微規則（見下段）。

### 推薦係數（起始）

* `α = 1.0`（縮短到出口）
* `β = 1.0`（遠離鬼）
* `γ = 0 ~ 0.2`（POC 先 0，卡位多了再開）
* `ω = 0.3`（安全邊際）
* `φ` 視規則觸發而定（通常是 ± 大值的硬懲罰/加分）

---

# 3) 特別規則（小而關鍵）

這些能讓策略在「近身糾纏」與「最後一跳」時更聰明。

1. **出口優先（可一跳到出口）**

   * 若某候選 `n` 是出口：直接標記為**最高優先**（甚至跳過打分，直接選）。
   * 依我們回合順序：生存者 Phase 結束時先判「逃脫」再判「被捕」，因此**就算出口格上有鬼，也能先逃**。

2. **近身恐懼區（d ≤ 2 強懲）**

   * 若 `D_killer[n] ≤ 2`，給大幅負分避免貼臉；除非 `n` 是出口（則套規則 1）。
   * 這能避免生存者因純粹縮短 `D_exit` 而自殺前進。

3. **最後回合求生（t == 100）**

   * 若能更接近出口（`D_exit[n] < D_exit[p]`），給額外加分；否則嚴懲「原地/遠離出口」。
   * 讓最後回合不保守。

4. **陷阱偵測（單步展望）**

   * 模擬「鬼下一步若朝最近生存者貼近」的局部預測：若 `n` 會導致 `D_killer_next[n] ≤ 1`，對 `n` 加重懲罰。
   * 實作上可不跑全圖，只估「就近的 1\~2 名鬼往你移動一步」的距離。

---

# 4) 不可同格下的衝突解算（Survivors Only）

所有生存者**同時**選好目標後，進行解算以滿足：

* 不可同格（生-生）
* 禁 swap（A→B 與 B→A）
* 禁跟隨鏈造成重疊

**建議流程（穩定 + 易實作）**

1. **為每個生存者提交 `(target_cell, score, id)`**。
2. **按「目標格」分桶**，對每個目標格的申請者：

   * 以 `score` 由高到低排序；若分數相同，以 `id` 由小到大（確保**決定性**）。
   * 允許**第一名**佔用；其他人**退回候補**（預設「原地不動」）。
3. **檢查 edge-swap**：若發生 A: X→Y、B: Y→X

   * **取消兩者移動**（都原地）。
4. **檢查跟隨鏈**（X→Y、Z→X… 形成循環）

   * 由最低分/後序者開始取消，直到消除循環。

> 為了行為更「合理」：步 2 可改用「**競標式分配**（score 高者贏）」而非單靠 id，能減少高分決策被 id 壓掉的隨機性。

---

# 5) 生存者決策的主流程（偽碼）

```text
# 每回合開始（鬼 Phase 已結束）：
D_exit    = MultiSourceBFS(exits)
D_killer  = MultiSourceBFS(killers)
T_margin  = D_killer - D_exit   # 可選

for each survivor S (alive):
  candidates = neighbors8(S.pos) ∪ {S.pos}  # 含原地
  legal = filter_out_of_bounds(candidates)
  # 不要在這裡排除「鬼所在格」，因為允許嘗試，之後會觸發抓捕/先逃脫判定
  # 也不要先排除同隊目標，統一交給解算器

  best = argmax_n in legal of score(n)
  submit_move(S, best, score(best))

# 解算（不可同格、禁 swap/跟隨）
moves = resolve_conflicts_by_bucket_and_no_swap(all_submitted)

# 套用移動
apply_moves(moves)

# 先判逃脫（在出口的直接移除 +1 分），再判「與鬼同格」被捕（移除 +1 分）
resolve_escapes_then_captures()
```

---

# 6) C# 介面／函式切割（範本）

```csharp
// 場建構
int[,] BuildDistanceFieldByBfs(Grid grid, IEnumerable<Point> sources); // Chebyshev
// 打分
double ScoreCell(Point n, DistFields f, LocalContext ctx);
// 生存者決策
MovePlan PlanSurvivorStep(Survivor s, DistFields f, LocalContext ctx);
// 衝突解算
IReadOnlyList<DecidedMove> ResolveNoOverlap(IReadOnlyList<CandidateMove> moves);
// 事件結算
void ResolveEscapesThenCaptures(GameState state);
```

`LocalContext` 可含：回合數 `t`、鄰近鬼資訊（距離≤k 的清單）、鄰近隊友距離等。

---

# 7) 參數調校建議

1. **先最小集**：`score = -D_exit + λ * D_killer`，λ 先從 `1.0` 開始。
2. **觀察行為**：

   * 若過度勇敢→加大近身懲罰（`D_killer ≤ 2` 大懲罰）。
   * 若過度保守→降低 `β` 或提高 `α`；並開啟 `margin_boost`。
   * 若擠在一起卡位→開 `flow_penalty` 或在解算器用「競標分配」。
3. **A/B 測**：以「存活率、平均逃脫時間、卡位次數、近身死亡率」為指標。

---

# 8) 效能與可擴充

* 50×50：兩次 BFS \~ 萬級操作，極快。
* 之後若加入**障礙/牆**，依然可用 BFS（障礙視為不可到達）；若加入**不同地形代價**，可改 **Dijkstra/A\***。
* 若要減少重算：當鬼與出口位置小變化，可做**增量更新**；但 POC 沒必要。

---

# 9) 常見陷阱與對策

* **直線貼近鬼**：純縮小 `D_exit` 會自殺，務必保留「近身懲罰 + 安全邊際」。
* **出口口袋被堵**：加入一次「單步展望預測」懲罰，避免走入死角。
* **同隊卡位**：先用解算器解決，必要時開 `flow_penalty` 或設「**排隊規則**」：距出口更近者優先、後位者暫緩。
* **非決定性重跑**：所有 tie-break（同分、同距、排序）都以固定規則（id/方向序）確保可重現。

---

## TL;DR

* **每回合**用兩張多源 BFS 建「出口距離場」與「鬼威脅場」。
* 用 **一步打分**從 8 鄰居（含原地）挑一步，內含**近身懲罰／安全邊際／出口優先**等微規則。
* 移動後用**不可同格解算器**處理衝突（競標式分配 + 禁 swap/跟隨），再依規則**先逃脫、後被捕**結算。
* 參數先簡單、指標化 A/B 調整；POC 容易跑、容易驗證，也能平滑升級到 A\*/Dijkstra/增量規劃。

如果你要，我可以下一步直接給你 **C# 可貼上的 `BuildDistanceFieldByBfs` 與 `PlanSurvivorStep` 的初版**（含幾個可切換的 `special_rules`），讓你立刻跑通一輪模擬。


Question : 
我想先確認一下這個生存者策略我理解的對不對，所以我們要做的事情是
Step 1、先用 BFS 計算兩個結果，生存者與出口路線距離、鬼與生存者路線距離
Step 2、使用 Scoring 演算法來挑選合適的路線 ， 這邊我想要多探討的是 BFS 得出來的結果會是只有2 個路線嗎?  還是我的理解有誤，其實是多個路線，然後再透過 Step2 的評分決定該走哪一個方位?
Step 3 、特別規則增加 Scoring 的權重，影響生存者在特殊情況的決策

Answer : 
你的理解大致正確 👍，但我幫你釐清一個關鍵誤解：

BFS 在這裡**不是用來直接產生「路線」**，而是用來產生一張「距離場 (distance field)」或「威脅場 (threat field)」。
換句話說，BFS 的結果**不是兩條路**，而是**整張地圖上每個格子對出口/鬼的最短距離**。

---

## 拆解你的三步驟

### Step 1：BFS 計算結果

* **出口距離場 D\_exit**：對每個格子算「到最近出口的步數」。
* **鬼距離場 D\_killer**：對每個格子算「到最近鬼的步數」。

> 所以結果是兩張 50×50 的矩陣，不是「兩條路」。
> 它提供每個位置的「走到出口還要幾步」以及「離鬼有多遠」。

---

### Step 2：Scoring 演算法

* 當生存者在格子 `p`，我們要考慮它的 **候選移動集合**：
  `neighbors8(p)` + `p`（原地不動）。
* 對於這些候選格 `n`，查表：

  * `D_exit[n]` = n 到出口的距離
  * `D_killer[n]` = n 離鬼的距離
* 然後用評分公式：

  ```
  score(n) = α * (-D_exit[n]) + β * D_killer[n] + ... + 特別規則
  ```
* 取分數最高的 `n` 作為移動方向。

> 這代表 BFS 的距離場只是**輸入特徵**，最後決定走哪裡是由 scoring 來做。
> 不是 BFS 自己給出兩條/多條路，而是 scoring 在每回合看 8 個方向，用 BFS 結果計算分數。

---

### Step 3：特別規則

* 在某些情境直接覆蓋或修改分數，例如：

  * **出口相鄰** → 優先逃脫，不計算其他分數。
  * **距離鬼 ≤ 2** → 大幅扣分，避免自殺。
  * **最後一回合** → 優先靠近出口。

這些規則就是你說的「增加 Scoring 的權重」。

---

## 舉例（簡單 5×5）

假設出口在 (4,4)，鬼在 (0,4)，生存者在 (2,2)

* BFS 結果（出口場 D\_exit）：
  (2,2) → 到出口 4 步
  (2,3) → 3 步
  (3,2) → 3 步
* BFS 結果（鬼場 D\_killer）：
  (2,2) → 離鬼 4 步
  (2,3) → 離鬼 3 步
  (3,2) → 離鬼 5 步

Scoring：

* (2,3)：出口近，但鬼也近 → 分數中等
* (3,2)：出口也近，鬼更遠 → 分數最高
  所以生存者會往 (3,2) 走。

---

✅ 所以總結：

* **Step 1**：BFS 給你「距離場」，不是「路線」。
* **Step 2**：生存者只考慮自己能走的一步，利用 BFS 的結果給分，挑最高分。
* **Step 3**：規則在特殊情況下修正/覆蓋分數，讓決策更合理。

---

要不要我幫你畫一個 **小的示意圖 (5×5)**，直接標出 BFS 的距離場，然後跑一輪 scoring，把決策過程圖解給你看？


Question : 
在確認一次理解正不正確
1、所以意思是 BFS 我們用來計算的是 Chebyshev distance ，得出所有距離，而決定生存者移動的則是 Scoring ?
2、所以意思是在這個演算法的邏輯下，生存者其實是看的到鬼在地圖上的位置的?

Answer : 
完全正確，你的理解方向對了 👍
我幫你再釐清一下細節，讓邏輯更嚴謹：

---

## 1. BFS 的用途

* 是的，這裡的 **BFS 用來計算 Chebyshev distance**（因為八方向走一步都算 1）。
* BFS 不是算「單一路徑」，而是建出一張**距離場**：對地圖上每一格，算出

  * 到最近出口的距離 `D_exit`
  * 到最近鬼的距離 `D_killer`
* **移動決策不是 BFS 給的，而是 Scoring 給的**。

  * Scoring 會查這兩張距離場，對每個候選步（8 個方向 + 原地）計算分數，然後挑最好的。

---

## 2. 生存者是否「看得到鬼」

* 在這個演算法設定裡，**是的**，生存者能「知道鬼在哪裡」，因為我們需要鬼的位置來跑 BFS（計算 `D_killer`）。
* 這代表我們假設 **全知視野**（omniscient vision）：生存者知道所有鬼的位置。

### 為什麼要這樣設計？

* 這是 **POC 版本**的簡化：

  * 方便測試與驗證演算法正確性。
  * 也能比較容易調整參數（α, β, γ 等）。
* 若要更真實模擬 Dead by Daylight，那就要加上 **有限視野 (R\_sight)**：

  * 例如：只有在距離 ≤ 7 格內的鬼才「能被看到」。
  * 那麼 `D_killer` 只能局部建，或是「看不到的鬼」視為「無限遠」。

---

✅ 所以你的理解總結：

1. **BFS 計算 Chebyshev distance**，得到距離場，不是直接給路線。最後移動是 **Scoring** 的工作。
2. 在目前這個設計裡，**生存者是能看到整張地圖上的鬼**（全知），因為我們要用鬼的位置來跑 BFS。如果想模擬更真實，就要改成有限視野版本。

---

要不要我幫你畫個「全知 vs 有限視野」的對比例子（用一張 7×7 小地圖），讓你清楚看到如果有限視野的話，生存者的決策會怎麼不同？

Question : 
在這邊我想要修改一下規則，生存者確實是可以知道出口在哪裡的這個情況全知視野沒有問題，但是在看到鬼的位置時全知視野似乎有點過於強大，所以我打算將可以看到鬼的距離限制在 5 X 5 的範圍內

Answer : 
太好了！把「看鬼」改成 **5×5 可視範圍**（中心包含自己）是很合理的弱化。下面我把規則精確化，並給出演算法怎麼改最穩、最容易落地。

# 視野規則（更新）

* **出口**：仍為全知（位置固定可見）。
* **鬼**：僅在「以生存者為中心的 5×5 區塊」內可見。

  * 形式化：對生存者位置 `p=(x,y)`，可見集合 `V = { q | max(|qx-x|, |qy-y|) ≤ 2 }`。
  * 換句話說：**Chebyshev 距離 ≤ 2** 可見（5×5 窗）。

# 距離/威脅場建構（Step 1 的調整）

我們原本每回合都建兩張場：`D_exit`、`D_killer`。

* `D_exit`：不變（多源 BFS from 所有出口）。
* `D_killer`：**只用「可見鬼」當作 BFS 的起點**。

  * 若看不到任何鬼：把 `D_killer` 視為「極安全」即可（例如用一個大數 `+∞` 或地圖最大距離+1）。

> 這代表：**不可見的鬼不進入威脅場**。生存者會在「未知區域」更傾向往出口走，但我們可以用一些「保守啟發」避免盲撞（見下）。

# Scoring（Step 2）的微調

核心仍是「對 8 鄰居 + 原地」打分，只是 `D_killer` 現在是「**局部威脅**」。

基礎分數仍然：

```
score(n) = α * (- D_exit[n])
         + β * safety(D_killer[n])      // 只會反映視野內鬼
         + γ * flow_penalty(n)
         + ω * margin_boost(D_killer[n] - D_exit[n])
         + φ * special_rules(n)
```

## 建議新增的「有限視野」對策（簡單好用）

1. **近身強懲**（維持）：若 `D_killer[n] ≤ 2`，給大負分；但 `n` 是出口則直接優先逃脫。
2. **未知區域的溫和懲罰**（避免盲撞）：

   * 定義：對於 `n` 的 5×5 區域若**完全沒有可見鬼訊息**，給一個微小負分 `-ε`（例如 `ε=0.1~0.3`），表示「未知有風險但不大」。
   * 好處：看不到鬼時仍以 `D_exit` 為主，但不會過度勇猛。
3. **最近一次看見的鬼（Last-Seen Memory，選配，強烈建議）**：

   * 為每個鬼記錄 `last_seen_pos` 與 `last_seen_time`。
   * 對每個候選 `n`，估計「鬼**可能**的覆蓋半徑」：`R = min(t_now - last_seen_time, R_cap)`（例如 `R_cap=5`），用 **Chebyshev** 往外擴。
   * 若 `n` 落在任一鬼的「**不確定區**」（以 `last_seen_pos` 為中心、半徑 R 的方窗）→ 給懲罰 `-δ`（例如 `δ=0.5~1.0`）。
   * 直覺：鬼越久沒看到，可能在更大區域內；但我們封頂 `R_cap`，避免無限擴張。
4. **單步預測（Local Lookahead, 0/1 步）**：

   * 對「視野內」的鬼，模擬它**下一步**可能朝我靠近（8 向 + 原地）。
   * 若 `n` 在模擬後的鬼可能位置的距離 ≤ 1，給懲罰 `-ζ`（例如 `ζ=1~2`）。
   * 成本極低，但能有效避免走到「下一步被貼臉」的位置。

> 以上 2–4 點都是在「不看不見的鬼」前提下，用**極廉價**的啟發來讓行為更保守、更合理。

# 衝突解算 & 特別規則（Step 3）——不變

* **不可同格**、**禁 swap**、**出口相鄰優先逃脫** 等規則不變。
* 只是現在 scoring 用的 `D_killer` 會因視野而變「稀疏」。

# 參數建議（起手式）

* 距離權重：`α=1.0, β=1.0`
* 安全邊際：`ω=0.3`
* 流量懲罰：`γ=0 ~ 0.2`
* 未知區懲罰：`ε=0.2`
* Last-Seen：`R_cap=5, δ=0.8`
* 一步預測懲罰：`ζ=1.5`
* 近身強懲：`D_killer ≤ 2` 時 `-∞`（或足夠大負分）

# 偽碼補丁（重點行為）

```text
# after Killer Phase
D_exit   = BFS_from_all_exits()
visibleK = { killer k | max(|kx - sx|, |ky - sy|) ≤ 2 for this survivor s }
D_killer = (visibleK is empty) ? +INF_field : BFS_from(visibleK)

# scoring extras:
unknownPenalty(n):
  return -ε if no killer is visible in 5x5 window centered at n else 0

lastSeenPenalty(n):
  for each killer k with last_seen_pos P and last_seen_time τ:
     R = min(t_now - τ, R_cap)
     if max(|nx - Px|, |ny - Py|) ≤ R: return -δ
  return 0

oneStepLookaheadPenalty(n):
  for each visible killer k at K:
     for m in neighbors8(K) ∪ {K}:
        if ChebyshevDist(n, m) ≤ 1: return -ζ
  return 0

score(n) = α*(-D_exit[n]) + β*safety(D_killer[n])
         + γ*flow_penalty(n) + ω*(D_killer[n] - D_exit[n])
         + unknownPenalty(n) + lastSeenPenalty(n) + oneStepLookaheadPenalty(n)
```

> `+INF_field` 可用一個很大的數（例如 10^6）代表「看不到鬼 ⇒ 當下無威脅」，讓 `safety` 不去扣分。

# 行為直覺（你可以預期到的變化）

* 看不到鬼時：生存者會以 `D_exit` 為主線前進，但因未知區小懲罰與 last-seen 陰影，**路徑會更保守**。
* 鬼一旦進入 5×5：`D_killer` 立即收斂，生存者會**大幅避讓**（近身強懲 + 一步預測）。
* 若鬼消失在視野外：威脅場回復「極安全」，但 **last-seen 陰影**仍會短時間維持警戒。

# 測試建議

* 固定種子跑 1000 場，對照「全知 vs 5×5 視野」的：

  * 逃脫率、平均逃脫步數、近身死亡率、卡位次數。
* 調 `ε, δ, ζ`（未知/陰影/預測懲罰）看行為曲線，找你想要的風格（保守/積極）。

---

如果你要，我可以直接給你 **C# 的 `BuildVisibleKillerField`（僅可見鬼的 BFS）、`LastSeenShadow`、以及調好參數的 `ScoreCell`** 版本，照這套邏輯就能跑出有限視野的生存者 AI。


Question : 
到這邊生存者的策略沒有問題，我想要先請你幫我整理一份到目前為止的詳細討論內容 整理的內容我期待要能夠看到我們每一個階段討論的議題，以及修改了哪些規則或策略，最後才會是我們現在的詳細規則

Answer : 
👌 很好，我幫你把我們到目前為止的討論做一份完整整理，分成三個層次：

1. **討論階段回顧** – 我們一步步聊了什麼主題
2. **每階段規則/策略修改** – 哪些規則被補充或修改過
3. **最終整合版詳細規則 (Current Spec)** – 目前的完整遊戲規格

---

# 1. 討論階段回顧

### (A) 初始規則草案

你最先提出了一個簡化版「鬼抓人 POC」的遊戲規則，包括：

* 回合制 100 回合、鬼先行
* 二維平面地圖（可八方向移動）
* 生存者 (1–3) vs 鬼 (2–5)
* 出口 ≥ 2
* 勝負條件（逃脫/捕獲/時間到）
* 生存者策略：往出口走、避鬼
* 鬼策略：追最近生存者

---

### (B) 我補充的完整規則草稿

我幫你整理出更精確的「POC 規格」，包含：

* **座標與距離** (Chebyshev)
* **同格規則** (原本鬼可同格、生可同格，但後續你修改掉)
* **衝突解算** (edge-swap、追尾)
* **事件順序** (鬼先移動捕獲 → 生存者移動逃脫 → 捕獲)
* **起始位置限制** (距出口/敵人最小距離)
* **生存者與鬼的 AI 行為** (用距離/分數決定方向)

---

### (C) 你修改的規則：不可同格

* **所有角色**（鬼-鬼、生-生、生-鬼）都不可同格。
* 我重新定義了「抓捕」：當**嘗試進入對方所在格**時觸發 → 被抓的一方移除 → 所以最終狀態仍不會同格。
* 並修正了衝突解算流程：

  * 鬼-鬼/生-生都要做「競爭 + tie-break」
  * 禁止 swap / 禁止追尾鏈條

---

### (D) 生存者策略：DFS vs BFS

* 我們深入比較：

  * **DFS**：不保證最短路，不適合逃脫需求。
  * **BFS**：能算最短距離，但因為是動態多智能體場景，結果必須每回合重算。
* 結論：用 BFS 來建 **距離場**（出口距離、鬼距離），再配合 **Scoring** 來選一步。

---

### (E) 生存者決策細節 (Scoring)

我提出完整的三步：

1. **BFS 距離場建構** – `D_exit` (出口距離)、`D_killer` (鬼距離)
2. **Scoring 打分** – 對每個候選方向算分：

   ```
   score = α*(-D_exit) + β*D_killer + γ*flow_penalty + ω*margin + 特殊規則
   ```
3. **特別規則** – 出口優先、近身懲罰、最後回合強制前進、一步預測鬼位置

---

### (F) 視野規則修改

* 你覺得「全知視野」對鬼的位置過強，於是修改為：

  * **出口：全知**（生存者永遠知道出口在哪）
  * **鬼：有限視野** → 只能看到自己為中心的 5×5 區域 (Chebyshev 距離 ≤ 2)
* 我幫你調整演算法：

  * `D_exit` 不變（全知）
  * `D_killer` 僅用「可見鬼」跑 BFS
  * 若看不到鬼 → `D_killer` 設為極大值
  * 補強策略：未知區小懲罰、last-seen 陰影、一步預測

---

# 2. 每階段修改過的規則/策略

1. **地圖大小**：從「30×30」改成「預設 50×50」。
2. **同格規則**：從「鬼/生可同格」改為「所有角色不可同格」，抓捕改為「嘗試進入觸發」。
3. **生存者視野**：從「全知」改成「僅出口全知、鬼 5×5 有限視野」。
4. **策略演算法**：從「直覺往出口走」→「BFS + Scoring → 加上特別規則 → 有限視野版」。

---

# 3. 最終詳細規則 (Current Spec)

### 0. 地圖與距離

* 尺寸：預設 50×50，日後可擴大。
* 移動：八方向 + 原地，每步成本 1（Chebyshev）。
* 邊界：不可越界。

### 1. 回合制

* 總共 100 回合。
* 每回合：鬼 Phase → 生存者 Phase。
* **事件順序**：

  * 鬼 Phase：移動 → 抓捕判定（嘗試進入生存者）
  * 生存者 Phase：移動 → 逃脫判定（出口優先） → 抓捕判定（踩到鬼）

### 2. 角色

* 生存者：1–3 人
* 鬼：2–5 人

### 3. 勝利條件

* **生存者隊**：成功逃脫者 +1 分；若全部逃脫則結算分數。
* **鬼隊**：捕獲者 +1 分；若在 100 回合前場上沒生存者，立即勝利；若 100 回合結束還有生存者未逃脫，也算鬼勝。

### 4. 同格規則

* **所有角色不可同格**。
* 抓捕定義：

  * 鬼移動到生存者所在格 → 生存者移除、鬼得分。
  * 生存者移動到鬼所在格 → 生存者移除、鬼得分。
* 最終棋盤狀態不會有重疊。

### 5. 起始配置

* 生/鬼與出口有最小距離 (`D_exit_min=8`)
* 生/鬼間最小距離 (`D_enemy_min=4`)
* 同隊間最小距離 (`D_ally_min=2`)
* 所有角色出生點互不重疊。

### 6. 生存者策略

* **視野**：

  * 出口：全知
  * 鬼：僅限 Chebyshev ≤ 2 (5×5 區域) 可見
* **BFS 場建構**：

  * `D_exit`: BFS from exits (全知)
  * `D_killer`: BFS from visible killers (有限視野)，若無可見鬼 → 設為極大值
* **Scoring 打分**：

  * 基本公式：

    ```
    score(n) = α*(-D_exit[n]) + β*D_killer[n]
             + γ*flow_penalty(n) + ω*(D_killer[n]-D_exit[n])
             + 特別規則
    ```
  * 特別規則：

    * 出口相鄰 → 優先逃脫
    * D\_killer ≤ 2 → 強懲（除非是出口）
    * 最後回合 → 強制逼近出口
    * Last-seen 陰影 → 曾經看過的鬼留下威脅區
    * 一步預測 → 避免走到鬼下一步可能貼臉的位置

### 7. 鬼策略

* 目標：追最近的生存者（Chebyshev 最近，tie-break by id）。
* 移動：往目標縮短距離的一步；同樣做衝突解算（不可同格/禁 swap）。

### 8. 衝突解算

* **同格目標衝突**：多角色想進同一格 → score 高者贏、其他退回原地。
* **swap 衝突**：兩角色互換位置 → 都原地。
* **跟隨鏈**：循環移動 → 後序者退回原地。

---

✅ 這就是我們目前的完整規則。
它已經足夠寫一個 **POC 模擬器**，可以輸出事件日誌（移動、逃脫、捕獲、比分），並且可以測試「全知 vs 有限視野」的差異。

---

要不要我幫你做一個 **流程圖 (Mermaid)**，把「一個回合的處理流程」圖解清楚（鬼 Phase → 生存者 Phase → 事件判定 → 衝突解算）？


Question : 
這邊已經夠詳細，接著我想要先來討論鬼的策略

Answer : 
很好 👌 既然我們生存者的策略已經定案，可以開始專注討論 **鬼的策略**。因為鬼的角色比較單純 —— **目標就是抓生存者**，但是在「不可同格」、「有限回合」和「多隻鬼同場」的前提下，鬼的策略也有很多層次。下面我幫你拆解成三個層次：

---

# 1. 鬼的資訊基礎

* **視野規則**：

  * 在目前規則裡，我們還沒限制鬼的「看見生存者」範圍。
  * 建議 POC 階段：**鬼全知**（知道所有生存者的位置）。
  * 未來可以加「有限視野」（例如 7×7 或 9×9），但這樣鬼可能會走空，POC 先簡單。

* **目標選擇**：

  * 預設：鬼會選「距離最近的生存者」（Chebyshev 最短距離）。
  * 如果有多個生存者距離相同 → 用固定 tie-break 規則（例如 id 最小者）。

---

# 2. 鬼的移動策略（核心）

## (A) 基本版：最短路追擊

* 用 BFS（或直接 Chebyshev 鄰居判斷）計算到目標生存者的距離。
* 從 8 個鄰居裡挑「能縮短距離」的步。
* 同距離的候選步，固定 tie-break（例如：優先 x 軸靠近、再看 y 軸）。
* **缺點**：這種鬼行為會很直線，容易被「風箏」（生存者繞牆、拉出口）。

---

## (B) 多鬼協同（POC 的升級方向）

多隻鬼時有幾個可能策略：

1. **單純各自追最近生存者**

   * 每隻鬼都有獨立目標（最短距離）。
   * 簡單，但可能多隻鬼同時追同一人 → 效率差。

2. **分配目標（Target Assignment）**

   * 全局看每個鬼-生存者距離矩陣，用一個匹配演算法（例如匈牙利算法）把鬼分配給不同的生存者。
   * 確保覆蓋面更廣。
   * 成本較高，但 5 鬼 vs 3 生規模很小，完全可行。

3. **包夾策略（Flanking）**

   * 部分鬼直接追，部分鬼嘗試「切斷逃跑路線」。
   * 實作方式：

     * 對生存者 → 出口做一條「最短路線」。
     * 鬼分工：一隻鬼追逐，一隻鬼往出口方向攔截。

---

## (C) 衝突解算影響下的優化

* 因為「鬼-鬼不可同格」，所以如果所有鬼都直線追同一生存者，常常會「卡在一起」。
* 簡單解法：

  * 在 **Scoring** 加入一個「鬼之間保持距離」的懲罰（例如 ≤1 時 -0.5 分），讓他們自動分散。
* 這樣能避免「兩隻鬼擠在一起、效率低下」。

---

# 3. 鬼的 Scoring（建議版）

對鬼的每一步候選 `n`，可以用一個簡單的評分：

```
score(n) = - dist_to_target_survivor(n)
         + θ * intercept_bonus(n)
         + κ * spacing_penalty(n)
```

* `dist_to_target_survivor(n)`：到目標生存者的距離（越小越好）。
* `intercept_bonus(n)`（選配）：如果 `n` 靠近「生存者 → 出口」的最短路，給加分（模擬攔截行為）。
* `spacing_penalty(n)`（建議）：若 `n` 與其他鬼距離 ≤1，給懲罰（避免擠在一起）。

參數建議：

* `θ = 0.5`（攔截小加成）
* `κ = 0.3`（避免重疊的懲罰）

---

# 4. 特殊規則

* **同時捕獲**：

  * 如果多隻鬼同時嘗試進入生存者位置，只要一隻成功，該生存者就會被捕獲（+1 分），其他鬼就原地。
* **出口守株待兔（Camping）**：

  * 可以加入「若出口距離 ≤ 3，給額外加分」 → 鬼會自動往出口巡邏。
  * 這會讓遊戲更平衡（否則生存者容易直奔出口）。

---

# 5. 建議的三個 POC 階段

1. **單純追擊版**：每隻鬼各自追最近的生存者。
2. **分配目標版**：用匈牙利算法分配鬼 → 生存者。
3. **攔截版**：一部分鬼嘗試切出口路線（需加「出口路徑」的 BFS 場）。

---

✅ 總結：

* POC 最快落地的是 **「每隻鬼都追最近生存者」**，這跟 BFS + Scoring 的生存者策略是對稱的。
* 若要更高級 → 加「鬼之間分工」（分配目標）與「出口攔截」策略。
* 衝突解算下，建議加一點「spacing penalty」，避免鬼都卡在一起。

---

要不要我先幫你寫一個 **鬼的演算法流程圖 (Mermaid)**，從「選目標」到「決定一步」到「捕獲判定」完整跑一次？


Question : 
我認為鬼也不該是全視野，但確實是必須要能夠看的範圍比生存者大一些，所以我想先限制鬼的視野距離為 7X7 

Answer : 
👌 完全明白，你是希望 **鬼也不是全知**，但是相對生存者（5×5 視野），鬼的「感知半徑」更大（7×7 視野）。這樣的設定能讓遊戲更公平，也能模擬真實「鬼比較有優勢但也非全知」的場景。下面我幫你整理 **鬼 7×7 視野規則**，並分析它對鬼的策略演算法會帶來什麼影響。

---

# 1. 視野規則更新

* **出口**：

  * 鬼依然全知（因為出口是固定物件，沒有隱藏的必要）。

* **生存者**：

  * 鬼僅能看到「自己為中心 7×7 區域」內的生存者。
  * 形式化：鬼位置 `(kx,ky)`，能見到的生存者 `s=(sx,sy)`，若 `max(|kx-sx|, |ky-sy|) ≤ 3`（Chebyshev ≤ 3）。
  * 換句話說：視野半徑 = 3，整個視野大小 = 7×7。

---

# 2. 鬼的目標選擇（Targeting）

在有限視野下，鬼需要有「目標選擇邏輯」：

1. **可見時**

   * 若鬼視野內有生存者：

     * 目標 = 最近的可見生存者（距離最小）。
     * 若多名同距離 → 用固定 tie-break（id 最小）。

2. **不可見時**

   * 幾種選項：

     * **Last-seen 模型**：記錄上一次看到的生存者位置，往那邊走。
     * **出口守株待兔**：若長時間沒見到人，往出口方向移動。
     * **隨機巡邏**：在地圖上隨機遊走，直到有生存者進入視野。

POC 版建議：先用 **last-seen > 出口守株待兔 > 隨機巡邏** 的優先序，這樣比較合理。

---

# 3. 鬼的距離場 (BFS)

在有視野限制後：

* `D_survivor`: 鬼要追蹤生存者時，BFS 的起點只能用「視野內的生存者」。
* 若看不到生存者：

  * 使用 `last_seen_pos` 當作 BFS 起點。
  * 若已經超過 `T_timeout` 回合沒看到生存者 → 轉換成「出口巡邏」。

---

# 4. 鬼的 Scoring 更新

鬼的打分公式可以調整為：

```
score(n) = - dist_to_target(n)
         + θ * intercept_bonus(n)
         + κ * spacing_penalty(n)
         + ψ * patrol_bonus(n)
```

* `dist_to_target(n)`：到目標（可見生存者 or last-seen 位置 or 出口）的距離。
* `intercept_bonus(n)`：若 n 靠近「出口路徑」，給小加分。
* `spacing_penalty(n)`：避免鬼卡在一起。
* `patrol_bonus(n)`：若鬼在「出口附近」或「last-seen 附近」巡邏，給小加分，避免鬼完全亂走。

---

# 5. 特殊行為規則

1. **Last-seen 擴散**

   * 每回合沒看到目標，就擴大「last-seen 區域」半徑，模擬生存者可能走遠。
   * 例如：

     * 回合 t 看見在 `(sx,sy)`，存檔。
     * t+1 沒看到 → 可疑區域 = `(sx,sy)` ± 1
     * t+2 沒看到 → 可疑區域 = `(sx,sy)` ± 2
   * 鬼可往這個區域移動搜尋。

2. **出口守株待兔**

   * 若超過 `T_patrol` 回合沒看到人，鬼自動往最近出口移動。

3. **隨機巡邏**

   * 如果完全沒有 last-seen 資訊（例如開場），鬼就隨機選一個方向走。

---

# 6. 視野差異的遊戲平衡

* **生存者視野 5×5 (半徑=2)**

  * 很容易看不到遠方的鬼，逃跑多依賴出口距離場。
* **鬼視野 7×7 (半徑=3)**

  * 鬼能提早發現生存者，比生存者更容易主動接觸。
* **結果**：生存者策略偏向「保守靠出口」，鬼則偏向「攔截 or 追擊」，整體更平衡。

---

✅ 總結：

* 鬼現在的視野 = **7×7 (半徑=3)**。
* 視野內 → 追最近生存者；視野外 → 依序考慮 last-seen / 出口巡邏 / 隨機巡邏。
* 鬼的 BFS 只用「可見生存者」或「last-seen 位置」來建距離場。
* 這樣可以讓鬼比生存者更有優勢，但仍保留「資訊不完整」的挑戰。

---

要不要我幫你把「鬼與生存者的完整感知規則」整理成一張對照表（包含出口 / 鬼 / 生存者的可見性），讓兩邊的差異一目了然？


Question : 
鬼的策略目前也可以了，我想要探討一下這樣子的規則下這幾個問題
1、地圖的大小大概可以到多大? 
2、鬼與生存者的勝率目前是幾比幾?
3、又如果是這樣的勝率，我們該怎麼調整到其中一方的角色勝率不超過 55% ?

Answer : 
讚，我用「可以直接拿去驗證與調參」的角度來回答這三題。

# 1) 地圖最大可到多大？

就我們現在的演算法，每回合主要成本是幾次 BFS（或等價 O(格子數) 的掃場）：

* 生存者：`D_exit` 1 次（多源 BFS from 出口，**全局一次共用**），`D_killer` 為**每位生存者**建一次（起點=各自可見到的鬼）。
* 鬼：若用「追最近目標 + last-seen/出口巡邏」，通常只需要**查距**或小型 BFS（起點=可見生存者或 last-seen）。

粗估每回合複雜度：

```
O( W * H * (1 + #Survivors + ε) )
```

其中 `ε` 是鬼端偶爾的 BFS（通常很小）。

實務指引（單執行緒、普通伺服器級 CPU）：

* **50×50（2,500 格）**：毫無壓力（我們現在的預設）。
* **100×100（10,000 格）**：依舊輕鬆（每回合幾萬級操作）。
* **200×200（40,000 格）**：OK，跑 100 回合也很順。
* **300×300（90,000 格）**：仍可行；若你同場進一步增加角色數或做更多展望預測，可能需要微量最佳化。
* **>500×500（≥250,000 格）**：就建議做兩件事：

  * 把 `D_killer` 改成**限制半徑的局部 BFS**（例如只算到距離 8\~12 的安全即可，超過視為遠離）。
  * 小幅平行化（每位生存者的 `D_killer` 各一個工作項）。

另外兩個簡單最佳化：

* `D_exit` 在地圖與出口固定時可**預先計算並快取**（整場共用）。
* `Last-seen 陰影` 與 `一步預測` 都是**常數級**計算，幾乎不影響規模。

👉 結論：POC 與早期研究，**200×200 完全沒問題**；要上 **300×300 \~ 500×500** 也行，適度做「局部 BFS + 平行化」即可。

---

# 2) 目前鬼與生存者的勝率是多少？

老實說，**不跑模擬就無法定量回答**。因為勝率高度取決於：

* 生/鬼人數（你允許 1–3 vs 2–5）
* 初始距離（`D_exit_min, D_enemy_min`）、出口數與位置
* 視野（生存者 5×5、鬼 7×7）
* 回合上限（100 回合）、不可同格/禁 swap 的卡位效應
* 生存者/鬼的 Scoring 權重與「特別規則」強度

建議你用固定種子進行**蒙地卡羅**（例如每種配置跑 5,000–10,000 場），用二項分佈估置信區間（95% CI）。
指標：鬼勝率、平均逃脫人數、平均逃脫回合、近身死亡率、卡位次數。

---

# 3) 要把任一方勝率壓在 ≤55%，怎麼調？

下面整理一份「**平衡旋鈕**與**勝率方向**」對照表，方便你逐一嘗試（粗體為最有效的槓桿）：

| 類別          | 參數/調整                        | 往生存者有利 | 往鬼有利 | 備註                                 |        |
| ----------- | ---------------------------- | -----: | ---: | ---------------------------------- | ------ |
| **視野**      | **生存者視野半徑**（5×5 → 6×6）       |      ⬆ |      | 生更早避鬼；先從 +1 試                      |        |
|             | **鬼視野半徑**（7×7 → 6×6）         |      ⬆ |      | 鬼較難鎖定；或維持 7×7 但加 last-seen timeout |        |
| 出口          | **出口數量**（≥2 → 3/4）           |      ⬆ |      | 出口多、距離近，逃脫率升                       |        |
|             | 出口布局更分散                      |      ⬆ |      | 避免單點被守株                            |        |
| 人數          | 生存者人數 +1                     |      ⬆ |      | 同步動作更易分散風險                         |        |
|             | 鬼人數 −1                       |      ⬆ |      | 直接影響追擊壓力                           |        |
| **啟動距離**    | **D\_exit\_min−1**（出生更靠近出口）  |      ⬆ |      | 生更快觸達                              |        |
|             | **D\_enemy\_min+1**（出生更遠離對手） |      ⬆ |      | 降低開場秒抓                             |        |
| 迴圈          | 回合上限（100 → 80）               |      ⬆ |      | 壓縮鬼追擊時間                            |        |
|             | 回合上限（100 → 120）              |        |    ⬆ |                                    | 鬼有更多周轉 |
| **Scoring** | **生存者 β↑**（更重視遠離鬼）           |      ⬆ |      | 通常很有效；別讓生過度保守                      |        |
|             | 近身強懲（`D_killer≤2` 負分↑）       |      ⬆ |      | 降低近身死亡                             |        |
|             | **鬼的 spacing penalty↑**      |      ⬆ |      | 鬼不易重疊、減少「蜂擁同一人」效率                  |        |
|             | 鬼的 intercept 加成↑             |        |    ⬆ | 攔截出口更強                             |        |
|             | 鬼 patrol bias（出口守株）↑         |        |    ⬆ | 生需繞行、時間拉長                          |        |
| 事件順序        | 保持「生存者先判逃脫再判被捕」              |      ⬆ |      | 我們已有；若反過來鬼會更強                      |        |

**實務調參流程（建議）**

1. 先選定一組「標準配置」（例如 3 生 vs 3 鬼、出口 2、50×50、視野 5×5/7×7、回合 100）。
2. 跑 5,000 場，觀察鬼勝率 `p` 與 95% CI。
3. 若 `p > 0.55`（鬼太強），依序調整：

   * 生存者 β + 0.1 → 再跑 2,000 場；
   * 鬼 spacing penalty +0.1；
   * `D_enemy_min +1`；
   * 出口 +1（或更分散）；
   * 生視野 +1 或 鬼視野 −1（擇一微調）。
4. 若 `p < 0.45`（鬼太弱），反向操作：

   * 鬼 intercept +0.1 → 再跑；
   * 回合上限 +10；
   * 出口 −1 或改近邊界集中；
   * 鬼視野 +1（若原先有下調）；
   * 生存者 β − 0.1 或近身強懲稍微放鬆。
5. 用「**單參數階梯搜尋**」+「**小批量蒙地卡羅**」逐步逼近 50–55% 區間。

   * 若要更快，可用 **二分/黃金分割** 或 **貝氏最佳化（Thompson Sampling）** 去選下一個參數點。

**觀察指標（避免“假平衡”）**

* 鬼勝率、平均逃脫人數、平均逃脫回合數。
* **近身死亡率**（`D_killer≤1` 發生的比例）—過高 → 生策略或視野需要強化。
* **卡位次數**（生-生/鬼-鬼衝突被退回原地的事件數）—過高 → flow/spacing 懲罰要上調。
* **守株成功率**（鬼在出口 3 格內的捕獲比例）—過高 → 出口數/布局需要調整。

---

## TL;DR

* **地圖規模**：200×200 無痛；到 300×300\~500×500 仍可，建議做局部 BFS + 平行化。
* **勝率**：需要蒙地卡羅實測；不跑無法準確回答。
* **壓到 ≤55%**：從「視野、出口數與布局、出生距離、回合上限、Scoring 權重、鬼的 spacing/intercept」這些旋鈕下手，配合小批量模擬做階梯式微調，數回合就能收斂到目標區間。

如果你願意，我可以幫你生一份**最小可跑的 C# 模擬器**（含批量跑、統計勝率與 CI、以及一組預設調參腳本），你把它丟到 3×3/出口2 的標準配置就能開始做平衡曲線了。


Question : 
針對現在這個版本，我希望增加 xUnit 的測試讓我能夠確認並驗證我的程式，請你先從測試案例幫我開始發想

Answer : 
太好！我先幫你把 **xUnit 測試案例清單**分門別類、以「Given / When / Then」方式列出，並附上少量範例測試骨架（命名、Arrange/Act/Assert 模式與輔助工具建議）。等你點頭，我再把這些轉成可直接執行的 xUnit 測試專案（含測試 helper 與固定地圖生成器）。

---

# A. 初始化與不變式（Initialization & Invariants）

1. **地圖邊界**

* Given：任意 `GameConfig`
* When：初始化
* Then：所有 `Exit` 與角色座標皆在地圖範圍內。

2. **出口數與位置**

* Given：`ExitCount = 2/3/4`
* When：初始化
* Then：地圖上出口數量正確、且互不重疊。

3. **出生距離約束**

* Given：`MinDistToExit/Enemy/Ally`
* When：初始化
* Then：所有生、鬼皆滿足與出口、敵對、同隊的最小距離限制。

4. **互斥佔位**

* Given：初始狀態
* When：初始化
* Then：任意兩個角色位置不相同（不可同格）。

5. **可重現性（Seed）**

* Given：相同 `Seed`
* When：連續初始化兩次
* Then：初始佈局完全相同。

---

# B. 回合流程與事件順序（Turn Order & Resolution）

6. **鬼先行**

* Given：固定小地圖與位置
* When：跑一回合
* Then：先套用鬼的移動與捕獲，之後才是生存者移動→逃脫→捕獲。

7. **逃脫優先於被捕（生存者 Phase）**

* Given：生存者相鄰出口，出口格同時有鬼
* When：生存者移動到出口
* Then：該生存者先逃脫（+1），不會被同格捕獲。

8. **鬼 Phase 的捕獲**

* Given：鬼移動一步即可進入生存者所在格
* When：鬼 Phase
* Then：生存者即時被移除、鬼得分+1。

9. **時間到鬼勝**

* Given：`MaxRounds=1` 且仍有生存者
* When：跑到回合結束
* Then：勝者=鬼。

---

# C. 視野規則（Vision）

10. **生存者視野 5×5**

* Given：生存者與鬼相距 Chebyshev=2/3
* When：計算可視鬼
* Then：距離≤2 可見，=3 不可見。

11. **鬼視野 7×7**

* Given：鬼與生存者相距 Chebyshev=3/4
* Then：距離≤3 可見，=4 不可見。

12. **不可見時 D\_killer 為安全大值**

* Given：生存者看不到任何鬼
* When：建 `BuildVisibleKillerField`
* Then：欄位值為極大（表示安全）。

13. **Last-seen 記錄與 timeout**

* Given：鬼/生互相可見 → 轉為不可見數回合
* Then：LastSeen 資訊保留至 `LastSeenTimeout` 後失效。

---

# D. 距離場與 BFS（Fields）

14. **出口距離場正確性**

* Given：小地圖（5×5）與出口位置
* When：`BuildExitField`
* Then：手動期望矩陣 vs 結果一致（Chebyshev 距離）。

15. **可視鬼距離場（局部）**

* Given：只放 1 隻可視鬼
* Then：距離場以該鬼為多源（單源）擴散、非可視鬼不影響。

---

# E. 生存者策略（Scoring & Moves）

16. **出口相鄰即選出口**

* Given：生存者旁邊有出口且非近身危險
* When：`DecideNext`
* Then：目標=出口格。

17. **近身強懲避免自殺靠近**

* Given：某候選格 `D_killer ≤ 2`（非出口）
* Then：不會選該格。

18. **一步預測避免貼臉**

* Given：鬼可於下一步貼近某候選格
* Then：該候選格分數降低、決策避開。

19. **未知區微懲罰生效**

* Given：候選格周遭 5×5 無可視鬼
* Then：分數含 `UnknownAreaPenalty` 扣分。

20. **Last-seen 陰影懲罰**

* Given：候選格落在 last-seen 擴散半徑內
* Then：分數含 `LastSeenShadowPenalty` 扣分。

---

# F. 鬼策略（Targeting & Moves）

21. **視野內選最近生存者**

* Given：鬼視野內有兩名生存者、距離不同
* Then：鎖定較近者。

22. **視野外使用 last-seen**

* Given：上一回合看見、此回合看不見
* Then：以 last-seen 位置為追蹤目標。

23. **巡邏出口（timeout 後）**

* Given：超過 `LastSeenTimeout` 未見生存者
* Then：目標切到最近出口。

24. **Spacing penalty 促進分散**

* Given：兩隻鬼選擇相鄰格
* Then：spacing 懲罰使其中一隻偏離，避免卡位（以分數對比驗證）。

---

# G. 衝突解算（No-Overlap & No-Swap）

25. **同格競爭：高分者得**

* Given：兩名生存者搶同一格，score A > score B
* Then：A 進格、B 原地。

26. **同分 tie-break by Id**

* Given：兩名生存者搶同一格，score 相等
* Then：Id 較小的進格、另一位原地。

27. **禁止對向交換**

* Given：A\:X→Y、B\:Y→X
* Then：兩者皆原地。

28. **跟隨鏈處理**

* Given：X→Y、Z→X 形成循環
* Then：後序者被回退直至無循環（可驗證最終位置）。

---

# H. 事件與分數（Events & Scoring）

29. **捕獲加分**

* Given：任一捕獲發生
* Then：KillerScore+1、受害者 Alive=false。

30. **逃脫加分且移除**

* Given：生存者踏上出口
* Then：SurvivorScore+1、該生存者 Alive=false。

31. **單回合多事件順序**

* Given：同回合內有捕獲與逃脫
* Then：符合「鬼 Phase 捕獲 → 生存者移動 → 先逃脫 → 再捕獲」順序。

---

# I. 統計穩健性（Monte Carlo 小樣本）

32. **相同參數下勝率穩定範圍**

* Given：固定 config、跑 200 場
* Then：鬼勝率在合理區間（例如 30%\~90%）且重跑差異不超過某閾值（如 ±10%）。

33. **單一旋鈕的單調性（煙霧測試）**

* Given：將 `SurvivorSight` 從 2 → 3
* Then：平均逃脫數不下降（或鬼勝率不上升），做為回歸保護。

---

# J. Logging 與可診斷性（Diagnostics）

34. **關鍵事件輸出**

* Given：開啟 `VerboseLog`
* Then：至少印出 `[ESCAPE]`、`[CAPTURE]` 與回合摘要。

35. **ASCII 地圖輸出格式**

* Given：`PrintAsciiMapEachRound=true`
* Then：輸出中包含 `E`、鬼大寫、生成者小寫、`.` 的棋盤，尺寸正確。

---

## 測試結構建議

* 專案：`TagPOC.Tests`
* 分類檔案：

  * `InitTests.cs`、`TurnOrderTests.cs`、`VisionTests.cs`、`FieldBfsTests.cs`、`SurvivorPolicyTests.cs`、`KillerPolicyTests.cs`、`ConflictResolverTests.cs`、`ScoringTests.cs`、`MonteCarloSmokeTests.cs`、`LoggingTests.cs`
* Helper：

  * `TestConfigFactory`：建立小地圖（如 7×7 / 9×9）與固定佈局。
  * `TestBoardBuilder`：直接指定座標（避免隨機）並略過 Spawn 檢查。
  * `AssertBoard`：提供常用斷言（位置相等、分數變化、無重疊）。
  * `RunOneStep`：只跑單回合或半個 Phase 的微測。

---

## 範例：幾個重點測試骨架

```csharp
public class TurnOrderTests
{
    [Fact]
    public void SurvivorEscapesBeforeBeingCaptured_OnExitTile()
    {
        // Arrange
        var cfg = new GameConfig { Width=7, Height=7, MaxRounds=1, SurvivorCount=1, KillerCount=1, Seed=1, VerboseLog=false };
        var state = TestBoardBuilder.BuildFixed(
            cfg,
            exits: new[] { new Point(3,3) },
            survivors: new[] { new Point(2,2) }, // 相鄰出口
            killers: new[] { new Point(5,5) }
        );

        // Act: 跑完整一回合
        var (_, sScore, kScore, _) = Simulator.RunOne(cfg);

        // Assert
        Assert.True(sScore >= 1, "生存者應先逃脫 +1");
        Assert.True(state.Survivors.All(sv => !sv.Alive) || sScore == 1);
    }
}
```

```csharp
public class VisionTests
{
    [Theory]
    [InlineData(2, true)]
    [InlineData(3, false)]
    public void SurvivorSight_5x5_Chebyshev2_Visible3_NotVisible(int dist, bool expectedVisible)
    {
        var cfg = new GameConfig { Width=9, Height=9, SurvivorSight=2, KillerSight=3, SurvivorCount=1, KillerCount=1, Seed=1 };
        var s = TestBoardBuilder.BuildFixed(cfg,
            exits: new[] { new Point(0,0) },
            survivors: new[] { new Point(4,4) },
            killers: new[] { new Point(4+dist,4) }
        );
        var sv = s.Survivors.Single();
        var visible = Vision.VisibleKillers(s, sv).Any();
        Assert.Equal(expectedVisible, visible);
    }
}
```

```csharp
public class ConflictResolverTests
{
    [Fact]
    public void NoSwap_BothStay_WhenOppositeExchange()
    {
        var cfg = new GameConfig { Width=7, Height=7, SurvivorCount=2, KillerCount=0, Seed=1 };
        var s = TestBoardBuilder.BuildFixed(cfg,
            exits: Array.Empty<Point>(),
            survivors: new[] { new Point(3,3), new Point(4,3) },
            killers: Array.Empty<Point>()
        );

        var a = s.Survivors[0]; var b = s.Survivors[1];
        var sub = new List<(Survivor actor, Point target, double score)>
        {
            (a, b.Pos, 1.0),
            (b, a.Pos, 1.0)
        };

        var decided = MoveConflictResolver.ResolveNoOverlapSwap(s, sub);
        Assert.Equal(a.Pos, decided[a.Id]);
        Assert.Equal(b.Pos, decided[b.Id]);
    }
}
```

---

## 下一步（如果你 OK）

* 我可以把以上 **34+ 項測試**做成可執行的 xUnit 專案骨架（含 `TestBoardBuilder` 等 helper），並先實作 **10–15 個關鍵測試**（事件順序、視野、距離場、生存者出口優先、No-Swap、捕獲/逃脫加分等），讓你在現有 POC 上直接跑起來。
* 後續再逐步把其餘案例補齊，並加入「CI 內的小型 Monte Carlo 煙霧測試」以防回歸。


Question : 
先從 A. 初始化與不變式（Initialization & Invariants） 開始幫我完整完成這幾個測試案例內容

Ansewer : 
太好了！下面先給你 **xUnit 測試專案的兩個檔案**，完整覆蓋 A. 初始化與不變式（1\~5 題）——直接加到 `TagPOC.Tests` 專案就能跑。
（假設你的 POC 專案命名空間仍為 `TagPOC`，測試專案已參考到它）

---

### `TestHelpers.cs`

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using TagPOC;

namespace TagPOC.Tests
{
    /// <summary>
    /// 共用的測試輔助：建立狀態、常用斷言工具。
    /// </summary>
    public static class TestHelpers
    {
        /// <summary>
        /// 依給定 config 建立遊戲狀態，並套用隨機化的 Setup.Initialize。
        /// 用於驗證初始化不變式。
        /// </summary>
        public static GameState BuildInitializedState(GameConfig cfg)
        {
            var state = new GameState(cfg);
            Setup.Initialize(state);
            return state;
        }

        /// <summary>
        /// 取得所有角色位置（存活者），依照 類型→Id 穩定排序。
        /// </summary>
        public static IReadOnlyList<(string kind, int id, Point pos)> GetAllActorPositions(GameState s)
        {
            var survivors = s.Survivors.Where(x => x.Alive).OrderBy(x => x.Id)
                .Select(x => (kind: "S", id: x.Id, pos: x.Pos));
            var killers = s.Killers.Where(x => x.Alive).OrderBy(x => x.Id)
                .Select(x => (kind: "K", id: x.Id, pos: x.Pos));
            return survivors.Concat(killers).ToList();
        }

        public static bool InBounds(GameState s, Point p)
            => p.X >= 0 && p.Y >= 0 && p.X < s.Config.Width && p.Y < s.Config.Height;

        public static int Chebyshev(Point a, Point b) => Point.Chebyshev(a, b);
    }
}
```

---

### `A_InitAndInvariantsTests.cs`

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using TagPOC;
using Xunit;

namespace TagPOC.Tests
{
    /// <summary>
    /// A. 初始化與不變式（Initialization & Invariants）
    /// 覆蓋題目 1~5：
    /// 1) 地圖邊界
    /// 2) 出口數與位置
    /// 3) 出生距離約束
    /// 4) 互斥佔位（不可同格）
    /// 5) 可重現性（Seed）
    /// </summary>
    public class A_InitAndInvariantsTests
    {
        [Fact(DisplayName = "A1. 初始化後：所有出口與角色皆在地圖邊界內")]
        public void AllEntitiesAreWithinBounds_AfterInitialization()
        {
            // Arrange
            var cfg = new GameConfig
            {
                Width = 50, Height = 50,
                SurvivorCount = 3, KillerCount = 3,
                ExitCount = 2,
                Seed = 1234
            };

            // Act
            var s = TestHelpers.BuildInitializedState(cfg);

            // Assert
            foreach (var e in s.Exits)
                Assert.True(TestHelpers.InBounds(s, e), $"Exit {e} out of bounds");

            foreach (var sv in s.Survivors)
                Assert.True(TestHelpers.InBounds(s, sv.Pos), $"Survivor#{sv.Id} at {sv.Pos} out of bounds");

            foreach (var k in s.Killers)
                Assert.True(TestHelpers.InBounds(s, k.Pos), $"Killer#{k.Id} at {k.Pos} out of bounds");
        }

        [Theory(DisplayName = "A2. 出口數量正確且不重疊")]
        [InlineData(2)]
        [InlineData(3)]
        [InlineData(4)]
        public void ExitCountIsCorrect_AndUnique(int exitCount)
        {
            // Arrange
            var cfg = new GameConfig
            {
                Width = 30, Height = 30,
                SurvivorCount = 2, KillerCount = 2,
                ExitCount = exitCount,
                Seed = 4321
            };

            // Act
            var s = TestHelpers.BuildInitializedState(cfg);

            // Assert: 數量
            Assert.Equal(exitCount, s.Exits.Count);

            // 位置唯一
            var unique = s.Exits.Distinct().Count();
            Assert.Equal(s.Exits.Count, unique);

            // 都是 Exit 標記
            foreach (var e in s.Exits)
                Assert.True(s.IsExit(e), $"Exit list contains non-exit at {e}");
        }

        [Fact(DisplayName = "A3. 出生距離約束：與出口/敵對/同隊的最小距離皆滿足")]
        public void SpawnRespectsMinDistances()
        {
            // Arrange
            var cfg = new GameConfig
            {
                Width = 40, Height = 40,
                SurvivorCount = 3, KillerCount = 3,
                ExitCount = 3,
                MinDistToExit = 8,
                MinDistEnemy = 4,
                MinDistAlly = 2,
                Seed = 9876
            };

            // Act
            var s = TestHelpers.BuildInitializedState(cfg);

            // Assert: 生存者與出口距離
            foreach (var sv in s.Survivors)
            {
                var minDExit = s.Exits.Min(e => TestHelpers.Chebyshev(e, sv.Pos));
                Assert.True(minDExit >= cfg.MinDistToExit, $"Survivor#{sv.Id} too close to exit: {minDExit} < {cfg.MinDistToExit}");
            }

            // 鬼與出口距離
            foreach (var k in s.Killers)
            {
                var minDExit = s.Exits.Min(e => TestHelpers.Chebyshev(e, k.Pos));
                Assert.True(minDExit >= cfg.MinDistToExit, $"Killer#{k.Id} too close to exit: {minDExit} < {cfg.MinDistToExit}");
            }

            // 生-鬼 最小距離
            foreach (var sv in s.Survivors)
            {
                var minDenemy = s.Killers.Min(k => TestHelpers.Chebyshev(k.Pos, sv.Pos));
                Assert.True(minDenemy >= cfg.MinDistEnemy, $"S#{sv.Id} too close to any killer: {minDenemy} < {cfg.MinDistEnemy}");
            }

            // 生-生 同隊最小距離
            for (int i = 0; i < s.Survivors.Count; i++)
            for (int j = i + 1; j < s.Survivors.Count; j++)
            {
                var d = TestHelpers.Chebyshev(s.Survivors[i].Pos, s.Survivors[j].Pos);
                Assert.True(d >= cfg.MinDistAlly, $"Survivors too close: d={d} < {cfg.MinDistAlly}");
            }

            // 鬼-鬼 同隊最小距離
            for (int i = 0; i < s.Killers.Count; i++)
            for (int j = i + 1; j < s.Killers.Count; j++)
            {
                var d = TestHelpers.Chebyshev(s.Killers[i].Pos, s.Killers[j].Pos);
                Assert.True(d >= cfg.MinDistAlly, $"Killers too close: d={d} < {cfg.MinDistAlly}");
            }
        }

        [Fact(DisplayName = "A4. 初始化後所有角色互不重疊（不可同格）")]
        public void NoOverlappingActors_OnInitialization()
        {
            // Arrange
            var cfg = new GameConfig
            {
                Width = 50, Height = 50,
                SurvivorCount = 3, KillerCount = 3,
                ExitCount = 2,
                Seed = 2468
            };

            // Act
            var s = TestHelpers.BuildInitializedState(cfg);

            // Assert
            var positions = TestHelpers.GetAllActorPositions(s).Select(x => x.pos).ToList();
            var distinct = positions.Distinct().Count();
            Assert.Equal(positions.Count, distinct);
        }

        [Fact(DisplayName = "A5. 相同 Seed 可重現：兩次初始化的佈局一致")]
        public void SameSeed_ProducesIdenticalInitialLayout()
        {
            // Arrange
            var cfg = new GameConfig
            {
                Width = 40, Height = 40,
                SurvivorCount = 2, KillerCount = 2,
                ExitCount = 2,
                Seed = 13579
            };

            // Act
            var s1 = TestHelpers.BuildInitializedState(cfg);
            var s2 = TestHelpers.BuildInitializedState(cfg);

            // Assert：出口順序與座標相同
            Assert.Equal(s1.Exits.Count, s2.Exits.Count);
            for (int i = 0; i < s1.Exits.Count; i++)
                Assert.Equal(s1.Exits[i], s2.Exits[i]);

            // 角色位置（依 Id）相同
            Assert.Equal(s1.Survivors.Count, s2.Survivors.Count);
            for (int i = 0; i < s1.Survivors.Count; i++)
                Assert.Equal(s1.Survivors[i].Pos, s2.Survivors[i].Pos);

            Assert.Equal(s1.Killers.Count, s2.Killers.Count);
            for (int i = 0; i < s1.Killers.Count; i++)
                Assert.Equal(s1.Killers[i].Pos, s2.Killers[i].Pos);
        }
    }
}
```

---

### 使用提示

* 把這兩個檔案放到你的測試專案（e.g. `TagPOC.Tests`）底下。
* 測試專案 `csproj` 記得參考你的 POC 專案（含命名空間 `TagPOC`）。
* 直接執行 `dotnet test` 可看到 A1\~A5 都會執行。

如果你覺得 OK，我可以接著把 **B. 回合流程與事件順序**（6\~9）也實作成測試檔，順便補一個 `TestBoardBuilder.BuildFixed(...)`，讓我們能在固定布局下檢驗事件順序與邊界情境。


Question : 
只有幾個地方需要再多注意變數的名稱，我認為這些區域變數雖然只有在這個範圍內使用但是可讀性還是很重要的 1、cfg => config 2、s => gameState 3、foreach 內的變數 e.g. sv => survivor 、 e => point 幫我修正一版

Answer:
收到 ✅
我幫你把 `A_InitAndInvariantsTests.cs` 裡的區域變數名稱與迴圈變數全數調整為更具可讀性：

* `cfg` → `config`
* `s` → `gameState`
* `sv` → `survivor`
* `k` → `killer`
* `e` → `exitPoint`
* `d` → `distance`

下面是修正版：

---

### `A_InitAndInvariantsTests.cs`（命名優化後）

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using TagPOC;
using Xunit;

namespace TagPOC.Tests
{
    /// <summary>
    /// A. 初始化與不變式（Initialization & Invariants）
    /// 覆蓋題目 1~5：
    /// 1) 地圖邊界
    /// 2) 出口數與位置
    /// 3) 出生距離約束
    /// 4) 互斥佔位（不可同格）
    /// 5) 可重現性（Seed）
    /// </summary>
    public class A_InitAndInvariantsTests
    {
        [Fact(DisplayName = "A1. 初始化後：所有出口與角色皆在地圖邊界內")]
        public void AllEntitiesAreWithinBounds_AfterInitialization()
        {
            // Arrange
            var config = new GameConfig
            {
                Width = 50, Height = 50,
                SurvivorCount = 3, KillerCount = 3,
                ExitCount = 2,
                Seed = 1234
            };

            // Act
            var gameState = TestHelpers.BuildInitializedState(config);

            // Assert
            foreach (var exitPoint in gameState.Exits)
                Assert.True(TestHelpers.InBounds(gameState, exitPoint), $"Exit {exitPoint} out of bounds");

            foreach (var survivor in gameState.Survivors)
                Assert.True(TestHelpers.InBounds(gameState, survivor.Pos), $"Survivor#{survivor.Id} at {survivor.Pos} out of bounds");

            foreach (var killer in gameState.Killers)
                Assert.True(TestHelpers.InBounds(gameState, killer.Pos), $"Killer#{killer.Id} at {killer.Pos} out of bounds");
        }

        [Theory(DisplayName = "A2. 出口數量正確且不重疊")]
        [InlineData(2)]
        [InlineData(3)]
        [InlineData(4)]
        public void ExitCountIsCorrect_AndUnique(int exitCount)
        {
            // Arrange
            var config = new GameConfig
            {
                Width = 30, Height = 30,
                SurvivorCount = 2, KillerCount = 2,
                ExitCount = exitCount,
                Seed = 4321
            };

            // Act
            var gameState = TestHelpers.BuildInitializedState(config);

            // Assert: 數量
            Assert.Equal(exitCount, gameState.Exits.Count);

            // 位置唯一
            var unique = gameState.Exits.Distinct().Count();
            Assert.Equal(gameState.Exits.Count, unique);

            // 都是 Exit 標記
            foreach (var exitPoint in gameState.Exits)
                Assert.True(gameState.IsExit(exitPoint), $"Exit list contains non-exit at {exitPoint}");
        }

        [Fact(DisplayName = "A3. 出生距離約束：與出口/敵對/同隊的最小距離皆滿足")]
        public void SpawnRespectsMinDistances()
        {
            // Arrange
            var config = new GameConfig
            {
                Width = 40, Height = 40,
                SurvivorCount = 3, KillerCount = 3,
                ExitCount = 3,
                MinDistToExit = 8,
                MinDistEnemy = 4,
                MinDistAlly = 2,
                Seed = 9876
            };

            // Act
            var gameState = TestHelpers.BuildInitializedState(config);

            // Assert: 生存者與出口距離
            foreach (var survivor in gameState.Survivors)
            {
                var minExitDistance = gameState.Exits.Min(exitPoint => TestHelpers.Chebyshev(exitPoint, survivor.Pos));
                Assert.True(minExitDistance >= config.MinDistToExit,
                    $"Survivor#{survivor.Id} too close to exit: {minExitDistance} < {config.MinDistToExit}");
            }

            // 鬼與出口距離
            foreach (var killer in gameState.Killers)
            {
                var minExitDistance = gameState.Exits.Min(exitPoint => TestHelpers.Chebyshev(exitPoint, killer.Pos));
                Assert.True(minExitDistance >= config.MinDistToExit,
                    $"Killer#{killer.Id} too close to exit: {minExitDistance} < {config.MinDistToExit}");
            }

            // 生-鬼 最小距離
            foreach (var survivor in gameState.Survivors)
            {
                var minEnemyDistance = gameState.Killers.Min(killer => TestHelpers.Chebyshev(killer.Pos, survivor.Pos));
                Assert.True(minEnemyDistance >= config.MinDistEnemy,
                    $"S#{survivor.Id} too close to any killer: {minEnemyDistance} < {config.MinDistEnemy}");
            }

            // 生-生 同隊最小距離
            for (int i = 0; i < gameState.Survivors.Count; i++)
            for (int j = i + 1; j < gameState.Survivors.Count; j++)
            {
                var distance = TestHelpers.Chebyshev(gameState.Survivors[i].Pos, gameState.Survivors[j].Pos);
                Assert.True(distance >= config.MinDistAlly,
                    $"Survivors too close: d={distance} < {config.MinDistAlly}");
            }

            // 鬼-鬼 同隊最小距離
            for (int i = 0; i < gameState.Killers.Count; i++)
            for (int j = i + 1; j < gameState.Killers.Count; j++)
            {
                var distance = TestHelpers.Chebyshev(gameState.Killers[i].Pos, gameState.Killers[j].Pos);
                Assert.True(distance >= config.MinDistAlly,
                    $"Killers too close: d={distance} < {config.MinDistAlly}");
            }
        }

        [Fact(DisplayName = "A4. 初始化後所有角色互不重疊（不可同格）")]
        public void NoOverlappingActors_OnInitialization()
        {
            // Arrange
            var config = new GameConfig
            {
                Width = 50, Height = 50,
                SurvivorCount = 3, KillerCount = 3,
                ExitCount = 2,
                Seed = 2468
            };

            // Act
            var gameState = TestHelpers.BuildInitializedState(config);

            // Assert
            var positions = TestHelpers.GetAllActorPositions(gameState).Select(x => x.pos).ToList();
            var distinct = positions.Distinct().Count();
            Assert.Equal(positions.Count, distinct);
        }

        [Fact(DisplayName = "A5. 相同 Seed 可重現：兩次初始化的佈局一致")]
        public void SameSeed_ProducesIdenticalInitialLayout()
        {
            // Arrange
            var config = new GameConfig
            {
                Width = 40, Height = 40,
                SurvivorCount = 2, KillerCount = 2,
                ExitCount = 2,
                Seed = 13579
            };

            // Act
            var gameState1 = TestHelpers.BuildInitializedState(config);
            var gameState2 = TestHelpers.BuildInitializedState(config);

            // Assert：出口順序與座標相同
            Assert.Equal(gameState1.Exits.Count, gameState2.Exits.Count);
            for (int i = 0; i < gameState1.Exits.Count; i++)
                Assert.Equal(gameState1.Exits[i], gameState2.Exits[i]);

            // 角色位置（依 Id）相同
            Assert.Equal(gameState1.Survivors.Count, gameState2.Survivors.Count);
            for (int i = 0; i < gameState1.Survivors.Count; i++)
                Assert.Equal(gameState1.Survivors[i].Pos, gameState2.Survivors[i].Pos);

            Assert.Equal(gameState1.Killers.Count, gameState2.Killers.Count);
            for (int i = 0; i < gameState1.Killers.Count; i++)
                Assert.Equal(gameState1.Killers[i].Pos, gameState2.Killers[i].Pos);
        }
    }
}
```

---

這樣調整之後，可讀性會更強，測試內容的意圖也能「一眼看懂」。
要不要我接著幫你把 **B. 回合流程與事件順序（6\~9）** 也用同樣命名風格寫完整測試？


Question : 
請在 B. 回合流程的程式注意一個城市風格，我希望所有迴圈，即便只有執行一行程式也要用 { } 區隔
現在可以開始 B 回合流程的測試了

Answer :
太棒，收到你的「所有迴圈一律加大括號」要求了 🙌
下面我直接給出 **B. 回合流程與事件順序（6–9）** 的完整 xUnit 測試與輔助工具。重點：

* 全部 `for/foreach/while` 都有 `{ }`。
* 提供 `TestBoardBuilder.BuildFixed(...)` 來建立**固定佈局**的 `GameState`（避免隨機）。
* 提供 `StepRunner` 幫你在**固定狀態**上，獨立執行「鬼 Phase」與「生存者 Phase」，以及回合收尾檢查（不必依賴 `Simulator.RunOne` 的隨機初始化）。
* 測試案例覆蓋：
  6\) 鬼先行（包含在鬼 Phase 就完成捕獲）
  7\) 生存者在出口上 **先逃脫** 再判被捕
  8\) 鬼 Phase 的捕獲邏輯
  9\) 時間到（MaxRounds）→ 鬼勝

> 假設你的主程式專案命名空間仍為 `TagPOC`，且測試專案為 `TagPOC.Tests`。

---

## `TestBoardBuilder.cs`

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using TagPOC;

namespace TagPOC.Tests
{
    /// <summary>
    /// 直接以固定佈局建立 GameState，避免隨機初始化。
    /// </summary>
    public static class TestBoardBuilder
    {
        public static GameState BuildFixed(
            GameConfig config,
            IEnumerable<Point> exits,
            IEnumerable<Point> survivors,
            IEnumerable<Point> killers)
        {
            var gameState = new GameState(config);

            // 佈置出口
            foreach (var exitPoint in exits)
            {
                gameState.Map[exitPoint.X, exitPoint.Y] = TileType.Exit;
                gameState.Exits.Add(exitPoint);
            }

            // 佈置生存者
            int survivorId = 0;
            foreach (var pos in survivors)
            {
                var survivor = new Survivor(survivorId++, pos);
                gameState.Survivors.Add(survivor);
            }

            // 佈置鬼
            int killerId = 0;
            foreach (var pos in killers)
            {
                var killer = new Killer(killerId++, pos);
                gameState.Killers.Add(killer);
            }

            // 簡單檢查：所有座標在界內、初始互不重疊
            var all = gameState.Survivors.Select(x => x.Pos)
                         .Concat(gameState.Killers.Select(x => x.Pos))
                         .ToList();
            if (all.Distinct().Count() != all.Count)
            {
                throw new ArgumentException("Initial actors overlap in BuildFixed().");
            }
            foreach (var p in all.Concat(gameState.Exits))
            {
                if (!gameState.InBounds(p))
                {
                    throw new ArgumentException($"Point {p} out of bounds in BuildFixed().");
                }
            }

            // 從第 1 回合開始（與主模擬一致）
            gameState.Round = 1;
            return gameState;
        }
    }
}
```

---

## `StepRunner.cs`

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using TagPOC;

namespace TagPOC.Tests
{
    /// <summary>
    /// 在固定的 GameState 上，單獨執行 Killer Phase / Survivor Phase 的小工具。
    /// 專供測試「事件順序」與「回合收尾」。
    /// </summary>
    public static class StepRunner
    {
        public static int[,] BuildExitField(GameState gameState)
        {
            return DistanceFieldBuilder.BuildExitField(gameState);
        }

        public static void RunKillerPhase(GameState gameState, int[,] exitField)
        {
            var killerMoves = new List<(Killer actor, Point target, double score)>();
            foreach (var killer in gameState.Killers.Where(k => k.Alive))
            {
                var target = KillerPolicy.DecideNext(gameState, killer, exitField);
                var sc = -Point.Chebyshev(target, killer.Pos);
                killerMoves.Add((killer, target, sc));
            }

            var decided = MoveConflictResolver.ResolveNoOverlapSwap(gameState, killerMoves);
            // 套用移動
            foreach (var kv in decided)
            {
                var killer = gameState.Killers.First(a => a.Id == kv.Key);
                killer.Pos = kv.Value;
            }

            // 捕獲 #1：鬼停到生存者所在格 -> 生存者移除 +1 分
            foreach (var killer in gameState.Killers.Where(k => k.Alive))
            {
                var victims = gameState.Survivors.Where(sv => sv.Alive && sv.Pos.Equals(killer.Pos)).ToList();
                foreach (var survivor in victims)
                {
                    survivor.Alive = false;
                    gameState.KillerScore++;
                }
            }
        }

        public static void RunSurvivorPhase(GameState gameState, int[,] exitField)
        {
            var survivorMoves = new List<(Survivor actor, Point target, double score)>();
            foreach (var survivor in gameState.Survivors.Where(sv => sv.Alive))
            {
                var target = SurvivorPolicy.DecideNext(gameState, survivor, exitField);
                var sc = -Point.Chebyshev(target, survivor.Pos);
                survivorMoves.Add((survivor, target, sc));
            }

            var decided = MoveConflictResolver.ResolveNoOverlapSwap(gameState, survivorMoves);

            // 先套用移動
            foreach (var kv in decided)
            {
                var survivor = gameState.Survivors.First(a => a.Id == kv.Key);
                survivor.Pos = kv.Value;
            }

            // 先判逃脫
            foreach (var survivor in gameState.Survivors.Where(sv => sv.Alive && gameState.IsExit(sv.Pos)).ToList())
            {
                survivor.Alive = false;
                gameState.SurvivorScore++;
            }

            // 再判與鬼同格的被捕
            foreach (var survivor in gameState.Survivors.Where(sv => sv.Alive).ToList())
            {
                if (gameState.Killers.Any(k => k.Alive && k.Pos.Equals(survivor.Pos)))
                {
                    survivor.Alive = false;
                    gameState.KillerScore++;
                }
            }
        }

        public static string DecideWinnerOnTimeout(GameState gameState)
        {
            // 規則：時間到且仍有生存者 => 鬼勝；若提早無生存者 => 鬼勝（但本函數只用於 timeout 場景）
            if (gameState.Survivors.Any(sv => sv.Alive))
            {
                return "Killer";
            }
            return "Survivor"; // 理論上 timeout 時通常不會全逃，但保留語義完整性
        }
    }
}
```

---

## `B_TurnOrderTests.cs`

```csharp
using System;
using System.Linq;
using TagPOC;
using Xunit;

namespace TagPOC.Tests
{
    /// <summary>
    /// B. 回合流程與事件順序（6~9）
    /// 6) 鬼先行（鬼 Phase 可直接捕獲）
    /// 7) 生存者相鄰出口且出口上有鬼 → 生存者先逃脫
    /// 8) 鬼 Phase 的捕獲
    /// 9) 時間到（MaxRounds）鬼勝
    /// </summary>
    public class B_TurnOrderTests
    {
        [Fact(DisplayName = "B6. 鬼先行：鬼 Phase 可直接捕獲，生存者在該回合不再行動")]
        public void KillerMovesFirst_AndCanCapture_BeforeSurvivorActs()
        {
            // 佈局：鬼一步可進入生存者格；確保生存者在該回合前半就被抓
            var config = new GameConfig
            {
                Width = 9, Height = 9,
                SurvivorCount = 0, KillerCount = 0,
                Seed = 1
            };

            var exitPos = new[] { new Point(0, 0) }; // 無關緊要
            var survivors = new[] { new Point(4, 4) };
            var killers = new[] { new Point(3, 3) }; // 斜向一步即可進入 (4,4)

            var gameState = TestBoardBuilder.BuildFixed(config, exitPos, survivors, killers);
            var exitField = StepRunner.BuildExitField(gameState);

            // Killer Phase
            StepRunner.RunKillerPhase(gameState, exitField);

            // 應在 Killer Phase 就移除生存者，且 KillerScore+1
            Assert.Equal(0, gameState.Survivors.Count(s => s.Alive));
            Assert.Equal(1, gameState.KillerScore);

            // 之後 Survivor Phase 即使執行，也不應有生存者行動
            StepRunner.RunSurvivorPhase(gameState, exitField);
            Assert.Equal(0, gameState.Survivors.Count(s => s.Alive));
            Assert.Equal(1, gameState.KillerScore);
        }

        [Fact(DisplayName = "B7. 生存者進入出口（出口上有鬼）時，先逃脫再判被捕")]
        public void SurvivorEscapesBeforeCapture_WhenMovingOntoExitEvenIfKillerOnExit()
        {
            // 佈局：出口 (4,4)；鬼一開始就站在出口；生存者相鄰出口 (3,3)
            var config = new GameConfig
            {
                Width = 9, Height = 9,
                SurvivorCount = 0, KillerCount = 0,
                Seed = 2
            };

            var exitPos = new[] { new Point(4, 4) };
            var survivors = new[] { new Point(3, 3) }; // 下一步可走到 (4,4)
            var killers = new[] { new Point(4, 4) };   // 鬼占在出口

            var gameState = TestBoardBuilder.BuildFixed(config, exitPos, survivors, killers);
            var exitField = StepRunner.BuildExitField(gameState);

            // 直接執行 Survivor Phase（假設 Killer Phase 此 turn 不移動或無關）
            StepRunner.RunSurvivorPhase(gameState, exitField);

            // 期望：生存者因踏上出口→立刻逃脫 +1，被移除；鬼分數不變
            Assert.Equal(0, gameState.Survivors.Count(s => s.Alive));
            Assert.Equal(1, gameState.SurvivorScore);
            Assert.Equal(0, gameState.KillerScore);
        }

        [Fact(DisplayName = "B8. 鬼 Phase 的捕獲：鬼移動到生存者所在格時立即捕獲 +1")]
        public void KillerPhaseCapture_GrantsKillerPoint_AndRemovesSurvivor()
        {
            var config = new GameConfig
            {
                Width = 9, Height = 9,
                SurvivorCount = 0, KillerCount = 0,
                Seed = 3
            };

            var exitPos = new[] { new Point(0, 0) };
            var survivors = new[] { new Point(5, 5) };
            var killers = new[] { new Point(4, 4) }; // 一步可至 (5,5)

            var gameState = TestBoardBuilder.BuildFixed(config, exitPos, survivors, killers);
            var exitField = StepRunner.BuildExitField(gameState);

            StepRunner.RunKillerPhase(gameState, exitField);

            Assert.Equal(0, gameState.Survivors.Count(s => s.Alive));
            Assert.Equal(1, gameState.KillerScore);
        }

        [Fact(DisplayName = "B9. 時間到且仍有生存者未逃脫 => 鬼勝")]
        public void KillerWinsOnTimeout_WhenAnySurvivorRemains()
        {
            // 佈局：彼此很遠，確保此回合內不會有捕獲也不會逃脫
            var config = new GameConfig
            {
                Width = 9, Height = 9,
                SurvivorCount = 0, KillerCount = 0,
                MaxRounds = 1,
                Seed = 4
            };

            var exitPos = new[] { new Point(8, 8) };
            var survivors = new[] { new Point(1, 1) }; // 距出口遠
            var killers = new[] { new Point(0, 8) };   // 距生存者遠

            var gameState = TestBoardBuilder.BuildFixed(config, exitPos, survivors, killers);
            var exitField = StepRunner.BuildExitField(gameState);

            // 跑一個完整回合（鬼 → 生存者）
            StepRunner.RunKillerPhase(gameState, exitField);
            StepRunner.RunSurvivorPhase(gameState, exitField);

            // 模擬時間到（MaxRounds = 1）
            gameState.Round = config.MaxRounds;

            // 仍有生存者存活 → timeout 規則下判定鬼勝
            Assert.True(gameState.Survivors.Any(s => s.Alive), "There should still be a survivor alive for timeout test.");
            var winner = StepRunner.DecideWinnerOnTimeout(gameState);
            Assert.Equal("Killer", winner);
        }
    }
}
```

---

### 使用方式

1. 把三個檔案加入你的 `TagPOC.Tests` 測試專案。
2. 確保測試專案已 **Project Reference** 你的主程式專案（`TagPOC.csproj`）。
3. 執行 `dotnet test`。你應該會看到 `B6 ~ B9` 皆通過。

---

如果你想要，我可以把這套測試再補上 **C. 視野規則** 與 **D. 距離場** 的單元測試，沿用同一套 `BuildFixed`/`StepRunner`，並維持你要求的程式風格（所有迴圈一律加 `{ }`）。


Question : 可以先進行 C 

Answer:
太好，我先完成 **C. 視野規則**（10–13） 的 xUnit 測試。
重點都照你的程式風格：**所有迴圈（for/foreach/while）即便一行也加上 `{ }`**。
這些測試直接使用我們先前的 `TestBoardBuilder` 與 `StepRunner`，不需要再動到主程式碼。

---

## `C_VisionTests.cs`

```csharp
using System;
using System.Linq;
using TagPOC;
using Xunit;

namespace TagPOC.Tests
{
    /// <summary>
    /// C. 視野規則（10~13）
    /// 10) 生存者視野 5×5（Chebyshev ≤ 2 可見）
    /// 11) 鬼視野 7×7（Chebyshev ≤ 3 可見）
    /// 12) 看不到任何鬼時，BuildVisibleKillerField 應為超大安全值
    /// 13) Last-seen 與 timeout：鬼在看不見生存者超過 timeout 後，改以出口為目標
    /// </summary>
    public class C_VisionTests
    {
        [Theory(DisplayName = "C10. SurvivorSight 5×5：距離 2 可見、距離 3 不可見")]
        [InlineData(2, true)]
        [InlineData(3, false)]
        public void SurvivorSight_5x5_Chebyshev2Visible3NotVisible(int distance, bool expectedVisible)
        {
            // Arrange
            var config = new GameConfig
            {
                Width =  nine, Height = nine,
                SurvivorCount = 0, KillerCount = 0,
                SurvivorSight = 2, // 5x5
                KillerSight = 3,   // 7x7（此測試無關）
                Seed = 1
            };

            var survivorPos = new Point(4, 4);
            var killerPos   = new Point(4 + distance, 4);
            var exits       = new[] { new Point(0, 0) };

            var gameState = TestBoardBuilder.BuildFixed(
                config,
                exits,
                survivors: new[] { survivorPos },
                killers:   new[] { killerPos }
            );

            // Act
            var survivor = gameState.Survivors.Single();
            var visible = Vision.VisibleKillers(gameState, survivor).Any();

            // Assert
            Assert.Equal(expectedVisible, visible);
        }

        [Theory(DisplayName = "C11. KillerSight 7×7：距離 3 可見、距離 4 不可見")]
        [InlineData(3, true)]
        [InlineData(4, false)]
        public void KillerSight_7x7_Chebyshev3Visible4NotVisible(int distance, bool expectedVisible)
        {
            // Arrange
            var config = new GameConfig
            {
                Width =  nine, Height = nine,
                SurvivorCount = 0, KillerCount = 0,
                SurvivorSight = 2,
                KillerSight = 3, // 7x7
                Seed = 2
            };

            var killerPos   = new Point(4, 4);
            var survivorPos = new Point(4 + distance, 4);
            var exits       = new[] { new Point(0, 0) };

            var gameState = TestBoardBuilder.BuildFixed(
                config,
                exits,
                survivors: new[] { survivorPos },
                killers:   new[] { killerPos }
            );

            // Act
            var killer = gameState.Killers.Single();
            var visible = Vision.VisibleSurvivors(gameState, killer).Any();

            // Assert
            Assert.Equal(expectedVisible, visible);
        }

        [Fact(DisplayName = "C12. 看不到任何鬼時，D_killer 場為超大安全值（近似無限）")]
        public void KillerField_IsVeryLarge_WhenNoKillerVisible()
        {
            // Arrange
            var config = new GameConfig
            {
                Width =  nine, Height = nine,
                SurvivorCount = 0, KillerCount = 0,
                SurvivorSight = 2, // 5x5 視野小，讓鬼超出視野
                KillerSight = 3,
                Seed = 3
            };

            var survivorPos = new Point(4, 4);
            var killerPos   = new Point(0, 8); // 與生存者距離 Chebyshev=4+ => 超過視野
            var exits       = new[] { new Point(8, 8) };

            var gameState = TestBoardBuilder.BuildFixed(
                config,
                exits,
                survivors: new[] { survivorPos },
                killers:   new[] { killerPos }
            );

            var survivor = gameState.Survivors.Single();

            // Act
            var dKiller = DistanceFieldBuilder.BuildVisibleKillerField(gameState, survivor);

            // Assert：任一格應該都是很大的值（我們在實作中用 1_000_000）
            // 為了降低耦合，這裡只檢查「足夠大」門檻，例如 > 100_000。
            for (int x = 0; x < config.Width; x++)
            {
                for (int y = 0; y < config.Height; y++)
                {
                    Assert.True(dKiller[x, y] > 100_000, $"Expected very large safe distance at ({x},{y}), got {dKiller[x, y]}");
                }
            }
        }

        [Fact(DisplayName = "C13. Killer Last-seen 與 Timeout：超時後改以出口為目標移動")]
        public void KillerUsesExitAfterLastSeenTimeout()
        {
            // Arrange：設計幾何讓方向可明顯區分
            // 地圖中心 (4,4) 放鬼；生存者「北方」(4,1) 先讓鬼看到一次；
            // 出口「東方」(8,4)。timeout 前鬼應往北走；timeout 後應往東走。
            var config = new GameConfig
            {
                Width =  nine, Height = nine,
                SurvivorCount = 0, KillerCount = 0,
                SurvivorSight = 2,
                KillerSight = 3,
                LastSeenTimeout = 2, // 短一點，方便測
                Seed = 4
            };

            var exitPoint   = new Point(8, 4); // 東方出口
            var killerStart = new Point(4, 4); // 中心
            var seenSurvivorPos = new Point(4, 1); // 北方（可見距離 3）
            var outOfSightPos   = new Point(0, 0); // 之後移出視野

            var gameState = TestBoardBuilder.BuildFixed(
                config,
                exits: new[] { exitPoint },
                survivors: new[] { seenSurvivorPos },
                killers:   new[] { killerStart }
            );
            var killer = gameState.Killers.Single();

            // 先讓鬼看到一次（Round 1）
            var exitField = StepRunner.BuildExitField(gameState);
            var firstStepTowardSeen = KillerPolicy.DecideNext(gameState, killer, exitField);
            // 應朝北（y-1）或（x不變,y-1 或 斜向北）以縮短到 (4,1)
            Assert.True(firstStepTowardSeen.Y <= killer.Pos.Y,
                $"Expected first move to reduce Y toward north; got {firstStepTowardSeen}");

            // 套用這一步，並將生存者移到視野外
            killer.Pos = firstStepTowardSeen;
            gameState.Survivors.Single().Pos = outOfSightPos;

            // 模擬 timeout：推進回合數超過 LastSeenTimeout
            gameState.Round += config.LastSeenTimeout + 1;

            // 再決策一次：現在應該以出口為目標，朝東移動（x+1 方向）
            var stepAfterTimeout = KillerPolicy.DecideNext(gameState, killer, exitField);

            Assert.True(stepAfterTimeout.X >= killer.Pos.X,
                $"Expected step after timeout to move east (toward exit at {exitPoint}), got {stepAfterTimeout} from {killer.Pos}");
        }

        // 小工具：為了避免魔數，這裡定義 9
        private const int nine = 9;
    }
}
```

---

### 怎麼跑

1. 把 `C_VisionTests.cs` 放進你的 `TagPOC.Tests` 測試專案。
2. 之前提供的 `TestBoardBuilder.cs`、`StepRunner.cs` 已經能支援這些測試。
3. 直接執行：`dotnet test`。你應該會看到 **C10 \~ C13** 全部通過。

---

需要我繼續補 **D. 距離場與 BFS（14–15）** 的測試嗎？我可以用 5×5 固定地圖做一個期望矩陣比對，並檢查可視鬼距離場只受「視野內」鬼影響。


Question : 
開始 D 

Answer : 
讚，我把 **D. 距離場與 BFS（14–15）** 的 xUnit 測試一次補齊。
重點同之前要求：**所有迴圈（for/foreach/while）即使只有一行也一律使用 `{ }` 大括號**，命名清晰（`config`、`gameState`、`exitPoint`、`survivor`、`killer`…）。

把下面單一檔案加入你的測試專案 `TagPOC.Tests` 即可執行。
（此檔依賴我們先前已提供的 `TestBoardBuilder.cs` 與主專案內的 `DistanceFieldBuilder`、`GameState` 等。）

---

## `D_FieldBfsTests.cs`

```csharp
using System;
using System.Linq;
using TagPOC;
using Xunit;

namespace TagPOC.Tests
{
    /// <summary>
    /// D. 距離場與 BFS（14–15）
    /// 14) 出口距離場正確性（Chebyshev + 多源）
    /// 15) 可視鬼距離場（僅以「可見鬼」為多源；不可見鬼不影響）
    /// </summary>
    public class D_FieldBfsTests
    {
        [Fact(DisplayName = "D14. 出口距離場 = 對所有出口 Chebyshev 距離的最小值（多源 BFS）")]
        public void ExitDistanceField_EqualsMinChebyshevToAllExits()
        {
            // Arrange：5x5，小地圖兩個出口（對角）
            var config = new GameConfig
            {
                Width = five, Height = five,
                SurvivorCount = 0, KillerCount = 0,
                ExitCount = 0, // 我們用固定佈局自行放置
                Seed = 1
            };

            var exitA = new Point(0, 0);
            var exitB = new Point(4, 4);
            var gameState = TestBoardBuilder.BuildFixed(
                config,
                exits: new[] { exitA, exitB },
                survivors: Array.Empty<Point>(),
                killers: Array.Empty<Point>());

            // Act
            var exitField = DistanceFieldBuilder.BuildExitField(gameState);

            // Assert：每格應為 min( Chebyshev(·,exitA), Chebyshev(·,exitB) )
            for (int x = 0; x < config.Width; x++)
            {
                for (int y = 0; y < config.Height; y++)
                {
                    var point = new Point(x, y);
                    var expected = Math.Min(Point.Chebyshev(point, exitA), Point.Chebyshev(point, exitB));
                    Assert.Equal(expected, exitField[x, y]);
                }
            }
        }

        [Fact(DisplayName = "D15a. 可視鬼距離場：只有可見鬼為多源；不可見鬼不影響")]
        public void VisibleKillerField_UsesOnlyVisibleKillers()
        {
            // Arrange：生存者在中心 (2,2)，一隻可見鬼在 (4,2)（距離=2 可見），一隻不可見鬼在 (2,5)（距離=3 > 視野2）
            var config = new GameConfig
            {
                Width = five, Height = five,
                SurvivorCount = 0, KillerCount = 0,
                SurvivorSight = 2, // 5x5 視野
                KillerSight = 3,
                Seed = 2
            };

            var survivorPos = new Point(2, 2);
            var visibleKillerPos = new Point(4, 2);   // Chebyshev=2 ⇒ 可見
            var invisibleKillerPos = new Point(2, 5); // Chebyshev=3 ⇒ 不可見
            var exitPoint = new Point(0, 0);

            var gameState = TestBoardBuilder.BuildFixed(
                config,
                exits: new[] { exitPoint },
                survivors: new[] { survivorPos },
                killers: new[] { visibleKillerPos, invisibleKillerPos });

            var survivor = gameState.Survivors.Single();

            // Act
            var killerField = DistanceFieldBuilder.BuildVisibleKillerField(gameState, survivor);

            // Assert：場應只等於「對可見鬼」的 Chebyshev 距離（此例只有一隻可見鬼）
            for (int x = 0; x < config.Width; x++)
            {
                for (int y = 0; y < config.Height; y++)
                {
                    var point = new Point(x, y);
                    var expected = Point.Chebyshev(point, visibleKillerPos);
                    Assert.Equal(expected, killerField[x, y]);
                }
            }
        }

        [Fact(DisplayName = "D15b. 可視鬼距離場：多隻可見鬼時，取最小距離（多源）")]
        public void VisibleKillerField_TakesMinimumOverMultipleVisibleKillers()
        {
            // Arrange：生存者在中心 (2,2)，兩隻可見鬼在 (4,2) 與 (0,2)（皆距離=2）
            var config = new GameConfig
            {
                Width = five, Height = five,
                SurvivorCount = 0, KillerCount = 0,
                SurvivorSight = 2,
                KillerSight = 3,
                Seed = 3
            };

            var survivorPos = new Point(2, 2);
            var visibleKillerA = new Point(4, 2);
            var visibleKillerB = new Point(0, 2);
            var exitPoint = new Point(4, 4);

            var gameState = TestBoardBuilder.BuildFixed(
                config,
                exits: new[] { exitPoint },
                survivors: new[] { survivorPos },
                killers: new[] { visibleKillerA, visibleKillerB });

            var survivor = gameState.Survivors.Single();

            // Act
            var killerField = DistanceFieldBuilder.BuildVisibleKillerField(gameState, survivor);

            // Assert：每格 = min(距離到 A, 距離到 B)
            for (int x = 0; x < config.Width; x++)
            {
                for (int y = 0; y < config.Height; y++)
                {
                    var point = new Point(x, y);
                    var expected = Math.Min(Point.Chebyshev(point, visibleKillerA), Point.Chebyshev(point, visibleKillerB));
                    Assert.Equal(expected, killerField[x, y]);
                }
            }
        }

        // 小工具：避免魔數
        private const int five = 5;
    }
}
```

---

### 說明

* **D14**：以 5×5 小地圖、兩個對角出口 `(0,0)` 與 `(4,4)` 測試 `BuildExitField`。斷言每一格皆等於 `min(Chebyshev(·,A), Chebyshev(·,B))`，驗證**多源 BFS**與 **Chebyshev 度量**都正確。
* **D15a**：放一隻「可見鬼」與一隻「不可見鬼」，檢查 `BuildVisibleKillerField` 只把「可見者」當作 BFS 起點；因此整張場應等於「到可見鬼的 Chebyshev 距離」。
* **D15b**：放兩隻「都可見」的鬼，驗證距離場等於對兩者距離的**最小值**（多源行為）。

全部測試都遵循你的程式風格習慣（所有迴圈有 `{ }`），並且可直接 `dotnet test` 執行。

---

要不要我接著把 **E. 生存者策略（Scoring & Moves, 16–20）** 也補上？我可以先從「出口相鄰必選、近身強懲避免自殺、一部預測避貼臉」這三個最關鍵案例寫起。

Question : 
D15a. 測試不通過
我們現在地圖縮限在 5 x 5 ，如果用 0 開始算初始點的話我們的 invisibleKillerPos 設定值目前會超出範圍 => 會在我們的 GameState 內 InBounds 判斷式出現 outofrange 

Answer : 
好抓！問題在於 5×5 地圖用 0-based 座標時，生存者放在正中 (2,2) 會讓整張圖到它的 Chebyshev 距離最多只有 2，所以想放一個「不可見（距離≥3）」的鬼就一定越界。解法：把生存者改到 (1,1)，這樣 (4,4) 的距離就是 3（在界內且確實不可見）。

下面是修正後的 **D15a** 測試（其餘不變）。我也維持你要求的風格：所有迴圈都有 `{ }`。

```csharp
[Fact(DisplayName = "D15a. 可視鬼距離場：只有可見鬼為多源；不可見鬼不影響")]
public void VisibleKillerField_UsesOnlyVisibleKillers()
{
    // Arrange：生存者在 (1,1)
    // 可見鬼在 (3,1) => Chebyshev=2（可見）
    // 不可見鬼在 (4,4) => Chebyshev=3（不可見，且在 5x5 界內）
    var config = new GameConfig
    {
        Width = five, Height = five,
        SurvivorCount = 0, KillerCount = 0,
        SurvivorSight = 2, // 5x5 視野
        KillerSight = 3,
        Seed = 2
    };

    var survivorPos = new Point(1, 1);
    var visibleKillerPos = new Point(3, 1);    // 可見
    var invisibleKillerPos = new Point(4, 4);  // 不可見
    var exitPoint = new Point(0, 0);

    var gameState = TestBoardBuilder.BuildFixed(
        config,
        exits: new[] { exitPoint },
        survivors: new[] { survivorPos },
        killers: new[] { visibleKillerPos, invisibleKillerPos });

    var survivor = gameState.Survivors.Single();

    // Act
    var killerField = DistanceFieldBuilder.BuildVisibleKillerField(gameState, survivor);

    // Assert：距離場應等於「到可見鬼」的 Chebyshev 距離（不可見鬼不影響）
    for (int x = 0; x < config.Width; x++)
    {
        for (int y = 0; y < config.Height; y++)
        {
            var point = new Point(x, y);
            var expected = Point.Chebyshev(point, visibleKillerPos);
            Assert.Equal(expected, killerField[x, y]);
        }
    }
}

// 小工具：避免魔數
private const int five = 5;
```

這樣就能在 5×5 的範圍內，同時滿足「一隻可見、另一隻不可見」的條件而不越界。跑 `dotnet test` 應該就會通過了。需要我把整個 `D_FieldBfsTests.cs` 幫你一併更新好嗎？

Question : 不需要，我們繼續進行下一步 E 
Answer : 

太好，我把 **E. 生存者策略（Scoring & Moves, 16–20）** 的 xUnit 測試寫好了。
重點都遵守你的程式風格：**所有迴圈（for/foreach/while）即使只有一行也一律使用 `{ }`**，並維持清楚的變數命名。

把下面單一檔案加入 `TagPOC.Tests` 專案即可執行（依賴我們之前的 `TestBoardBuilder.cs` 與主專案的政策/場生成程式）。

---

## `E_SurvivorPolicyTests.cs`

```csharp
using System;
using System.Linq;
using TagPOC;
using Xunit;

namespace TagPOC.Tests
{
    /// <summary>
    /// E. 生存者策略（Scoring & Moves, 16–20）
    /// 16) 出口相鄰即選出口
    /// 17) 近身強懲避免自殺靠近（D_killer ≤ 2 的候選格不被選）
    /// 18) 一步預測避免貼臉（可見鬼下一步可能貼臉的格會被避開）
    /// 19) 未知區微懲罰：沒有可視鬼的 5x5 區會被小幅扣分
    /// 20) Last-seen 陰影懲罰：候選格落在 last-seen 擴散半徑內會被避開
    /// </summary>
    public class E_SurvivorPolicyTests
    {
        [Fact(DisplayName = "E16. 出口相鄰 ⇒ SurvivorPolicy 應優先選出口格")]
        public void AdjacentToExit_PicksExitImmediately()
        {
            // Arrange：生存者在 (3,3)，出口在 (4,4)，鬼遠離不影響
            var config = new GameConfig
            {
                Width = nine, Height = nine,
                SurvivorCount = 0, KillerCount = 0,
                SurvivorSight = 2, KillerSight = 3,
                Seed = 10
            };

            var exitPoint = new Point(4, 4);
            var survivorPos = new Point(3, 3);
            var killerPos = new Point(0, 0); // 遠處，不影響決策
            var gameState = TestBoardBuilder.BuildFixed(
                config,
                exits: new[] { exitPoint },
                survivors: new[] { survivorPos },
                killers: new[] { killerPos }
            );

            var survivor = gameState.Survivors.Single();
            var exitField = DistanceFieldBuilder.BuildExitField(gameState);

            // Act
            var next = SurvivorPolicy.DecideNext(gameState, survivor, exitField);

            // Assert：直接選出口
            Assert.Equal(exitPoint, next);
        }

        [Fact(DisplayName = "E17. 近身強懲：不會主動選擇 D_killer ≤ 2 的危險候選格（非出口）")]
        public void StrongClosePenalty_AvoidsDangerousCell()
        {
            // Arrange：生存者 (5,5)，可見鬼 (7,5) → 若往 (6,5) 則 D_killer=1（危險）
            var config = new GameConfig
            {
                Width = eleven, Height = eleven,
                SurvivorCount = 0, KillerCount = 0,
                SurvivorSight = 2, KillerSight = 3,
                Seed = 11
            };

            var exitPoint = new Point(10, 10);       // 遠方出口
            var survivorPos = new Point(5, 5);
            var killerPos = new Point(7, 5);         // 可見，距離=2
            var dangerousCandidate = new Point(6, 5); // 往這步會與鬼 Chebyshev=1

            var gameState = TestBoardBuilder.BuildFixed(
                config,
                exits: new[] { exitPoint },
                survivors: new[] { survivorPos },
                killers: new[] { killerPos }
            );

            var survivor = gameState.Survivors.Single();
            var exitField = DistanceFieldBuilder.BuildExitField(gameState);

            // Act
            var next = SurvivorPolicy.DecideNext(gameState, survivor, exitField);

            // Assert：不應選擇危險格（非出口）
            Assert.NotEqual(dangerousCandidate, next);
        }

        [Fact(DisplayName = "E18. 一步預測：會避開鬼下一步可能貼臉的位置")]
        public void OneStepLookahead_AvoidsPotentialAdjacentNextTurn()
        {
            // Arrange：生存者 (5,3)，可見鬼 (3,3)；若生存者走到 (4,3)，鬼下一步可到 (4,3) 貼臉
            var config = new GameConfig
            {
                Width = nine, Height = nine,
                SurvivorCount = 0, KillerCount = 0,
                SurvivorSight = 2, KillerSight = 3,
                Seed = 12
            };

            var exitPoint = new Point(8, 8);        // 出口在遠方，不直接干擾該案例
            var survivorPos = new Point(5, 3);
            var killerPos   = new Point(3, 3);      // 可見（距離=2）
            var riskyStep   = new Point(4, 3);      // 介於兩者之間

            var gameState = TestBoardBuilder.BuildFixed(
                config,
                exits: new[] { exitPoint },
                survivors: new[] { survivorPos },
                killers: new[] { killerPos }
            );

            var survivor = gameState.Survivors.Single();
            var exitField = DistanceFieldBuilder.BuildExitField(gameState);

            // Act
            var next = SurvivorPolicy.DecideNext(gameState, survivor, exitField);

            // Assert：不應選擇 riskyStep（鬼下一步可能貼臉的位置）
            Assert.NotEqual(riskyStep, next);
        }

        [Fact(DisplayName = "E19. 未知區微懲罰：沒有可視鬼的 5x5 區域的候選格會被小幅扣分")]
        public void UnknownAreaPenalty_ShiftsChoiceTowardInformativeArea()
        {
            // Arrange：目標是讓兩個候選步在 D_exit 與 D_killer 上幾乎等價，
            // 但其中一個候選步的 5x5 區域「存在鬼」而另一個完全沒有，從而區分 unknown penalty。
            var config = new GameConfig
            {
                Width = nine, Height = nine,
                SurvivorCount = 0, KillerCount = 0,
                SurvivorSight = 2, KillerSight = 3,
                Seed = 13
            };

            var exitPoint   = new Point(8, 8);
            var survivorPos = new Point(4, 4);      // 中央
            var killerNearCandidateA = new Point(2, 4); // 讓候選 A 的 5x5 視窗內含鬼
            // 注意：從 survivor 當前位置看，這隻鬼距離=2（可見），但我們的目標是比較兩個候選的 unknown 懲罰差異，
            // AnyVisibleInWindow 是以「候選格」為中心掃 <=SurvivorSight 的鬼，因此只要相對候選 A 視窗內有鬼即可。

            var gameState = TestBoardBuilder.BuildFixed(
                config,
                exits: new[] { exitPoint },
                survivors: new[] { survivorPos },
                killers: new[] { killerNearCandidateA }
            );

            var survivor = gameState.Survivors.Single();
            var exitField = DistanceFieldBuilder.BuildExitField(gameState);

            // 讓兩個候選：A=(3,4)（靠近鬼視窗），B=(5,4)（遠離鬼視窗），在 D_exit/D_killer 近似對稱
            var candidateA = new Point(3, 4);
            var candidateB = new Point(5, 4);

            // 為了讓 SurvivorPolicy 用我們期望的候選做比較，我們暫不直接操控內部 score，
            // 而是檢查實際決策是否偏向「資訊較多」（不受 unknown penalty）的方向（candidateA）。
            var next = SurvivorPolicy.DecideNext(gameState, survivor, exitField);

            // Assert：傾向選擇包含鬼的 5x5 視窗那一側（避免 unknown penalty 的扣分）
            // 如果剛好出口距離造成另一方向更佳，也可能不是 A；此測試在上述幾何下通常會選 A。
            Assert.NotEqual(candidateB, next);
        }

        [Fact(DisplayName = "E20. Last-seen 陰影：候選格在陰影半徑內時會被避開")]
        public void LastSeenShadow_DiscouragesStepsInsideShadowRadius()
        {
            // Arrange：目前看不到鬼，但 survivor 曾經在 (6,4) 看過鬼；陰影半徑=3，
            // 讓候選 Inside=(5,4) 落在陰影內，Outside=(3,4) 落在陰影外。
            var config = new GameConfig
            {
                Width = nine, Height = nine,
                SurvivorCount = 0, KillerCount = 0,
                SurvivorSight = 2, KillerSight = 3,
                LastSeenShadowCap = 5,
                Seed = 14
            };

            var exitPoint   = new Point(8, 8);
            var survivorPos = new Point(4, 4);

            var gameState = TestBoardBuilder.BuildFixed(
                config,
                exits: new[] { exitPoint },
                survivors: new[] { survivorPos },
                killers:   Array.Empty<Point>() // 目前看不到鬼
            );

            var survivor = gameState.Survivors.Single();

            // 模擬「曾經看見過鬼」：last-seen 在 (6,4)，現在回合=10，lastSeenRound=8 => R = min(2, cap)=2
            gameState.Round = 10;
            survivor.LastSeenKillerPos = new Point(6, 4);
            survivor.LastSeenKillerRound = 8;

            var exitField = DistanceFieldBuilder.BuildExitField(gameState);

            var insideShadowCandidate  = new Point(5, 4); // 距 (6,4) = 1 ⇒ 在陰影內
            var outsideShadowCandidate = new Point(3, 4); // 距 (6,4) = 3 ⇒ 陰影外（R=2）

            // Act
            var next = SurvivorPolicy.DecideNext(gameState, survivor, exitField);

            // Assert：應該避開陰影內的候選
            Assert.NotEqual(insideShadowCandidate, next);
        }

        private const int nine = 9;
        private const int eleven = 11;
    }
}
```

---

### 小補充

* **E19 的幾何設計**讓「unknown 區域懲罰」在兩個對稱候選間產生差異：
  Candidate A 的 5×5 視窗內有一隻鬼（因此 **沒有 unknown penalty**）；Candidate B 的 5×5 視窗完全沒有鬼（因此 **會被扣 `UnknownAreaPenalty`**）。
  在其他項目近似對稱時，決策會偏向 Candidate A。

* 以上案例都只依賴現有的政策實作，不需要改主程式；如果你之後微調 `score` 權重，E19/E20 的「方向性」仍應成立（避免未知、避開陰影）。

---

需要我繼續補 **F. 鬼策略（21–24）** 嗎？我可以用同樣風格與輔助工具，檢驗「視野內選最近」、「timeout 後巡邏出口」、「spacing penalty 促進分散」等關鍵行為。

Question : 
有兩個地方需要修正並確認是否正確

1、UnknownAreaPenalty_ShiftsChoiceTowardInformativeArea

candidateA 這個變數沒有使用到，因為我們的驗證是要驗證不會選擇 candidateB 因為是最靠近 killer 的選項，但同時我們的演算法還是有可能會選擇不是我們預想的 candidateA  ，以至於我們無法直接驗證會等於 candidateA  ，是否要考慮其他的驗證情境? 或是其實 candidateA  並不會用到我們就直接移除?

2、LastSeenShadow_DiscouragesStepsInsideShadowRadius
outsideShadowCandidate 這個變數也沒有使用到，同 1 因為我們無法確定 next 真的會選擇 outsideShadowCandidate 是否要考慮其他驗證情境或是移除?

Answer : 
超細心的抓！這兩個測試我幫你改成「明確由該懲罰項決定勝負」的幾何情境，避免出現未使用變數，也讓斷言更強而不是只用 NotEqual。

以下是更新後的兩個測試方法（其餘 E16、E17、E18 保持不變）。直接把它們覆蓋到你的 `E_SurvivorPolicyTests.cs` 即可。

---

### 1) E19：UnknownAreaPenalty\_ShiftsChoiceTowardInformativeArea

**思路**：讓 `D_exit` 和 `D_killer` 在兩個候選格上**完全對稱**，只有「未知區微懲罰」有差異。
作法：生存者在 (4,4)、出口在 (4,8)——對左右候選 `(3,4)` 與 `(5,4)` 到出口距離相同；沒有可見鬼（`D_killer` 對兩格相同且極大值）。
但在候選 A `(3,4)` 周圍 5×5 內放一隻「對生存者不可見」的鬼 `(1,4)`（距離=3），使 **candidateA 無 unknown penalty、candidateB 有 unknown penalty**，因此應選 A。

```csharp
[Fact(DisplayName = "E19. 未知區微懲罰：偏向含已知威脅資訊的一側（避免 unknown penalty）")]
public void UnknownAreaPenalty_ShiftsChoiceTowardInformativeArea()
{
    // 幾何：S=(4,4)，Exit=(4,8)（左右對稱）；Invisible Killer 放在 (1,4)：
    // - 對 S 的距離 = 3（不可見），因此 D_killer 在兩候選處相同（極大）。
    // - 對 candidateA=(3,4) 的距離 = 2（在其 5×5 視窗內），因此 A 無 unknown penalty；
    //   candidateB=(5,4) 的距離 = 4（視窗外），因此 B 會吃 unknown penalty。
    var config = new GameConfig
    {
        Width = nine, Height = nine,
        SurvivorCount = 0, KillerCount = 0,
        SurvivorSight = 2, KillerSight = 3,
        // 讓 unknown penalty 影響更明顯（其實預設也夠，這裡強化可避免未來參數微調造成測試脆弱）
        UnknownAreaPenalty = 0.5,
        Omega_Margin = 0.0,   // 移除 margin 影響，純看 unknown penalty
        Seed = 19
    };

    var exitPoint   = new Point(4, 8);
    var survivorPos = new Point(4, 4);
    var invisibleKiller = new Point(1, 4); // 對 S 距離=3（不可見）

    var gameState = TestBoardBuilder.BuildFixed(
        config,
        exits: new[] { exitPoint },
        survivors: new[] { survivorPos },
        killers:   new[] { invisibleKiller } // 對 survivor 不可見，但會落在 candidateA 的 5x5 視窗
    );

    var survivor   = gameState.Survivors.Single();
    var exitField  = DistanceFieldBuilder.BuildExitField(gameState);

    var candidateA = new Point(3, 4); // 左
    var candidateB = new Point(5, 4); // 右（會吃 unknown penalty）

    var next = SurvivorPolicy.DecideNext(gameState, survivor, exitField);

    // 唯一差異來自 unknown penalty：應選資訊較多的 candidateA
    Assert.Equal(candidateA, next);
}
```

---

### 2) E20：LastSeenShadow\_DiscouragesStepsInsideShadowRadius

**思路**：同樣讓 `D_exit` 與 `D_killer` 在候選上對稱，唯一差異是 **last-seen 陰影懲罰**。
作法：生存者在 (4,4)、出口在 (4,8)（左右對稱）、目前沒有任何鬼。
設定 last-seen 在 (6,4)，R=2，使 `(5,4)` 在陰影內、`(3,4)` 在陰影外 ⇒ 應選 `(3,4)`。

```csharp
[Fact(DisplayName = "E20. Last-seen 陰影：避開陰影內候選、偏向陰影外候選")]
public void LastSeenShadow_DiscouragesStepsInsideShadowRadius()
{
    var config = new GameConfig
    {
        Width = nine, Height = nine,
        SurvivorCount = 0, KillerCount = 0,
        SurvivorSight = 2, KillerSight = 3,
        LastSeenShadowCap = 5,
        Omega_Margin = 0.0, // 移除 margin 影響，讓陰影成為唯一差異
        Seed = 20
    };

    var exitPoint   = new Point(4, 8); // 對左右候選對稱
    var survivorPos = new Point(4, 4);

    var gameState = TestBoardBuilder.BuildFixed(
        config,
        exits: new[] { exitPoint },
        survivors: new[] { survivorPos },
        killers:   Array.Empty<Point>() // 目前看不到鬼
    );

    var survivor = gameState.Survivors.Single();

    // 設定 last-seen：位置 (6,4)，R = min( gameState.RoundDiff, cap ) = 2（見下兩行）
    gameState.Round = 10;
    survivor.LastSeenKillerPos = new Point(6, 4);
    survivor.LastSeenKillerRound = 8; // 10-8=2 ⇒ R=2

    var exitField = DistanceFieldBuilder.BuildExitField(gameState);

    var outsideShadowCandidate = new Point(3, 4); // 距 (6,4) = 3 > R=2 ⇒ 陰影外
    var insideShadowCandidate  = new Point(5, 4); // 距 (6,4) = 1 ≤ R=2 ⇒ 陰影內

    var next = SurvivorPolicy.DecideNext(gameState, survivor, exitField);

    // 因為唯一差異來自陰影懲罰，應選陰影外的候選
    Assert.Equal(outsideShadowCandidate, next);
}
```

---

### 為什麼這樣更穩？

* 兩個測試都把非目標因素（`D_exit`、`D_killer`、`margin`、`flow` 等）**對稱化或關閉**，保證僅有目標懲罰項（unknown / last-seen）在起作用。
* 因此我們可以用 **Equal** 來斷言結果，避免只用 **NotEqual** 帶來的不確定性。
* 也順勢讓之前「未使用變數」都被妥善使用（`candidateA` 與 `outsideShadowCandidate`）。

如果你 OK，我可以把 **F. 鬼策略（21–24）** 也用同樣方式設計成「單一因素決定勝負」的穩健測試。


Question : 
有幾個問題點想更正

1、 UnknownAreaPenalty_ShiftsChoiceTowardInformativeArea
我們這樣的設置 candidateA 是否應該是 3,5 ? 
另外就是我們也需要驗證不等於 candidateB 所以應該要補上
Assert.NotEqual(candidateB, next);

2、LastSeenShadow_DiscouragesStepsInsideShadowRadius
同樣的 outsideShadowCandidate 是否應該是 3,5 ?
另外也是需要驗證不等於 insideShadowCandidate 需要補上 Assert.NotEqual(insideShadowCandidate, next);


Answer : 
好眼力！兩個點我都調整好了，並補上更嚴謹的斷言。關鍵改動：

* 把對稱候選改成 **斜對稱** `(3,5)` 與 `(5,5)`：這樣到出口 `(4,8)` 的 Chebyshev 距離都為 3，且更容易控制 5×5 視窗的差異（unknown / 陰影）。
* 補上你提到的 **NotEqual** 斷言，確保不會選到不該選的那一側。

把下面兩個測試方法覆蓋到你的 `E_SurvivorPolicyTests.cs` 即可（其他測試不變）。

---

### E19（UnknownAreaPenalty）修正版

```csharp
[Fact(DisplayName = "E19. 未知區微懲罰：偏向含已知威脅資訊的一側（避免 unknown penalty）")]
public void UnknownAreaPenalty_ShiftsChoiceTowardInformativeArea()
{
    // 幾何：Survivor=(4,4)，Exit=(4,8)；Invisible Killer=(1,4)。
    // 候選：A=(3,5)、B=(5,5)：
    // - 兩者到 Exit 的 Chebyshev 距離皆為 3（對稱）。
    // - 對 Survivor 而言，Killer 距離=3 ⇒ 看不到（D_killer 對兩者等價且極大）。
    // - 以候選格為中心的 5x5 來看：
    //   * A=(3,5) 到 Killer=(1,4) 距離 max(|3-1|,|5-4|)=2 ⇒ 5x5 視窗內「有鬼」→ 無 unknown penalty
    //   * B=(5,5) 到 Killer=(1,4) 距離 max(4,1)=4 ⇒ 視窗外 → 會吃 unknown penalty
    var config = new GameConfig
    {
        Width = 9, Height = 9,
        SurvivorCount = 0, KillerCount = 0,
        SurvivorSight = 2, KillerSight = 3,
        UnknownAreaPenalty = 0.5,
        Omega_Margin = 0.0,
        Seed = 19
    };

    var exitPoint     = new Point(4, 8);
    var survivorPos   = new Point(4, 4);
    var invisibleKiller = new Point(1, 4);

    var gameState = TestBoardBuilder.BuildFixed(
        config,
        exits:     new[] { exitPoint },
        survivors: new[] { survivorPos },
        killers:   new[] { invisibleKiller }
    );

    var survivor  = gameState.Survivors.Single();
    var exitField = DistanceFieldBuilder.BuildExitField(gameState);

    var candidateA = new Point(3, 5); // 應被選
    var candidateB = new Point(5, 5); // 應被排除（unknown penalty）

    var next = SurvivorPolicy.DecideNext(gameState, survivor, exitField);

    Assert.Equal(candidateA, next);
    Assert.NotEqual(candidateB, next);
}
```

---

### E20（Last-seen Shadow）修正版

```csharp
[Fact(DisplayName = "E20. Last-seen 陰影：避開陰影內候選、偏向陰影外候選")]
public void LastSeenShadow_DiscouragesStepsInsideShadowRadius()
{
    // 幾何：Survivor=(4,4)，Exit=(4,8)；此刻地圖上沒有可見鬼。
    // 設定 last-seen 在 (6,4)，Round=10、LastSeenRound=8 ⇒ 陰影半徑 R=2。
    // 候選：Outside=(3,5)、Inside=(5,5)
    // - 到 Exit 距離皆為 3（對稱）
    // - 到 last-seen=(6,4)：Outside 距離= max(3,1)=3 > R ⇒ 陰影外；Inside 距離= max(1,1)=1 ≤ R ⇒ 陰影內
    var config = new GameConfig
    {
        Width = 9, Height = 9,
        SurvivorCount = 0, KillerCount = 0,
        SurvivorSight = 2, KillerSight = 3,
        LastSeenShadowCap = 5,
        Omega_Margin = 0.0,
        Seed = 20
    };

    var exitPoint   = new Point(4, 8);
    var survivorPos = new Point(4, 4);

    var gameState = TestBoardBuilder.BuildFixed(
        config,
        exits:     new[] { exitPoint },
        survivors: new[] { survivorPos },
        killers:   Array.Empty<Point>()
    );

    var survivor = gameState.Survivors.Single();

    gameState.Round = 10;
    survivor.LastSeenKillerPos   = new Point(6, 4);
    survivor.LastSeenKillerRound = 8; // → R = 2

    var exitField = DistanceFieldBuilder.BuildExitField(gameState);

    var outsideShadowCandidate = new Point(3, 5); // 應被選
    var insideShadowCandidate  = new Point(5, 5); // 應被排除

    var next = SurvivorPolicy.DecideNext(gameState, survivor, exitField);

    Assert.Equal(outsideShadowCandidate, next);
    Assert.NotEqual(insideShadowCandidate, next);
}
```

---

如果還想再強化穩健度，我可以把這兩個案例的 `Alpha_Exit/Beta_Safety/Gamma/Omega` 參數在測試前暫時「鎖定」為最小影響組合（我們已把 `Omega_Margin=0`，其餘維持預設也能通過），以降低未來你微調權重造成測試脆弱的機率。需要的話我也可以順手加上。


Question : 
可以不用，前面幾個測試案例設置的參數已經足夠驗證以及不會有誤測的情況發生了

繼續下一個 F

Answer : 
好，這一輪我把 **F. 鬼策略（21–24）** 的 xUnit 測試一次補齊，沿用你要求的程式風格（所有 `for/foreach/while` 一律使用 `{ }`），並且維持清楚的變數命名。直接把下面檔案加入 `TagPOC.Tests` 專案即可執行（依賴先前的 `TestBoardBuilder.cs` 與主專案的 `KillerPolicy`、`Vision` 等）。

---

## `F_KillerPolicyTests.cs`

```csharp
using System;
using System.Linq;
using TagPOC;
using Xunit;

namespace TagPOC.Tests
{
    /// <summary>
    /// F. 鬼策略（21–24）
    /// 21) 視野內選最近生存者
    /// 22) 視野外時使用 last-seen 位置追擊
    /// 23) 超過 timeout 後改巡邏出口（朝最近出口前進）
    /// 24) spacing penalty 促使選擇不緊鄰其他鬼的候選步（在等距縮短目標時）
    /// </summary>
    public class F_KillerPolicyTests
    {
        [Fact(DisplayName = "F21. 視野內有多名生存者時，鎖定最近者並朝其方向縮短距離")]
        public void VisibleTargets_SelectsNearestSurvivor()
        {
            // 幾何：Killer=(4,4)，兩名生存者在可見範圍內：
            // Snear=(6,4) 距離=2；Sfar=(8,8) 距離=4。預期鬼的下一步會縮短到 Snear 的距離。
            var config = new GameConfig
            {
                Width = 15, Height = 15,
                SurvivorCount = 0, KillerCount = 0,
                SurvivorSight = 2, KillerSight = 3, // 7x7 視野
                Seed = 210
            };

            var exitPoint   = new Point(0, 0);  // 無關
            var killerStart = new Point(4, 4);
            var sNear       = new Point(6, 4);  // dist=2
            var sFar        = new Point(8, 8);  // dist=4

            var gameState = TestBoardBuilder.BuildFixed(
                config,
                exits:     new[] { exitPoint },
                survivors: new[] { sNear, sFar },
                killers:   new[] { killerStart }
            );

            var killer    = gameState.Killers.Single();
            var exitField = DistanceFieldBuilder.BuildExitField(gameState);

            var prevDistToNear = Point.Chebyshev(killer.Pos, sNear);
            var prevDistToFar  = Point.Chebyshev(killer.Pos, sFar);

            var next = KillerPolicy.DecideNext(gameState, killer, exitField);

            var newDistToNear = Point.Chebyshev(next, sNear);
            var newDistToFar  = Point.Chebyshev(next, sFar);

            // 斷言：對最近者距離必須縮短 1；不會為了遠者而放棄縮短最近者
            Assert.Equal(prevDistToNear - 1, newDistToNear);
            Assert.True(newDistToFar >= prevDistToFar - 1);
        }

        [Fact(DisplayName = "F22. 看不見時，使用 last-seen 位置作為追擊目標")]
        public void UsesLastSeenPosition_WhenSurvivorOutOfSight()
        {
            // 幾何：Killer=(4,4)，先在 Round t 看見生存者 at (6,4)；
            // 下一回合生存者移至視野外，但在 timeout 內 ⇒ 應朝 last-seen (6,4) 前進（x 增加）。
            var config = new GameConfig
            {
                Width = 15, Height = 15,
                SurvivorCount = 0, KillerCount = 0,
                SurvivorSight = 2, KillerSight = 3,
                LastSeenTimeout = 5,
                Seed = 220
            };

            var exitPoint        = new Point(0, 0);
            var killerStart      = new Point(4, 4);
            var survivorSeen     = new Point(6, 4);  // 可見
            var survivorOutOfFov = new Point(12, 12); // 與 killer 距離 > 3，移至視野外

            var gameState = TestBoardBuilder.BuildFixed(
                config,
                exits:     new[] { exitPoint },
                survivors: new[] { survivorSeen },
                killers:   new[] { killerStart }
            );

            var killer    = gameState.Killers.Single();
            var survivor  = gameState.Survivors.Single();
            var exitField = DistanceFieldBuilder.BuildExitField(gameState);

            // 第一次決策（看見）
            var first = KillerPolicy.DecideNext(gameState, killer, exitField);
            Assert.True(first.X >= killer.Pos.X, "When target is at (6,4), the first step should not move left.");

            // 套用一步並更新 last-seen（視為 Round t）
            killer.Pos = first;
            killer.LastSeenSurvivorPos = survivorSeen;
            killer.LastSeenSurvivorRound = gameState.Round;

            // 生存者移到視野外，回合+1（仍在 timeout 內）
            gameState.Round += 1;
            survivor.Pos = survivorOutOfFov;

            var second = KillerPolicy.DecideNext(gameState, killer, exitField);
            // 仍應朝 last-seen (6,4) 前進（東向或東北/東南）
            Assert.True(second.X >= killer.Pos.X, "Should keep moving toward last-seen (increase X toward 6).");
        }

        [Fact(DisplayName = "F23. 超過 last-seen timeout 後，改朝最近出口前進")]
        public void PatrolsExit_AfterLastSeenTimeout()
        {
            // 幾何：Killer=(4,4)，最近出口在 (10,4)（東方）。超過 timeout 後應朝出口方向移動（x 增加）。
            var config = new GameConfig
            {
                Width = 15, Height = 15,
                SurvivorCount = 0, KillerCount = 0,
                SurvivorSight = 2, KillerSight = 3,
                LastSeenTimeout = 2,
                Seed = 230
            };

            var exitPoint   = new Point(10, 4);
            var killerStart = new Point(4, 4);

            var gameState = TestBoardBuilder.BuildFixed(
                config,
                exits:     new[] { exitPoint },
                survivors: Array.Empty<Point>(),
                killers:   new[] { killerStart }
            );

            var killer    = gameState.Killers.Single();
            var exitField = DistanceFieldBuilder.BuildExitField(gameState);

            // 模擬：曾看過生存者，但已經超時
            killer.LastSeenSurvivorPos = new Point(6, 6);
            killer.LastSeenSurvivorRound = 1;
            gameState.Round = killer.LastSeenSurvivorRound + config.LastSeenTimeout + 1;

            var step = KillerPolicy.DecideNext(gameState, killer, exitField);

            // 應朝最近出口 (10,4) 前進：x 不應減少，且到出口距離應縮小
            Assert.True(step.X >= killer.Pos.X, "Should move east toward the nearest exit.");
            var prev = Point.Chebyshev(killer.Pos, exitPoint);
            var now  = Point.Chebyshev(step, exitPoint);
            Assert.Equal(prev - 1, now);
        }

        [Fact(DisplayName = "F24. Spacing penalty：等距縮短目標時，偏好不緊鄰其他鬼的候選步")]
        public void SpacingPenalty_PrefersNonAdjacentCandidate_WhenDistanceGainIsEqual()
        {
            // 幾何：
            // - 目標生存者 T=(5,3)
            // - Killer A at (2,2) 有兩個「等價縮短」候選：
            //     A1=(3,2) 與 A2=(3,3) 到 T 距離同為 2（皆從 3 縮到 2）
            // - 另一隻 Killer B at (2,4)
            //   * A1=(3,2) 與 B 距離 = max(|3-2|,|2-4|)=2（不觸發 spacing penalty）
            //   * A2=(3,3) 與 B 距離 = max(1,1)=1（觸發 spacing penalty）
            // 預期：Killer A 應選 A1=(3,2) 而不是 A2=(3,3)。
            var config = new GameConfig
            {
                Width = 9, Height = 9,
                SurvivorCount = 0, KillerCount = 0,
                SurvivorSight = 2, KillerSight = 3,
                KillerSpacingPenalty = 1.0, // 放大影響，確保傾向明顯
                KillerInterceptBonus = 0.0, // 關掉額外干擾
                Seed = 240
            };

            var exitPoint = new Point(0, 0); // 無關
            var target    = new Point(5, 3);
            var killerA   = new Point(2, 2);
            var killerB   = new Point(2, 4);

            var gameState = TestBoardBuilder.BuildFixed(
                config,
                exits:     new[] { exitPoint },
                survivors: new[] { target },
                killers:   new[] { killerA, killerB }
            );

            var killerARef = gameState.Killers.First(k => k.Id == 0);
            var exitField  = DistanceFieldBuilder.BuildExitField(gameState);

            var next = KillerPolicy.DecideNext(gameState, killerARef, exitField);

            Assert.Equal(new Point(3, 2), next);   // 偏好不緊鄰 B 的候選
            Assert.NotEqual(new Point(3, 3), next); // 避免緊鄰 B 的候選
        }
    }
}
```

---

### 設計重點說明

* **F21**：兩名可見生存者、距離不同。檢查下一步對最近者距離必然縮短 1（Chebyshev）。
* **F22**：先「看見」一次，記錄 last-seen；之後把生存者移出視野但仍在 timeout 內，檢查下一步仍朝 last-seen 的方向。
* **F23**：超過 `LastSeenTimeout` 後，檢查下一步會朝最近出口縮短距離。
* **F24**：構造「兩個等距縮短目標」的候選，只有一個會觸發 spacing penalty，驗證 `KillerPolicy` 會選擇不緊鄰同伴的那個。

如果這些測試跑起來都 OK，我可以繼續補 **G. 衝突解算（25–28）**；或你想先回頭把某些主程式策略（例如鬼的攔截得分）再做一點可測性的重構，我也可以配合調整測試。


Question : 
有一個問題在 SpacingPenalty_PrefersNonAdjacentCandidate_WhenDistanceGainIsEqual 驗測不通過 ，next 結果是 3,1 ，這邊有個疑惑確實應該要選擇比較靠近逃脫者，又不跟 killerb 緊鄰的候選，為甚麼會是這樣?

Answer : 
好問題！這個失敗是**情境設計** + **tie-break 行為**造成的，不是演算法壞掉。

## 為什麼會走到 (3,1)？

在原本的幾何下：

* 目標生存者 `T=(5,3)`
* 鬼 A 起點 `(2,2)`，另一隻鬼 B 在 `(2,4)`
* A 的鄰居中有 **三個**會把到 T 的 Chebyshev 距離從 3 縮到 2：

  * `(3,2)`, `(3,3)`, **`(3,1)`**
* 我們關掉了 `KillerInterceptBonus`，而 `spacing` 對 `(3,2)` 與 `(3,1)` 都**不觸發**（對 B 的距離分別是 2 與 3），所以三者的分數其實**一樣**。
* `KillerPolicy.DecideNext` 在分數相等時會選到**第一個**掃到的候選（鄰居順序是 `(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)`），因此 `(3,1)` 先被看到就被選中。

> 結論：不是 spacing 無效，而是 **第三個同分候選 (3,1)** 讓 tie-break 落在它身上。

---

## 修正測試的方法（建議）

把目標改成 `T=(5,4)`，就能排除 `(3,1)` 這個同分候選，只留下我們想比較的兩個：

* 從 `(2,2)` 到 `(5,4)` 的距離是 3；能縮短到 2 的只有 `(3,2)` 與 `(3,3)`。
* `(3,3)` 會**緊鄰** B `(2,4)`（距離 1）→ 觸發 spacing 懲罰；
  `(3,2)` 與 B 距離 2 → **不觸發**。
* 關掉 `KillerInterceptBonus`，即可保證 spacing 是唯一差異 → 應選 `(3,2)`。

### 更新後的測試（只改這個案例）

```csharp
[Fact(DisplayName = "F24. Spacing penalty：等距縮短目標時，偏好不緊鄰其他鬼的候選步")]
public void SpacingPenalty_PrefersNonAdjacentCandidate_WhenDistanceGainIsEqual()
{
    var config = new GameConfig
    {
        Width = 9, Height = 9,
        SurvivorCount = 0, KillerCount = 0,
        SurvivorSight = 2, KillerSight = 3,
        KillerSpacingPenalty = 1.0, // 放大影響，確保傾向明顯
        KillerInterceptBonus = 0.0, // 關掉額外干擾
        Seed = 240
    };

    var exitPoint = new Point(0, 0); // 無關
    var target    = new Point(5, 4); // ← 改成 5,4，排除 (3,1) 的同分候選
    var killerA   = new Point(2, 2);
    var killerB   = new Point(2, 4);

    var gameState = TestBoardBuilder.BuildFixed(
        config,
        exits:     new[] { exitPoint },
        survivors: new[] { target },
        killers:   new[] { killerA, killerB }
    );

    var killerARef = gameState.Killers.First(k => k.Id == 0);
    var exitField  = DistanceFieldBuilder.BuildExitField(gameState);

    var next = KillerPolicy.DecideNext(gameState, killerARef, exitField);

    Assert.Equal(new Point(3, 2), next);    // 偏好不緊鄰 B 的候選
    Assert.NotEqual(new Point(3, 3), next); // 會觸發 spacing 懲罰的候選
}
```

---

## 其他可選修法（不一定要改）

如果你想保留原幾何（T=5,3），也可以：

* **把 B 放在 (3,1)**：讓 `(3,1)` 直接吃到 spacing 懲罰（甚至同格會被解算擋住）；或
* **在策略中加入明確的 tie-break**（例如分數相等時，優先 `dx>0`、再 `dy`、或依方位排序），讓測試可預期。

但就測試穩健度而言，**調幾何使唯一差異來自 spacing**是最乾淨的做法。

Quesiton  : 

我認為目前這樣的方法比起另外兩個建議比較適合，所以我們可以開始 G 的測試了

Answer : 
太好了～按照你的風格與目前實作狀態，我把 **G. 衝突解算（25–28）** 的測試寫好了。
重點：所有 `for/foreach/while` 都加上 `{ }`、命名清晰、而且我特別處理了 **28：跟隨鏈**——目前你的 `MoveConflictResolver` 並**尚未**實作一般長度 > 2 的循環偵測（只有雙向交換 no-swap），所以我提供：

* 一個 **\[Skip] 的「期望行為」測試**（等之後你實作循環回退時再開啟）；
* 一個 **「目前行為」的保護測試**，避免未來不小心改壞。

把下面檔案加到 `TagPOC.Tests` 專案即可執行。

---

## `G_ConflictResolverTests.cs`

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using TagPOC;
using Xunit;

namespace TagPOC.Tests
{
    /// <summary>
    /// G. 衝突解算（25–28）
    /// 25) 同格競爭：高分者得
    /// 26) 同分 tie-break by Id
    /// 27) 禁止對向交換（swap）
    /// 28) 跟隨鏈（目前程式尚未支援一般循環；附上 Skip 的期望測試 + 目前行為測試）
    /// </summary>
    public class G_ConflictResolverTests
    {
        [Fact(DisplayName = "G25. 同格競爭：高分者佔位，其他人原地")]
        public void HigherScoreWins_OnSameTargetCell()
        {
            // 小盤面，兩名生存者搶同一格
            var config = new GameConfig
            {
                Width = 7, Height = 7,
                SurvivorCount = 0, KillerCount = 0,
                Seed = 250
            };

            var exitPoints = Array.Empty<Point>();
            var survivors = new[] { new Point(3, 3), new Point(5, 3) };
            var killers = Array.Empty<Point>();

            var gameState = TestBoardBuilder.BuildFixed(config, exitPoints, survivors, killers);
            var survivorA = gameState.Survivors[0]; // Id=0
            var survivorB = gameState.Survivors[1]; // Id=1

            var targetCell = new Point(4, 3); // 兩人都想進來
            var submissions = new List<(Survivor actor, Point target, double score)>
            {
                (survivorA, targetCell, score: 0.8),
                (survivorB, targetCell, score: 0.2)
            };

            var decided = MoveConflictResolver.ResolveNoOverlapSwap(gameState, submissions);

            Assert.Equal(targetCell, decided[survivorA.Id]); // 高分者得
            Assert.Equal(survivorB.Pos, decided[survivorB.Id]); // 低分者原地
        }

        [Fact(DisplayName = "G26. 同分 tie-break：Id 較小者佔位")]
        public void TieBreakById_WhenScoresEqual_OnSameTargetCell()
        {
            var config = new GameConfig
            {
                Width = 7, Height = 7,
                SurvivorCount = 0, KillerCount = 0,
                Seed = 260
            };

            var gameState = TestBoardBuilder.BuildFixed(
                config,
                exits: Array.Empty<Point>(),
                survivors: new[] { new Point(3, 3), new Point(5, 3) },
                killers: Array.Empty<Point>());

            var survivorA = gameState.Survivors[0]; // Id=0
            var survivorB = gameState.Survivors[1]; // Id=1

            var targetCell = new Point(4, 3);
            var submissions = new List<(Survivor actor, Point target, double score)>
            {
                (survivorA, targetCell, score: 1.0),
                (survivorB, targetCell, score: 1.0) // 同分
            };

            var decided = MoveConflictResolver.ResolveNoOverlapSwap(gameState, submissions);

            Assert.Equal(targetCell, decided[survivorA.Id]);   // Id 小者贏
            Assert.Equal(survivorB.Pos, decided[survivorB.Id]); // 另一位原地
        }

        [Fact(DisplayName = "G27. 禁止對向交換：兩人互換彼此格子 ⇒ 皆原地")]
        public void NoSwap_BothStay_WhenOppositeExchange()
        {
            var config = new GameConfig
            {
                Width = 7, Height = 7,
                SurvivorCount = 0, KillerCount = 0,
                Seed = 270
            };

            var gameState = TestBoardBuilder.BuildFixed(
                config,
                exits: Array.Empty<Point>(),
                survivors: new[] { new Point(3, 3), new Point(4, 3) },
                killers: Array.Empty<Point>());

            var a = gameState.Survivors[0];
            var b = gameState.Survivors[1];

            var submissions = new List<(Survivor actor, Point target, double score)>
            {
                (a, b.Pos, score: 1.0),
                (b, a.Pos, score: 1.0)
            };

            var decided = MoveConflictResolver.ResolveNoOverlapSwap(gameState, submissions);

            Assert.Equal(a.Pos, decided[a.Id]); // 原地
            Assert.Equal(b.Pos, decided[b.Id]); // 原地
        }

        // === 28. 跟隨鏈（期望 vs 目前行為） ===

        [Fact(DisplayName = "G28(expectation). 三人循環跟隨應阻擋（目前程式尚未支援）", Skip = "MoveConflictResolver 尚未實作一般循環（>2）偵測/回退；此測試為未來功能預留")]
        public void FollowChain_ShouldBePrevented_WhenThreeCycle()
        {
            // 期望行為（尚未實作）：
            // A: (3,3) -> B.pos
            // B: (4,3) -> C.pos
            // C: (5,3) -> A.pos
            // 三人形成 3-cycle，應回退以避免循環（例如讓後序者原地）。
            var config = new GameConfig { Width = 9, Height = 9, SurvivorCount = 0, KillerCount = 0, Seed = 280 };
            var gameState = TestBoardBuilder.BuildFixed(
                config,
                exits: Array.Empty<Point>(),
                survivors: new[] { new Point(3, 3), new Point(4, 3), new Point(5, 3) },
                killers: Array.Empty<Point>());

            var a = gameState.Survivors[0];
            var b = gameState.Survivors[1];
            var c = gameState.Survivors[2];

            var submissions = new List<(Survivor actor, Point target, double score)>
            {
                (a, b.Pos, 1.0),
                (b, c.Pos, 1.0),
                (c, a.Pos, 1.0)
            };

            var decided = MoveConflictResolver.ResolveNoOverlapSwap(gameState, submissions);

            // 期望（尚未實作）：至少一人被回退，避免三人互換結束狀態
            Assert.NotEqual(b.Pos, decided[a.Id]);
            Assert.NotEqual(c.Pos, decided[b.Id]);
            Assert.NotEqual(a.Pos, decided[c.Id]);
        }

        [Fact(DisplayName = "G28(current). 目前行為：三人循環跟隨會被允許（未阻擋）")]
        public void FollowChain_CurrentlyAllowed_ThreeCycle()
        {
            // 目前版本只阻擋「兩人對向交換」，不處理一般循環。
            var config = new GameConfig { Width = 9, Height = 9, SurvivorCount = 0, KillerCount = 0, Seed = 281 };
            var gameState = TestBoardBuilder.BuildFixed(
                config,
                exits: Array.Empty<Point>(),
                survivors: new[] { new Point(3, 3), new Point(4, 3), new Point(5, 3) },
                killers: Array.Empty<Point>());

            var a = gameState.Survivors[0];
            var b = gameState.Survivors[1];
            var c = gameState.Survivors[2];

            var submissions = new List<(Survivor actor, Point target, double score)>
            {
                (a, b.Pos, 1.0),
                (b, c.Pos, 1.0),
                (c, a.Pos, 1.0)
            };

            var decided = MoveConflictResolver.ResolveNoOverlapSwap(gameState, submissions);

            // 驗證目前的實際行為（允許 3-cycle）：每個人都移動到下家的起點
            Assert.Equal(b.Pos, decided[a.Id]);
            Assert.Equal(c.Pos, decided[b.Id]);
            Assert.Equal(a.Pos, decided[c.Id]);
        }
    }
}
```

---

### 備註與後續建議

* **G25/G26/G27** 會通過，因為你的解算器已處理：同格競爭（依 score、再依 id）與雙向交換禁止。
* **G28**：目前僅有「現行行為」測試。若你打算支援一般循環（例如長度 3 以上），可以把 resolver 增強為：

  1. 先建立「起點 → 目標」的映射圖；
  2. 找所有 **有向環**（長度 ≥ 2）；
  3. 對長度=2 的環維持現有處理（雙向互換 → 皆回退）；
  4. 對長度≥3 的環，選擇一個策略（例如「除環中得分最低者回退，其餘照常」或「全員回退」），之後把上面的 **Skip 測試**打開並依策略調整斷言。

要我順手把「三人以上循環阻擋」也實作到 `MoveConflictResolver` 給你一個可通過的版本嗎？我可以採「環中只有最高分前進，其餘回退」的規則，比較直覺而且易測。


Qestion : 目前這樣的規則就可以了，我們暫時不需要考慮太過複雜的狀況，請開始 H.

好的！我把 **H. 事件與分數（29–31）** 的 xUnit 測試整理成一個檔案。
重點維持你的要求：**所有迴圈（for/foreach/while）即使只有一行也都使用 `{ }`**，且命名清楚。
這些測試沿用我們之前提供的 `TestBoardBuilder` 與 `StepRunner`，不需更動主程式。

---

## `H_EventsScoringTests.cs`

```csharp
using System;
using System.Linq;
using TagPOC;
using Xunit;

namespace TagPOC.Tests
{
    /// <summary>
    /// H. 事件與分數（29–31）
    /// 29) 捕獲加分（任一捕獲發生 → KillerScore +1 且被捕生存者移除）
    /// 30) 逃脫加分（生存者踏上出口 → SurvivorScore +1 且該生存者移除）
    /// 31) 單回合多事件順序：鬼Phase捕獲 → 生存者Phase移動→先逃脫→再捕獲
    /// </summary>
    public class H_EventsScoringTests
    {
        [Fact(DisplayName = "H29. 捕獲發生時：KillerScore +1 且生存者被移除")]
        public void Capture_IncrementsKillerScore_AndRemovesSurvivor()
        {
            // 佈局：鬼一步可在鬼Phase進到生存者格
            var config = new GameConfig
            {
                Width = 9, Height = 9,
                SurvivorCount = 0, KillerCount = 0,
                SurvivorSight = 2, KillerSight = 3,
                Seed = 901
            };

            var exitPoint   = new Point(0, 0);  // 無關
            var survivorPos = new Point(5, 5);
            var killerPos   = new Point(4, 4);  // 斜向一步可達 (5,5)

            var gameState = TestBoardBuilder.BuildFixed(
                config,
                exits:     new[] { exitPoint },
                survivors: new[] { survivorPos },
                killers:   new[] { killerPos }
            );

            var exitField = StepRunner.BuildExitField(gameState);

            // Act：執行鬼 Phase（預期會捕獲）
            StepRunner.RunKillerPhase(gameState, exitField);

            // Assert
            Assert.Equal(1, gameState.KillerScore);
            Assert.Equal(0, gameState.Survivors.Count(s => s.Alive));
        }

        [Fact(DisplayName = "H30. 逃脫發生時：SurvivorScore +1 且該生存者被移除")]
        public void Escape_IncrementsSurvivorScore_AndRemovesSurvivor()
        {
            // 佈局：生存者相鄰出口；鬼遠離不影響
            var config = new GameConfig
            {
                Width = 9, Height = 9,
                SurvivorCount = 0, KillerCount = 0,
                SurvivorSight = 2, KillerSight = 3,
                Seed = 902
            };

            var exitPoint   = new Point(4, 4);
            var survivorPos = new Point(3, 3);  // 下一步可踏上出口
            var killerPos   = new Point(0, 8);  // 遠處

            var gameState = TestBoardBuilder.BuildFixed(
                config,
                exits:     new[] { exitPoint },
                survivors: new[] { survivorPos },
                killers:   new[] { killerPos }
            );

            var exitField = StepRunner.BuildExitField(gameState);

            // Act：只跑生存者 Phase（測純逃脫）
            StepRunner.RunSurvivorPhase(gameState, exitField);

            // Assert
            Assert.Equal(1, gameState.SurvivorScore);
            Assert.Equal(0, gameState.Survivors.Count(s => s.Alive));
            Assert.Equal(0, gameState.KillerScore);
        }

        [Fact(DisplayName = "H31. 同回合有捕獲與逃脫：順序為『鬼Phase捕獲 → 生存者Phase先逃脫 → 再捕獲』")]
        public void TurnOrder_WithBothCaptureAndEscape_InSameRound()
        {
            // 佈局：
            // - S1 在出口旁，生存者Phase時應逃脫 +1
            // - S2 將在鬼Phase被 K1 捕獲 +1
            // 確保兩事件同回合內都會發生，並檢視最終分數與存活情況。
            var config = new GameConfig
            {
                Width =  nine, Height = nine,
                SurvivorCount = 0, KillerCount = 0,
                SurvivorSight = 2, KillerSight = 3,
                Seed = 903
            };

            var exitPoint = new Point(4, 4);

            var s1Start   = new Point(3, 3);  // 相鄰出口，會逃脫
            var s2Start   = new Point(6, 6);  // 會被 K1 捕獲
            var k1Start   = new Point(5, 5);  // 斜向一步可入 (6,6)

            var gameState = TestBoardBuilder.BuildFixed(
                config,
                exits:     new[] { exitPoint },
                survivors: new[] { s1Start, s2Start },
                killers:   new[] { k1Start }
            );

            var exitField = StepRunner.BuildExitField(gameState);

            // === 鬼 Phase：預期 K1 捕獲 S2 ===
            StepRunner.RunKillerPhase(gameState, exitField);

            // 中場檢查（鬼Phase之後）
            Assert.Equal(1, gameState.KillerScore);
            Assert.Equal(1, gameState.Survivors.Count(s => s.Alive)); // S2 被移除，S1 還在

            // === 生存者 Phase：S1 先移動踏出出口 → 逃脫 +1（若其他生存者移動踩到鬼才會再被捕）===
            StepRunner.RunSurvivorPhase(gameState, exitField);

            // 回合末狀態：S1 逃脫、S2 被捕；生存者全移除
            Assert.Equal(1, gameState.SurvivorScore); // 先逃脫
            Assert.Equal(1, gameState.KillerScore);   // 之前的捕獲
            Assert.Equal(0, gameState.Survivors.Count(s => s.Alive));

            // 額外確認：S1 確實是因為踏出口而消失（非被捕）
            // （因我們先在鬼Phase已完成一次捕獲，生存者Phase的 ResolveEscapes 先於「生踩鬼」捕獲）
            // 這裡用「鬼分數未增加到 2」間接驗證逃脫優先。
            Assert.Equal(1, gameState.KillerScore);
        }

        // 小工具：避免魔數
        private const int nine = 9;
    }
}
```

---

### 測試重點回顧

* **H29**：在鬼 Phase 內完成捕獲 → `KillerScore` 立刻 +1，且生存者被移除。
* **H30**：在生存者 Phase 內踏出口 → `SurvivorScore` +1，且該生存者被移除（不會同回合再被捕）。
* **H31**：同回合同時存在捕獲及逃脫事件，驗證流程順序正確：

  1. 鬼 Phase 先捕獲；
  2. 生存者 Phase 先處理移動 → 立刻處理逃脫加分與移除；
  3. 再處理「生踩到鬼」的捕獲。
     測試以分數與最後存活狀況確認順序無誤。

---

如果這批都通過，我可以再補 **I. 統計穩健性（32–33）** 的煙霧測試（小批量 Monte Carlo），或你也可以指定下一個區塊要先完成哪一組 👍

Question : 可以開始 I

Answer : 
太好了～我把 **I. 統計穩健性（32–33）** 的 xUnit「煙霧測試」寫成一個檔案。
特色：

* 所有 `for/foreach/while` 一律加上 `{ }`。
* 以**小批量蒙地卡羅**（可調整集數，預設 150）驗證「勝率穩定性」與「單一旋鈕的單調性」。
* 測試時不依賴 `MiniMonteCarlo.RunBatch`（它只列印），而是在測試內建一個 `RunBatchForStats(...)` 回傳統計值。

> 提醒：這類測試屬「煙霧/趨勢」檢查，避免過度嚴苛。為降低隨機抖動，選用 150 場與寬鬆閾值；若你想更嚴格，可將 `episodes` 提高與容忍度調小。

---

## `I_MonteCarloSmokeTests.cs`

```csharp
using System;
using System.Linq;
using TagPOC;
using Xunit;

namespace TagPOC.Tests
{
    /// <summary>
    /// I. 統計穩健性（32–33）
    /// 32) 相同參數下，多批次勝率差不應過大（穩定性）
    /// 33) 單一旋鈕單調性：SurvivorSight 2 → 3 不應讓鬼勝率上升，且不應讓生存者平均得分下降
    /// </summary>
    public class I_MonteCarloSmokeTests
    {
        private readonly record struct BatchStats(double KillerWinRate, double AvgSurvivorPoints, double AvgKillerPoints, double AvgRounds);

        private static BatchStats RunBatchForStats(GameConfig baseConfig, int episodes, int seedOffset)
        {
            int killerWins = 0;
            int totalSurvivorPoints = 0;
            int totalKillerPoints = 0;
            int totalRounds = 0;

            for (int i = 0; i < episodes; i++)
            {
                var config = baseConfig with
                {
                    Seed = baseConfig.Seed + seedOffset + i,
                    VerboseLog = false,
                    PrintAsciiMapEachRound = false
                };

                var (winner, survivorScore, killerScore, rounds) = Simulator.RunOne(config);

                if (winner == "Killer")
                {
                    killerWins++;
                }

                totalSurvivorPoints += survivorScore;
                totalKillerPoints += killerScore;
                totalRounds += rounds;
            }

            double winRate = (double)killerWins / episodes;
            double avgS = (double)totalSurvivorPoints / episodes;
            double avgK = (double)totalKillerPoints / episodes;
            double avgR = (double)totalRounds / episodes;

            return new BatchStats(winRate, avgS, avgK, avgR);
        }

        [Fact(DisplayName = "I32. 穩定性：同參數下不同隨機種子，鬼勝率差異不應過大")]
        public void Stability_KillerWinRate_ShouldNotVaryTooMuchAcrossBatches()
        {
            // 基準配置：50x50、3v3、視野 5x5 / 7x7、回合 100（與主程式預設一致）
            var baseConfig = new GameConfig
            {
                Width = 50,
                Height = 50,
                MaxRounds = 100,
                SurvivorCount = 3,
                KillerCount = 3,
                SurvivorSight = 2,
                KillerSight = 3,
                ExitCount = 2,
                Seed = 1000
            };

            int episodes = 150;           // 小批量即可觀察趨勢
            double allowedDiff = 0.20;    // 允許批次間最大 20% 的波動

            var batchA = RunBatchForStats(baseConfig, episodes, seedOffset: 0);
            var batchB = RunBatchForStats(baseConfig, episodes, seedOffset: 10_000);

            // 鬼勝率不應差太多（避免回歸造成極端不穩定）
            double diff = Math.Abs(batchA.KillerWinRate - batchB.KillerWinRate);
            Assert.True(diff <= allowedDiff, $"Win rate drift too large: Δ={diff:0.000} (> {allowedDiff:0.00})");

            // 一些基本健全檢查
            Assert.InRange(batchA.AvgRounds, 1, baseConfig.MaxRounds);
            Assert.InRange(batchB.AvgRounds, 1, baseConfig.MaxRounds);
            Assert.True(batchA.AvgSurvivorPoints >= 0 && batchB.AvgSurvivorPoints >= 0, "Avg survivor points should be non-negative.");
            Assert.True(batchA.AvgKillerPoints >= 0 && batchB.AvgKillerPoints >= 0, "Avg killer points should be non-negative.");
        }

        [Fact(DisplayName = "I33. 單調性：SurvivorSight ↑ 時，鬼勝率不應上升；生存者平均分不應下降")]
        public void Monotonicity_SurvivorSight_Increase_ShouldNotHelpKillers()
        {
            var baseConfigLowSight = new GameConfig
            {
                Width = 50,
                Height = 50,
                MaxRounds = 100,
                SurvivorCount = 3,
                KillerCount = 3,
                SurvivorSight = 2, // 5x5
                KillerSight = 3,   // 7x7
                ExitCount = 2,
                Seed = 2000
            };

            var baseConfigHighSight = baseConfigLowSight with { SurvivorSight = 3 }; // 7x7 視野給生存者

            int episodes = 150;
            double epsilon = 0.05; // 允許小幅隨機抖動

            var low = RunBatchForStats(baseConfigLowSight, episodes, seedOffset: 0);
            var high = RunBatchForStats(baseConfigHighSight, episodes, seedOffset: 10_000);

            // 生存者視野變大，不應讓「鬼勝率」上升
            Assert.True(high.KillerWinRate <= low.KillerWinRate + epsilon,
                $"Killer win rate increased unexpectedly when SurvivorSight increased: low={low.KillerWinRate:0.000}, high={high.KillerWinRate:0.000}, eps={epsilon:0.00}");

            // 也不應讓生存者平均得分下降
            Assert.True(high.AvgSurvivorPoints + epsilon >= low.AvgSurvivorPoints,
                $"Avg survivor points dropped unexpectedly when SurvivorSight increased: low={low.AvgSurvivorPoints:0.000}, high={high.AvgSurvivorPoints:0.000}, eps={epsilon:0.00}");
        }
    }
}
```

---

### 小結

* **I32**：以兩個不同的隨機區間跑各 150 場，比較鬼勝率差異是否 ≤ 20%。同時做基本健全檢查（平均回合數落在 1～MaxRounds、平均分數非負）。
* **I33**：將 `SurvivorSight` 從 2 提升到 3，跑各 150 場；檢查鬼勝率**不增加**、生存者平均分**不降低**（容忍抖動 `ε=0.05`）。

如果你希望把這些測試跑得更穩，可以把 `episodes` 提高到 300～500；或把 `epsilon/allowedDiff` 再調小。
要不要我接著補 **J. Logging 與可診斷性（34–35）**？

Question : 
先處理第一個語法的問題 C# 沒有 with 的寫法
例如 : 
var baseConfigHighSight = baseConfigLowSight with { SurvivorSight = 3 }; 
這是不可以執行的

需要創建這個物件後初始化給設定，請幫我調整

Answer : 
啊對，你的 `GameConfig` 在我們的專案裡是 **class** 不是 `record`，所以 C# 沒有 `with` 表達式可用。
要做「複製後改某些屬性」只能用 **new + 指定屬性**。

我幫你把 `I33` 測試改掉 `with` 的語法，使用正統的物件初始化：

---

### 修正版片段（I33 測試內）

```csharp
[Fact(DisplayName = "I33. 單調性：SurvivorSight ↑ 時，鬼勝率不應上升；生存者平均分不應下降")]
public void Monotonicity_SurvivorSight_Increase_ShouldNotHelpKillers()
{
    var baseConfigLowSight = new GameConfig
    {
        Width = 50,
        Height = 50,
        MaxRounds = 100,
        SurvivorCount = 3,
        KillerCount = 3,
        SurvivorSight = 2, // 5x5
        KillerSight = 3,   // 7x7
        ExitCount = 2,
        Seed = 2000
    };

    // 原本 with 改為 new 初始化
    var baseConfigHighSight = new GameConfig
    {
        Width = baseConfigLowSight.Width,
        Height = baseConfigLowSight.Height,
        MaxRounds = baseConfigLowSight.MaxRounds,
        SurvivorCount = baseConfigLowSight.SurvivorCount,
        KillerCount = baseConfigLowSight.KillerCount,
        SurvivorSight = 3, // 7x7 視野給生存者
        KillerSight = baseConfigLowSight.KillerSight,
        ExitCount = baseConfigLowSight.ExitCount,
        Seed = baseConfigLowSight.Seed
    };

    int episodes = 150;
    double epsilon = 0.05; // 允許小幅隨機抖動

    var low = RunBatchForStats(baseConfigLowSight, episodes, seedOffset: 0);
    var high = RunBatchForStats(baseConfigHighSight, episodes, seedOffset: 10_000);

    // 生存者視野變大，不應讓「鬼勝率」上升
    Assert.True(high.KillerWinRate <= low.KillerWinRate + epsilon,
        $"Killer win rate increased unexpectedly when SurvivorSight increased: low={low.KillerWinRate:0.000}, high={high.KillerWinRate:0.000}, eps={epsilon:0.00}");

    // 也不應讓生存者平均得分下降
    Assert.True(high.AvgSurvivorPoints + epsilon >= low.AvgSurvivorPoints,
        $"Avg survivor points dropped unexpectedly when SurvivorSight increased: low={low.AvgSurvivorPoints:0.000}, high={high.AvgSurvivorPoints:0.000}, eps={epsilon:0.00}");
}
```

---

這樣就能正常編譯。
你要不要我幫你寫一個 `Clone()` 方法（或 `CopyFrom(...)`）在 `GameConfig` 裡？這樣以後就不用一個個手動複製，測試會更乾淨。


Question : 
RunBatchForStats 這一個裡面也有 with 的寫法請修正

Answer : 
👌 抓到了！`RunBatchForStats` 裡我用了一個 `with` 來複製 `GameConfig`，但它是 class，不能這樣用。
我們只需要建立一個新的 `GameConfig`，把屬性一一複製過來，再覆寫要調整的值。

---

### 修正版 `RunBatchForStats`

```csharp
private static BatchStats RunBatchForStats(GameConfig baseConfig, int episodes, int seedOffset)
{
    int killerWins = 0;
    int totalSurvivorPoints = 0;
    int totalKillerPoints = 0;
    int totalRounds = 0;

    for (int i = 0; i < episodes; i++)
    {
        var config = new GameConfig
        {
            Width = baseConfig.Width,
            Height = baseConfig.Height,
            MaxRounds = baseConfig.MaxRounds,
            SurvivorCount = baseConfig.SurvivorCount,
            KillerCount = baseConfig.KillerCount,
            SurvivorSight = baseConfig.SurvivorSight,
            KillerSight = baseConfig.KillerSight,
            ExitCount = baseConfig.ExitCount,
            Seed = baseConfig.Seed + seedOffset + i,
            VerboseLog = false,
            PrintAsciiMapEachRound = false
        };

        var (winner, survivorScore, killerScore, rounds) = Simulator.RunOne(config);

        if (winner == "Killer")
        {
            killerWins++;
        }

        totalSurvivorPoints += survivorScore;
        totalKillerPoints += killerScore;
        totalRounds += rounds;
    }

    double winRate = (double)killerWins / episodes;
    double avgS = (double)totalSurvivorPoints / episodes;
    double avgK = (double)totalKillerPoints / episodes;
    double avgR = (double)totalRounds / episodes;

    return new BatchStats(winRate, avgS, avgK, avgR);
}
```

---

這樣就完全移除了 `with`，跑測試就不會再遇到編譯錯誤。

要不要我幫你在 `GameConfig` 裡加一個 `CloneWith(Action<GameConfig> mutate)` 小工具？這樣測試就能寫成：

```csharp
var highSight = baseConfigLowSight.CloneWith(cfg => cfg.SurvivorSight = 3);
```

比手動複製所有欄位乾淨很多。


Question : 
這個測試通過了，接著我需要回到我前面問過的問題，我想知道我們目前的參數在 生存者 3 鬼 2 地圖大小 100 x 100 的情況下哪一邊的勝率高，並且我希望能夠將我們跑的模擬結果留下來，請幫我放在這個專案目錄下 TestResult 的檔案，檔案格式可以由你決定，但我會想知道 1、每一次模擬結果的關鍵事件，例如: 第幾回合生存者編號幾被鬼抓了，第幾回合生存者編號幾逃脫了。 2、每一次模擬結果的最終勝利方 3、最後統計出來的數字哪一邊勝率比較高?

Answer : 
棒！我幫你做了一組「可直接落地」的**批次模擬＋落檔**工具，不動你現有測試；只要把下面 3 個檔案加到主專案（`TagPOC`）裡，然後在 `Program.Main` 呼叫一次就能在專案根目錄下生成 `TestResult/`，包含：

* `episode_XXXX.ndjson`：逐回合關鍵事件（CAPTURE / ESCAPE）
* `summary.csv`：每場摘要（勝利方、回合數、雙方分數）
* `aggregate.json`：整體統計（鬼勝率、生存者平均得分…），並指出哪一邊勝率較高

我已預設參數：**地圖 100×100、3 名生存者、2 名鬼、100 回合**。
你可以在 `Program.Main` 用這個設定跑 N 場（例如 300 場）。

---

# 1) `GameEvent.cs`

```csharp
using System;

namespace TagPOC
{
    public enum GameEventType { Capture, Escape }

    public sealed class GameEvent
    {
        public int Episode { get; set; }
        public int Round { get; set; }
        public GameEventType Type { get; set; }

        // 參與者
        public int? SurvivorId { get; set; }
        public int? KillerId { get; set; }

        // 事件位置（當下格）
        public int X { get; set; }
        public int Y { get; set; }

        public override string ToString()
        {
            return $"{{\"episode\":{Episode},\"round\":{Round},\"type\":\"{Type}\",\"survivorId\":{(SurvivorId.HasValue ? SurvivorId.Value : -1)},\"killerId\":{(KillerId.HasValue ? KillerId.Value : -1)},\"x\":{X},\"y\":{Y}}}";
        }
    }
}
```

---

# 2) 擴充 logger：在 `StructuredLogger` 裡加事件收集

把下列兩個新增的成員與修改過的兩個方法貼進你現有的 `StructuredLogger` 類別（原有功能不變；只是多記一份事件）。

```csharp
// 在 StructuredLogger 類別內新增：
public readonly System.Collections.Generic.List<GameEvent> Events = new System.Collections.Generic.List<GameEvent>();
internal int CurrentEpisode { get; set; } = 0;

// 修改 Capture 與 Escape：保留原本 Console.WriteLine，同時記事件
public void Capture(Killer killer, Survivor victim, string phase)
{
    Console.WriteLine($"[CAPTURE] phase={phase} killer={killer.Id}@{killer.Pos} victim={victim.Id}@{victim.Pos}");
    Events.Add(new GameEvent
    {
        Episode = CurrentEpisode,
        Round = killer is null ? 0 : killer.Id >= 0 ? 0 : 0, // 佔位，不用這行也行
        // 正確 round 由外層填（見 RunOneWithEvents），這裡先佔位
        Type = GameEventType.Capture,
        SurvivorId = victim.Id,
        KillerId = killer.Id,
        X = killer.Pos.X,
        Y = killer.Pos.Y
    });
}

public void Escape(Survivor survivor)
{
    Console.WriteLine($"[ESCAPE] survivor={survivor.Id}@{survivor.Pos}");
    Events.Add(new GameEvent
    {
        Episode = CurrentEpisode,
        Round = 0, // 佔位，稍後由外層補 round
        Type = GameEventType.Escape,
        SurvivorId = survivor.Id,
        KillerId = null,
        X = survivor.Pos.X,
        Y = survivor.Pos.Y
    });
}
```

> 小提醒：上面 `Round=0` 是暫存；我在下一個 `RunOneWithEvents` 會於事件發生的當回合即補上正確 `Round` 值。

---

# 3) `SimulatorExtensions.cs`：回傳事件、寫檔工具

```csharp
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;

namespace TagPOC
{
    public static class SimulatorExtensions
    {
        /// <summary>
        /// 跑單場並回傳：勝者 / 分數 / 回合數 / 逐回合事件。
        /// 此函式為保留你原有 RunOne 的語意，僅在事件產生時把 Round/EP 填正。
        /// </summary>
        public static (string Winner, int SurvivorScore, int KillerScore, int Rounds, List<GameEvent> Events)
            RunOneWithEvents(GameConfig config, int episode)
        {
            var state = new GameState(config);
            state.Log.CurrentEpisode = episode;

            Setup.Initialize(state);
            var exitsField = DistanceFieldBuilder.BuildExitField(state);

            // 本地方法：把剛新增進 Events 的 round 填正
            void StampRoundOnNewEvents(int round)
            {
                // 從尾端往回補到第一個尚未 stamp 的事件
                for (int i = state.Log.Events.Count - 1; i >= 0; i--)
                {
                    if (state.Log.Events[i].Round == 0)
                    {
                        state.Log.Events[i].Round = round;
                        state.Log.Events[i].Episode = episode;
                    }
                    else
                    {
                        break;
                    }
                }
            }

            for (state.Round = 1; state.Round <= config.MaxRounds; state.Round++)
            {
                // === Killer Phase ===
                var killerMoves = new List<(Killer actor, Point target, double score)>();
                foreach (var killer in state.Killers.Where(k => k.Alive))
                {
                    var target = KillerPolicy.DecideNext(state, killer, exitsField);
                    var sc = -Point.Chebyshev(target, killer.Pos);
                    killerMoves.Add((killer, target, sc));
                }
                var killerDecided = MoveConflictResolver.ResolveNoOverlapSwap(state, killerMoves);

                // 套用 & 捕獲 #1
                foreach (var kv in killerDecided)
                {
                    var killer = state.Killers.First(a => a.Id == kv.Key);
                    killer.Pos = kv.Value;
                }
                foreach (var killer in state.Killers.Where(k => k.Alive))
                {
                    var victims = state.Survivors.Where(sv => sv.Alive && sv.Pos.Equals(killer.Pos)).ToList();
                    foreach (var victim in victims)
                    {
                        victim.Alive = false;
                        state.KillerScore++;
                        state.Log.Capture(killer, victim, phase: "KillerPhase");
                        StampRoundOnNewEvents(state.Round);
                    }
                }

                if (!state.Survivors.Any(sv => sv.Alive))
                {
                    state.Log.RoundFooter(state);
                    return ("Killer", state.SurvivorScore, state.KillerScore, state.Round, state.Log.Events.ToList());
                }

                // === Survivor Phase ===
                var survivorMoves = new List<(Survivor actor, Point target, double score)>();
                foreach (var survivor in state.Survivors.Where(sv => sv.Alive))
                {
                    var target = SurvivorPolicy.DecideNext(state, survivor, exitsField);
                    var sc = -Point.Chebyshev(target, survivor.Pos);
                    survivorMoves.Add((survivor, target, sc));
                }
                var survivorDecided = MoveConflictResolver.ResolveNoOverlapSwap(state, survivorMoves);

                // 移動
                foreach (var kv in survivorDecided)
                {
                    var survivor = state.Survivors.First(a => a.Id == kv.Key);
                    survivor.Pos = kv.Value;
                }

                // 逃脫
                foreach (var survivor in state.Survivors.Where(sv => sv.Alive && state.IsExit(sv.Pos)).ToList())
                {
                    survivor.Alive = false;
                    state.SurvivorScore++;
                    state.Log.Escape(survivor);
                    StampRoundOnNewEvents(state.Round);
                }

                // 被捕 #2（生踩鬼）
                foreach (var survivor in state.Survivors.Where(sv => sv.Alive).ToList())
                {
                    if (state.Killers.Any(k => k.Alive && k.Pos.Equals(survivor.Pos)))
                    {
                        survivor.Alive = false;
                        state.KillerScore++;
                        var killer = state.Killers.First(k => k.Alive && k.Pos.Equals(survivor.Pos));
                        state.Log.Capture(killer, survivor, phase: "SurvivorPhase");
                        StampRoundOnNewEvents(state.Round);
                    }
                }

                state.Log.RoundFooter(state);

                if (!state.Survivors.Any(sv => sv.Alive))
                {
                    return ("Killer", state.SurvivorScore, state.KillerScore, state.Round, state.Log.Events.ToList());
                }
            }

            // 時間到：規則=鬼勝
            return ("Killer", state.SurvivorScore, state.KillerScore, state.Round, state.Log.Events.ToList());
        }

        /// <summary>
        /// 跑多場並把結果寫入 ./TestResult
        /// </summary>
        public static void RunAndSaveBatch(GameConfig baseConfig, int episodes, string outputDir = "TestResult")
        {
            if (!Directory.Exists(outputDir))
            {
                Directory.CreateDirectory(outputDir);
            }

            var csvPath = Path.Combine(outputDir, "summary.csv");
            using var sw = new StreamWriter(csvPath, false);
            sw.WriteLine("episode,winner,survivorScore,killerScore,rounds");

            int killerWins = 0;
            int sumS = 0;
            int sumK = 0;
            int sumRounds = 0;

            for (int i = 0; i < episodes; i++)
            {
                var config = new GameConfig
                {
                    Width = baseConfig.Width,
                    Height = baseConfig.Height,
                    MaxRounds = baseConfig.MaxRounds,
                    SurvivorCount = baseConfig.SurvivorCount,
                    KillerCount = baseConfig.KillerCount,
                    SurvivorSight = baseConfig.SurvivorSight,
                    KillerSight = baseConfig.KillerSight,
                    ExitCount = baseConfig.ExitCount,
                    Seed = baseConfig.Seed + i,
                    VerboseLog = false,
                    PrintAsciiMapEachRound = false
                };

                var (winner, sScore, kScore, rounds, events) = RunOneWithEvents(config, i);

                // 逐回合事件 NDJSON
                var ndjson = Path.Combine(outputDir, $"episode_{i:D4}.ndjson");
                using (var ew = new StreamWriter(ndjson, false))
                {
                    for (int j = 0; j < events.Count; j++)
                    {
                        ew.WriteLine(events[j].ToString());
                    }
                }

                // 摘要 CSV
                sw.WriteLine($"{i},{winner},{sScore},{kScore},{rounds}");

                if (winner == "Killer")
                {
                    killerWins++;
                }
                sumS += sScore;
                sumK += kScore;
                sumRounds += rounds;
            }

            double killerWinRate = (double)killerWins / episodes;
            double avgS = (double)sumS / episodes;
            double avgK = (double)sumK / episodes;
            double avgR = (double)sumRounds / episodes;

            // aggregate.json
            var aggregatePath = Path.Combine(outputDir, "aggregate.json");
            using (var aw = new StreamWriter(aggregatePath, false))
            {
                var whichHigher = killerWinRate > 0.5 ? "Killer" : (killerWinRate < 0.5 ? "Survivor" : "Tie");
                aw.WriteLine("{");
                aw.WriteLine($"  \"episodes\": {episodes},");
                aw.WriteLine($"  \"killer_win_rate\": {killerWinRate.ToString("0.000", CultureInfo.InvariantCulture)},");
                aw.WriteLine($"  \"avg_survivor_points\": {avgS.ToString("0.000", CultureInfo.InvariantCulture)},");
                aw.WriteLine($"  \"avg_killer_points\": {avgK.ToString("0.000", CultureInfo.InvariantCulture)},");
                aw.WriteLine($"  \"avg_rounds\": {avgR.ToString("0.0", CultureInfo.InvariantCulture)},");
                aw.WriteLine($"  \"which_side_higher\": \"{whichHigher}\"");
                aw.WriteLine("}");
            }
        }
    }
}
```

---

# 4) 在 `Program.Main` 呼叫（100×100、S=3、K=2）

把 `Main()` 換成或加上這段（或另外寫一個 `if` 開關）：

```csharp
public static void Main()
{
    var config = new GameConfig
    {
        Width = 100,
        Height = 100,
        MaxRounds = 100,
        SurvivorCount = 3,
        KillerCount = 2,
        SurvivorSight = 2, // 5x5
        KillerSight = 3,   // 7x7
        ExitCount = 2,
        Seed = 42,
        VerboseLog = false,
        PrintAsciiMapEachRound = false
    };

    // 跑 300 場（可依你需求調整），輸出到 ./TestResult
    SimulatorExtensions.RunAndSaveBatch(config, episodes: 300, outputDir: "TestResult");

    Console.WriteLine("Batch done. See ./TestResult for NDJSON per episode, summary.csv, and aggregate.json");
}
```

---

## 你會得到什麼？

* `TestResult/episode_0000.ndjson`、`episode_0001.ndjson`、…
  每行像這樣（方便 grep / jq）：

  ```
  {"episode":12,"round":7,"type":"Capture","survivorId":1,"killerId":0,"x":36,"y":42}
  {"episode":12,"round":15,"type":"Escape","survivorId":0,"killerId":-1,"x":98,"y":3}
  ```
* `TestResult/summary.csv`

  ```
  episode,winner,survivorScore,killerScore,rounds
  0,Killer,0,3,57
  1,Killer,1,2,64
  ...
  ```
* `TestResult/aggregate.json`
  會包含鬼勝率、生存者/鬼平均得分與回合數，還有 `which_side_higher`（哪邊勝率較高）。

---

## 關於你問的三點

1. **每次模擬的關鍵事件**：已寫入 `episode_*.ndjson`（包含「第幾回合、誰被抓、誰逃脫、位置」）。
2. **每次模擬的最終勝利方**：在 `summary.csv`。
3. **整體哪邊勝率較高**：在 `aggregate.json` 的 `which_side_higher` 字段 & `killer_win_rate`；同時你也可以從 `summary.csv` 自己計算。

---

如果你想把匯出改成單一大檔（例如單一 `events.ndjson`，或 SQLite），我也可以幫你換。或是要加上**隨機地圖/初始布局的 snapshot**，方便重現特定 Episode，也能一起加上。
