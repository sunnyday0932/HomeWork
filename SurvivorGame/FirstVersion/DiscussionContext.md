
Question : 我想要針對一個市面上的遊戲 Dead by Daylight 來做一些演算法研究的討論，假設我們現在想要模擬寫出這個遊戲的演算法，可以先請你幫我研究一下這個遊戲的規則嗎?

Answer : 
好的，我先幫你整理一下 **Dead by Daylight (DBD)** 的遊戲規則，讓我們之後討論演算法模擬有一個完整的基礎。以下我會分成幾個部分：

---

## 1. 遊戲基本結構

* **非對稱對抗**：4 名倖存者 (Survivors) vs 1 名殺手 (Killer)。
* **目標**：

  * 倖存者：啟動 5 台發電機，開啟出口門並逃生。
  * 殺手：阻止倖存者逃脫，將他們掛上鉤子並最終犧牲。

---

## 2. 倖存者規則

* **主要行為**：

  * 修理發電機：需要累積進度條 (多次中斷可繼續)。
  * 治療：可幫自己或隊友治療。
  * 躲藏：可進入櫃子、潛行避免被發現。
  * 拯救：從鉤子上救下隊友。
  * 逃生：透過出口門或最後一名倖存者時的「活板門 (Hatch)」。

* **失敗風險**：

  * 修機失敗（QTE 技術檢查失敗）會發出聲音提示殺手。
  * 被殺手攻擊兩次會倒地，再被抓起掛鉤。

---

## 3. 殺手規則

* **主要行為**：

  * 追逐倖存者：移動速度快於倖存者。
  * 攻擊：一次攻擊讓倖存者受傷，第二次使其倒地。
  * 抓取：可直接從修機、翻窗、櫃子中抓人。
  * 掛鉤：將倒地倖存者掛到特定地點的鉤子上。

* **技能特色**：每個殺手有獨特能力（如陷阱、隱形、傳送等）。

---

## 4. 胜利/失敗條件

* **倖存者勝利**：

  * 修好至少 5 台發電機 → 開門 → 至少一人逃脫。
  * 或最後一人能從活板門逃脫。

* **殺手勝利**：

  * 將全部倖存者犧牲（掛鉤多次直至死亡）或阻止逃脫。

---

## 5. 遊戲核心系統

* **修機進度**：每台需要一定時間，4 人合作可加速。
* **技能檢查 (Skill Check)**：隨機觸發的 QTE，失敗會倒退進度並暴露位置。
* **心跳範圍 (Terror Radius)**：倖存者聽到心跳聲代表殺手在附近。
* **地圖限制**：有一定大小，內含障礙物、窗戶、櫃子、板子（可放倒阻礙殺手）。

---

## 6. 可模擬的演算法重點

如果我們要研究演算法，可以針對以下幾個方向：

1. **倖存者行為決策**

   * 何時修機 / 何時躲藏 / 何時救人 / 何時逃跑。
   * 可用 **狀態機 (FSM)** 或 **強化學習 (RL)** 模擬。

2. **殺手追擊策略**

   * 最短路徑（BFS / A\*）找人。
   * 追擊中判斷繞道 vs 直線。

3. **地圖生成 & 平衡性**

   * 演算法可模擬板子、窗戶、發電機位置隨機化。

4. **遊戲勝率平衡**

   * 計算倖存者和殺手在不同策略下的勝率。

---

要不要我幫你把這些規則轉成 **演算法建模用的狀態圖 / 流程圖**，讓之後模擬比較有結構化的參考？

Question : 
先縮小一點規模，我們現在要做一個 POC 版本的鬼抓人遊戲，想要先了解製作出這樣的遊戲架構會需要考慮哪些東西
以下是我現在想到的遊戲規則限制，我們先來確認一下還有沒有遺漏的部分
1、回合制遊戲，總共 100 回合，由鬼先行動，因為分成兩種角色，所以每一回合所有類型的角色都會同時移動，e.g. 第一回合，鬼先行動，若場上有 2 個鬼，都會移動一步。
2、是一個平面地圖，由二維陣列所組成，點與點之間的距離相同。
3、角色與隊伍
    生存者隊
        - 1 ~ 3 位
    鬼隊
        - 2 ~ 5 位

4、移動方式與條件
    - 因為是二維陣列，所以移動方式可以是，上、下、左、右、左上、左下、右上、右下。
    - 一次只能移動一步

5、地圖要素
    - 有 >= 2 的逃脫出口
    - 有限邊界的地圖，因為只有 100 回合，

6、勝利條件
    生存者隊 
        - 當生存者移動到逃脫出口時，生存者隊 + 1 分，同時該名生存者從地圖上移出，逃脫出口保留 (也就是說一個逃脫出口可以使用多次)
        - 當到 100 回合結束時還有生存者仍未移動到逃脫出口則算生存者隊失敗。
    
    鬼隊
        - 當鬼移動到跟生存者同一個點時代表生存者被捕獲，鬼隊 + 1 分，該名被捕或生存者從地圖上移出，鬼則保留在地圖上。
        - 當 100 回合結束前，場上已沒有生存者則算鬼隊獲勝，或是 100 回合到時場上還有生存者也算鬼隊獲勝。

7、行為
    生存者 
        - 以最近出口為逃脫選擇
        - 會盡量避開鬼
        - 生存者彼此不會共享視野
    鬼
        - 以最近的生存者為追捕對象
        - 鬼彼此不會共享視野

8、起始
    - 鬼或是生存者都要距離逃脫出口有一定的距離

Answer:
太好了，我把你列的規則整理成「可直接實作的 POC 規格」，同時把常見會遺漏的細節都補齊（包含同格衝突、同回合先後、距離定義、視野與資訊、出生距離、逃脫/捕獲判定的優先序等）。你可以直接依這版做程式與測試；若要改參數，只需調整常數即可。

# POC 規格（建議預設值）

## 0. 坐標與距離

* 地圖：`W x H` 的二維整數格（建議預設 `W=H=30`，日後可用 10–50 做壓測）。
* 座標系：左上 `(0,0)`，向右 `x+1`，向下 `y+1`。
* 可移動鄰居：8 向（上、下、左、右、左上、右上、左下、右下）。
* **移動成本**：八方向皆為 `1`（Chebyshev metric），**距離**定義為 `max(|dx|,|dy|)`。

## 1. 迴合流程與先後

* 總回合 `T_max = 100`，**每回合分兩個 Phase**：

  1. **鬼行動 Phase**：所有鬼**同時**決定並移動 1 步。

     * 鬼移動完成後，立即結算**捕獲**（見 §4）。
  2. **生存者行動 Phase**：所有生存者**同時**決定並移動 1 步。

     * 生存者移動完成後，立即結算**逃脫與被捕**（見 §4）。
* 如在任何時間點「場上無生存者」，遊戲立刻結束（鬼勝）。

## 2. 隊伍與人數

* 生存者：`1 ~ 3` 位。
* 鬼：`2 ~ 5` 位。

> 兩陣營人數可參數化；測試時建議常用 `(Survivors=3, Killers=3)`。

## 3. 地圖要素

* **出口**：`>= 2` 個出口格。建議預設在邊界上、互相間距離盡量分散（例如四角或邊緣均勻取點）。
* **邊界**：不可越界。
* **障礙**：POC 先無障礙；日後可加入牆/不可通行格。

## 4. 勝負與計分

* **生存者得分**：生存者在生存者 Phase 結束時，若站在出口格 → 該生存者**立刻逃脫 +1 分**，從地圖移除；出口仍可重複使用。
* **鬼得分（捕獲）**：

  * **鬼 Phase 結束時**：若任何鬼**最終停留格**恰為**某生存者的當前位置** → 該生存者被捕，**+1 分**並移除。
  * **生存者 Phase 結束時**：若任何生存者**最終停留格**恰為**某鬼的當前位置** → 該生存者被捕，**+1 分**並移除。
* **終局**：

  * 於 `T_max` 前場上無生存者 → 鬼勝。
  * 到 `T_max` 仍有任一生存者未逃脫 → 鬼勝。
  * 生存者並無「全員逃脫才勝」的條件；本 POC 定義**只要結束仍有人未逃**就判鬼勝（符合你列的規則）。

## 5. 同格衝突與占位規則（關鍵補齊）

* **鬼-鬼**：可同格（不阻擋彼此）。
* **生存者-生存者**：預設**不可同格**。同回合若多名生存者選擇同一目的格，**以穩定 tie-breaker** 解決：

  * 依生存者 `Id`（或出生順序）由小到大，依序「鎖定」該格；後來者若衝突則**改為保留原地不動**（或挑次佳候選格，見 §7 策略可選擇）。
* **鬼-生存者**：允許同格，並依 §4 的時點規則結算捕獲。

## 6. 起始配置（出生規則）

* 參數：

  * `D_exit_min`：任一單位（鬼/生存者）到任一出口的最小初始距離（Chebyshev）。建議預設 `D_exit_min = 8`。
  * `D_enemy_min`：初始時敵我間最小距離（避免一出生就被秒抓）。建議 `D_enemy_min = 4`。
  * `D_ally_min`：同陣營最小距離（避免卡位）。建議 `D_ally_min = 2`。
* 生成步驟（無障礙版）：

  1. 先放出口（邊界均勻）。
  2. 以隨機或固定種子抽樣生存者位置，直到滿足 `D_exit_min`/`D_enemy_min`/`D_ally_min`。
  3. 以同樣規則放置鬼。
  4. 若抽樣次數上限仍無解，放寬距離（逐步 -1）直至可行。

## 7. 行為與目標選擇（可直接實作的簡化 AI）

### 7.1 生存者策略（最近出口 + 盡量避鬼）

* **資訊模型（POC 版本）**：**完全資訊**環境，但「不共享視野」解釋為：**決策函式在程式上以單一個體為單位，不讀取其他生存者的「內部暫存狀態」**；位置仍可讀取。

  > 後續可切換為「感知半徑 `R_sight`」模式（只看得到距離 ≤ `R_sight` 的敵/出口）。POC 預設先全知，方便驗證基準。
* **目標出口**：以 Chebyshev 距離選最近出口；若距離相同，選擇 `Id` 較小的出口（穩定性）。
* **每步評分函式（八鄰居中擇優）**：
  對每個候選格 `n` 計算

  ```
  score(n) = α * (-dist_to_target_exit(n))
           + β * (min_dist_to_any_killer(n))
           + γ * (-ally_conflict_penalty(n))
  ```

  * `dist_to_target_exit`：Chebyshev 距離。
  * `min_dist_to_any_killer`：離最近鬼的距離（越大越安全）。
  * `ally_conflict_penalty(n)`：若其他生存者也瞄準 `n`，可加一個預估懲罰（POC 先設 0；靠 §5 的 tie-breaker 解）。
  * 建議預設係數：`α=1.0, β=0.6, γ=0`（可 A/B 測）。
* **不可行動**：越界或被占據規則不允許（同隊同格）者捨棄。若無可行步，**原地不動**。

### 7.2 鬼策略（最近生存者為追捕目標）

* **目標生存者**：取距離最近者；若有多名距離相同，取 `Id` 最小者（穩定性）。
* **每步評分函式**：

  ```
  score(n) = - dist_to_target_survivor(n)
  ```

  同距離時備選 tie-breaker：優先讓 `dx`/`dy` 絕對值較大的方向（加快收斂），再以方向序或 `Id` 穩定化。
* **鬼可同格**，不需考慮同隊衝突。

## 8. 事件結算的**精確順序**（避免同回合判定歧義）

**在同一回合 t：**

1. **鬼 Phase**
   a. 各鬼基於「回合開始狀態」同時決策目標格。
   b. 同時移動到各自目標格（可同格）。
   c. **捕獲判定 #1**：對每名生存者 `S`，若有任一鬼的**最終格** == `S` 的**當前格** → `S` 被捕，立刻移除並鬼得分。
2. **生存者 Phase**（只對仍存活者）
   a. 各生存者基於「鬼已移動後的狀態」同時決策目標格。
   b. 依 §5 的同隊衝突規則決定最終停留格（衝突者可能留在原地）。
   c. **逃脫判定**：在出口格的生存者 → 立刻逃脫 +1 分並移除。
   d. **捕獲判定 #2**：剩餘仍在場的生存者中，若其**最終格** == 任一鬼的**當前格** → 被捕 +1 分並移除。
3. **終局檢查**：若無生存者 → 立即結束（鬼勝）；若 `t == T_max` 且仍有生存者 → 鬼勝；否則 `t++` 進入下一回合。

> 這個順序明確處理了「同回合同格」與「先到出口 vs 被抓」的爭議：
>
> * 鬼先行，有機會在生存者起步前**先抓**到。
> * 生存者移動後若落在出口就在捕獲前先**逃脫**；但逃脫後仍留在場的生存者，若與鬼同格就會被抓（公平且易測）。

## 9. 複雜度控制與可擴充點

* **可調參數**：`W,H,T_max,D_exit_min,D_enemy_min,D_ally_min, α,β,γ`、出口數量與位置、起點抽樣種子。
* **可選功能（下一步）**：

  * 加入障礙、牆、可破壞板；A\* 取代鄰居打分。
  * 有限視野 `R_sight` + 聲音/心跳提示模型。
  * 多目標協作（生存者間策略多樣化），或鬼之間包夾策略。
  * 不同角色移速/技能（衝刺、短距傳送等）。

## 10. 事件日誌與可視化（便於驗證）

* 每回合輸出：回合數、各角色 `(id, from -> to)`、捕獲/逃脫事件、當前比分。
* 地圖快照（簡易字元地圖）：`S`（生存者 id 小字）、`K`（鬼 id）、`E`（出口）、`.`（空地）。
* 建議附上固定隨機種子重跑測試，確保 determinism。

---

# 極簡主迴圈（偽碼）

```text
state = init(W,H, exits, survivors, killers, constraints)
for t in 1..T_max:
  # Phase K
  K_moves = plan_all_killers(state)
  state = apply_moves_allow_overlap(state, K_moves)
  state = resolve_kill_captures(state)   # 捕獲判定 #1
  if no_survivor(state): break

  # Phase S
  S_moves = plan_all_survivors(state)
  S_moves = resolve_survivor_conflicts(S_moves, state)  # 同隊衝突
  state = apply_moves_no_overlap_for_survivors(state, S_moves)
  state = resolve_escapes(state)         # 逃脫
  state = resolve_kill_captures(state)   # 捕獲判定 #2
  log_round(state)

  if no_survivor(state): break

winner = "Killer" if survivors_left(state) == 0 or t == T_max else "Killer" # 本規則下到時仍有人==鬼勝
```

---

如果你 OK，我下一步可以直接給你一份 **C# 版的資料模型與可跑的核心迴圈（含單元測試雛型）**，把上述規則都落成程式（地圖、角色、移動決策、衝突處理、事件日誌）。你只要決定是否先走「完全資訊」版本，或要同時上「有限視野 `R_sight`」參數。


Question : 
關於規則，我列出幾個我想修改的地方

0. 坐標與距離
- 地圖 : 預設 50 * 50 ，日後調整可能會往上調，因為地圖太小會很快結束

5.同格衝突與占位規則（關鍵補齊）
- 所有角色都不可同格

Answer : 

收到！我把你要改的兩點整合進整體規格，並把「不可同格」帶來的連鎖影響一次補齊（含衝突處理、抓捕判定、swap 衝突等），這版可以直接拿去實作。

# 變更重點

## 0. 座標與距離（更新）

* 地圖大小：預設 **50×50**（左上 `(0,0)`，右下 `(49,49)`）。
* 鄰接：八方向皆可走（上/下/左/右/左上/右上/左下/右下）。
* 距離：**Chebyshev**（一步=1）。

## 5. 同格衝突與占位（重大更新：**所有角色不可同格**）

* **任意時刻的「最終狀態」不得有同格**（鬼-鬼、鬼-生存者、生存者-生存者都不行）。
* **抓捕如何不違反不可同格？**

  * 把「抓捕」定義為**嘗試進入對方所在格**時發生的事件，**事件處理會移除被抓的一方**，因此**回合結束時不會同格**。
  * 結論：**可觸發抓捕，但不會留下同格狀態**。

---

# 完整回合流程（套用不可同格）

每回合 t 仍分兩個 Phase，鬼先、生存者後：

## A. 鬼 Phase（同步決策與移動）

1. **所有鬼同時選一步目標格**（基於回合開始的棋盤）。
2. **衝突檢查與解決（鬼-鬼、鬼-鬼 swap、跟隨衝突）**

   * **Vertex 衝突**：多隻鬼要進入同一格 → 以**穩定優先序**決定誰能進（建議：「距離目標生存者更近者優先；再以 Id 較小者優先」），**後位者改為原地不動**。
   * **Edge（對向交換）衝突**：鬼A 要從 X→Y，同時鬼B 要從 Y→X → **禁止交換**，兩者都**原地不動**（簡化 MAPF 規則）。
   * **跟隨衝突**（X→Y、Z→X 鏈狀追尾）：若導致最終同格或交換，**低優先序者原地不動**。
3. **抓捕判定 #1（鬼主動）**

   * 若**某鬼的最終目標格 = 某生存者當前格** → **觸發抓捕**：

     * 該生存者**被移除**、鬼**進入該格**、鬼隊 +1 分。
     * 這筆移動合法，結束後不會同格。
4. 應用所有合法移動，更新棋盤。
5. 若場上已無生存者 → 遊戲立即結束（鬼勝）。

## B. 生存者 Phase（同步決策與移動）

1. **所有存活生存者同時選一步目標格**（基於鬼 Phase 後的棋盤）。
2. **衝突檢查與解決（生-生、edge/swap、跟隨）**

   * **生-生同格衝突**：多人生要進同一格 → 以**穩定優先序**（建議固定 Id 由小到大）決定**唯一能進者**，其餘**原地不動**。
   * **Edge swap**：兩名生存者互換 → **禁止**，兩者**原地不動**。
   * **跟隨衝突**：同上，低優先序者**原地**。
   * **對鬼佔據格**：若目標格目前有鬼 → **允許嘗試**，但將觸發抓捕（見下一步）。
3. **逃脫判定**

   * 最終停於出口格者 → **立刻逃脫**、自場上移除、生存者隊 +1 分。
4. **抓捕判定 #2（生動入鬼格）**

   * 過了逃脫判定後，若仍有生存者**最終停在某鬼所在格** → **觸發抓捕**：

     * 該生存者**被移除**、鬼**保持原位**、鬼隊 +1 分。
5. 若場上無生存者 → 立即結束（鬼勝）。
6. 若 t==100 且仍有任一生存者未逃 → 鬼勝；否則進下一回合。

> 關鍵：**抓捕是“嘗試進入對方所在格”的事件**，移除被抓的一方後，**終態**沒有同格，完全符合「不可同格」。

---

# AI 決策（在不可同格下的調整）

## 生存者

* 目標：最近出口（Chebyshev）。
* 評分函式（挑 8 鄰居合法步）：

  ```
  score(n) = α * (-dist_to_exit(n))
           + β * min_dist_to_any_killer(n)
           + γ * (-潛在同隊衝突風險(n))
  ```

  建議係數：α=1.0, β=0.6, γ=0.2。
* **非法步**（越界、被同隊預計占用且自己優先序較低、Edge swap、跟隨造成衝突）→ 捨棄；若全非法 → 原地。

## 鬼

* 目標：最近生存者（同距離取 Id 小者）。
* 評分：`-dist_to_target(n)`；同距離 tie-breaker 可固定方向序或偏向減少 max(|dx|,|dy|) 的方向。
* 同隊衝突與 swap 依上節規則處理。

---

# 起始與間距（沿用但提醒「不可同格」）

* 初始隨機放置時，務必檢查所有單位互不重疊，並滿足：

  * `D_exit_min`（建議 8）
  * `D_enemy_min`（建議 4）
  * `D_ally_min`（建議 2）
* 若抽樣上限仍無解 → 逐步放寬距離直到可行。

---

# 事件與日誌（驗證不可同格）

* 於每個 Phase 結束後斷言：**棋盤上無任意同格**。
* Log 需標示：

  * 決策步（含被拒絕原因：越界/同隊衝突/edge-swap）
  * 抓捕事件（誰嘗試進入誰、在哪個 Phase）
  * 逃脫事件與比分
* 可視化：50×50 ASCII/PNG，每回合一幀即可驗證不重疊。

---

# 極簡偽碼（更新版）

```text
for t in 1..100:
  # Killer Phase
  K_moves = plan_killers(state)
  K_moves = resolve_conflicts_no_overlap(K_moves)   # 禁同格+禁swap
  apply_moves(state, K_moves)
  resolve_kill_captures_by_killers(state)           # 鬼嘗試進入生 -> 生移除, 鬼佔格
  assert no_overlaps(state)
  if no_survivor: break

  # Survivor Phase
  S_moves = plan_survivors(state)
  S_moves = resolve_conflicts_no_overlap(S_moves)    # 禁同格+禁swap
  apply_moves(state, S_moves)
  resolve_escapes(state)                             # 先逃脫
  resolve_kill_captures_by_tiles(state)              # 生在鬼格 -> 生移除, 鬼不動
  assert no_overlaps(state)
  if no_survivor: break

# 終局：若提前清空 -> 鬼勝；若 t=100 且仍有人存活 -> 鬼勝；否則下一回合
```

---

如果這版 OK，我可以下一步直接給你 **C# 可跑的 POC（資料模型、規則引擎、衝突解算器、單元測試）**，已內建「不可同格」與「edge-swap 禁止」的 MAPF 簡化規則，方便你後續擴充到障礙與 A\*。要我直接開寫嗎？


Question : 
接著我想要討論生存者的策略，幫我分析 DFS 或是 BFS 演算法跟我們目前的生存者逃脫策略有相關嗎? 如果不相關的話選哪一種演算法比較好呢?

Answer : 
結論先說：**DFS 幾乎不相關、BFS 有部分相關但不夠用**。
在我們這個「動態對手 + 同格不可重疊 + 八方向一步」的 POC 裡，**最佳做法是：把 BFS 當作每回合的「距離/風險場 (distance/threat field)」建構工具，再用打分決策**；若之後加障礙或權重，再升級為 **A\***（或 D\* Lite / LPA\* 等增量路徑規劃）。

---

# 為什麼 DFS 不適合？

* **DFS 不保證最短路徑**，而逃生目標是「盡快到出口、還要避鬼」；DFS 可能走很深的繞路。
* DFS 對「動態威脅」沒有天然優勢；它偏探索，不是規劃最短／最安全路徑的演算法。

# BFS 的「部分相關」

* 在**無權重、每步成本=1**（我們採 Chebyshev、一步=1）下，**BFS 可給你到出口的最短步數**（若暫時忽略鬼與隊友阻擋）。
* 但我們的環境是**動態與多智能體**：鬼會移動、同隊會卡位、不可同格與禁止交換（edge-swap）——**單純 BFS 路徑常常下個回合就失效**。

---

# 建議的生存者決策（簡單好用、可直接落地）

## 1) 每回合重建兩張場（用 BFS 做多源擴散）

* **Exit Distance Field `D_exit`**：以所有出口為起點做**多源 BFS**，得到每格到最近出口的最短步數。
* **Killer Distance/Threat Field `D_killer`**：以所有鬼為起點做**多源 BFS**，得到每格離最近鬼的最短步數，或進一步做**威脅場**（距離越近分數越低）。

  * 50×50 規模，兩次 BFS 每回合跑一次非常輕、省心，也容易除錯。

## 2) 一步式打分（我的 POC 建議）

對於生存者「當前格的 8 個候選步」做打分，挑最高分那步（若皆非法則原地）：

```
score(cell) = α * (- D_exit[cell])
            + β *  f_safety(D_killer[cell])
            + γ *  f_flow(cell)   // 減少與隊友衝突、避免swap
```

* `f_safety`：可以用 `+D_killer[cell]`（離鬼越遠越好），或用非線性衰減如 `log(1 + D_killer)`/ 分段懲罰（例如距離≤2 給巨大負分）。
* `f_flow`：對「被多名生存者同時瞄準」的格、或會觸發 edge-swap 的格，給懲罰，降低卡位機率。
* **參數建議**（可 A/B 測）：`α=1.0, β=0.8~1.2, γ=0.1~0.3`。
* **好處**：穩定、可解釋、成本低、面對動態對手時**每回合重算、自然再規劃**。

> 小技巧：你也可以直接把 `score = - D_exit + λ * D_killer`（最簡版），先跑通驗證，再逐步加 flow 與懲罰。

## 3) 為何不直接用「BFS 路徑」？

* 直接用 BFS 算一條到出口的最短路，**下回合可能被鬼/隊友封死**；你又得整條重算，還要處理路徑失效與 swap 衝突。
* 用「**場 + 一步打分**」每回合**局部決策**，在動態環境更穩定。

---

# 什麼時候要用 A\* / D\*？

* **當地圖加入障礙/牆**，且你希望路線更平滑、更少回頭：

  * 用 **A\***（啟發式=Chebyshev 距離）比 BFS 更快找最短路。
  * 若鬼/障礙會改變或地圖很大、你不想每回合重算全圖：用 **D\* Lite / LPA\*** 這類**增量式**路徑規劃更有效率。
* **多智能體協作**（多名生存者彼此避讓）：可考慮 **Cooperative A\*** 或 **CBS (Conflict-Based Search)**；但 POC 階段不必，成本高很多。

---

# 實作建議（落到你現在的專案）

1. **每回合**先用兩次多源 BFS 產生 `D_exit` 與 `D_killer`。
2. 生存者逐一對 8 鄰居做 `score`（過濾越界/同隊占用/edge-swap 會觸發者）。
3. 以最高分為目標步；若衝突，按你定的 tie-breaker（Id 小者先）保留，其他人原地。
4. 紀錄「因流量/衝突被擋」的次數，之後可用來調整 `γ` 或加入「繞行懲罰折減」。

---

# TL;DR

* **DFS：不適合。**
* **BFS：適合作為「距離/威脅場」的建構工具**，每回合重算，再用**一步打分**做動態決策。
* **若有障礙或要更聰明**，升級為 **A\***（甚至 D\* Lite/LPA\*）。
* 50×50 的規模下，這套法簡單、快、穩、好驗證，超適合 POC。

如果你想，我可以直接給你 **C# 的 `BuildDistanceFieldByBFS(...)` 與 `ChooseBestStep(...)`** 兩個方法範本，嵌進你現有的回合引擎就能跑。


Question : 
我想要先針對 DFS 以及 BFS 演算法在此次需求上的應用做進一步探討，我想了解
1、為甚麼 DFS 不保證最短路徑?
2、為甚麼 BFS 部分相關，考量的點你有提到 「環境是動態與多智能體」，我可以理解成因為計算的結果並不能重複利用嗎?

Answer : 
好，我幫你把這兩點拆開來講，並且跟你的 **鬼抓人生存者策略需求**做對照。

---

## 1. 為什麼 DFS 不保證最短路徑？

* **DFS 的特性**

  * DFS（深度優先搜尋）會沿著一條路徑「一路走到底」，直到不能走或到達目標，再回頭換另一條路。
  * 它的重點是**探索完整路徑空間**，而不是優先尋找「步數最少的路徑」。
  * 舉例：如果出口距離只有 3 步，但 DFS 先走了一條 20 步的深路，找到的第一個解就是 20 步，DFS 並不會自動保證「回頭再找短的」。

* **應用到本需求**

  * 生存者要「逃脫」其實是要最少步數到出口（同時要安全），DFS 會走出「可能能逃，但繞遠路」的解，這不符需求。
  * 所以 DFS 更適合用在「是否存在一條路」的驗證，而不是「找到最短或最佳路徑」。

---

## 2. 為什麼 BFS 部分相關？

* **BFS 的特性**

  * BFS（廣度優先搜尋）是「分層往外擴展」，遇到目標時，保證這條路徑是**最短步數解**。
  * 所以如果我們把出口當作目標，BFS 算出來的步數距離就是「到出口的最短路」。

* **為什麼只「部分相關」**

  * 你的環境是 **動態 + 多智能體**：

    1. **動態性**：鬼每回合都在移動，BFS 算的路徑下一回合就可能失效（出口還在，但路線的「安全性」變了）。
    2. **多智能體**：生存者之間「不能同格」，鬼也在移動堵路。這代表 BFS 得出的路線不一定能實際執行（例如下一步被隊友卡住，或鬼剛好走進來）。

* **你理解的「計算結果不能重複利用」是對的，但更精確的說法是**：

  * BFS 計算的「靜態最短路」只對**當前回合靜態環境**有效。
  * 下一回合環境改變（鬼換位置、隊友站位不同），之前的 BFS 結果**失效或需要重算**。
  * 所以在這種需求裡，BFS 常常要「每回合重跑一次」，僅用來提供當下的「最近出口距離」或「離鬼的距離」。

---

## 小結

1. **DFS**：只能回答「有沒有路」，但不能保證「路是不是最短」，所以不符合「生存者要最短、安全逃脫」的需求。
2. **BFS**：可以保證最短路，但只在靜態環境裡有效。在動態多智能體的場景裡，BFS 的結果必須**每回合重算**，否則就不可靠。

---

要不要我接著幫你做一個小範例（用 5x5 地圖 + 鬼/出口的簡單配置），展示 DFS 找到「繞遠路」、BFS 找到「最短路」的差異，並解釋為什麼下一回合就要重算？


Question : 
這邊足夠我了解 BFS 以及 DFS 在本次需求的適用性了，接著我想要往下探討所建議的生存者決策，我需要詳細解說這個部分

Answer : 
太好了，往下我把「生存者決策」拆成可直接實作的幾個模組，涵蓋：距離/威脅場的建構、一步打分的設計、不可同格下的衝突解算、幾個關鍵情境的特別規則、參數調校與效能/測試建議。整體思路：**每回合重算兩張場（出口距離場 + 鬼威脅場），對 8 個鄰居做打分擇優，再進行不可同格的衝突解算**。

---

# 1) 場（Field）建構：兩個多源 BFS

在 50×50 地圖上，兩次多源 BFS 每回合跑一次很輕鬆（O(WH)）。

**D\_exit：出口距離場**

* 以所有出口為起點做多源 BFS，得到每格到最近出口的 Chebyshev 最短步數。
* 代表「**越小越接近出口**」。

**D\_killer：鬼威脅場**

* 以所有鬼為起點做多源 BFS，得到每格到最近鬼的最短步數。
* 代表「**越大越安全**」。

（可選）**T\_margin：安全邊際場**

* 直覺定義：`T_margin(cell) = D_killer[cell] - D_exit[cell]`

  > 正值：我們理論上比鬼更快到這格/穿過此區域；負值：風險較高。
* 可作為打分中額外特徵（見 §2）。

---

# 2) 一步打分（Scoring）——從 8 鄰居挑一步

對當前生存者位置 `p` 的 8 個合法鄰居 `n`（含「原地不動」作為第 9 候選，避免被動撞上衝突）計算：

```
score(n) = α * (- D_exit[n])
         + β *  safety(D_killer[n])
         + γ *  flow_penalty(n)
         + ω *  margin_boost(T_margin[n])
         + φ *  special_rules(n)   // 近身、最後回合、出口相鄰等
```

### 推薦的子函式

* `safety(d)`: 距離越遠分數越高。線性即可，或以「近距離重懲、遠距離平緩」的分段/對數：

  * 例：`safety(d) = { -∞ (d ≤ 1), -C (d = 2), d  (d ≥ 3) }`
* `flow_penalty(n)`: 降低同隊擠壓/卡位。POC 兩種做法擇一：

  1. **簡版**：`flow_penalty = 0`，把衝突完全交給解算器處理（較簡單）。
  2. **改善版**：對「距離最近隊友 ≤ 1 或 2」給小幅負分，降低朝擁擠區移動的傾向。
* `margin_boost(m)`: 將 `T_margin` 拉成分數（正值加分，負值給小懲罰）。
* `special_rules(n)`：幾個對逃脫很有用的微規則（見下段）。

### 推薦係數（起始）

* `α = 1.0`（縮短到出口）
* `β = 1.0`（遠離鬼）
* `γ = 0 ~ 0.2`（POC 先 0，卡位多了再開）
* `ω = 0.3`（安全邊際）
* `φ` 視規則觸發而定（通常是 ± 大值的硬懲罰/加分）

---

# 3) 特別規則（小而關鍵）

這些能讓策略在「近身糾纏」與「最後一跳」時更聰明。

1. **出口優先（可一跳到出口）**

   * 若某候選 `n` 是出口：直接標記為**最高優先**（甚至跳過打分，直接選）。
   * 依我們回合順序：生存者 Phase 結束時先判「逃脫」再判「被捕」，因此**就算出口格上有鬼，也能先逃**。

2. **近身恐懼區（d ≤ 2 強懲）**

   * 若 `D_killer[n] ≤ 2`，給大幅負分避免貼臉；除非 `n` 是出口（則套規則 1）。
   * 這能避免生存者因純粹縮短 `D_exit` 而自殺前進。

3. **最後回合求生（t == 100）**

   * 若能更接近出口（`D_exit[n] < D_exit[p]`），給額外加分；否則嚴懲「原地/遠離出口」。
   * 讓最後回合不保守。

4. **陷阱偵測（單步展望）**

   * 模擬「鬼下一步若朝最近生存者貼近」的局部預測：若 `n` 會導致 `D_killer_next[n] ≤ 1`，對 `n` 加重懲罰。
   * 實作上可不跑全圖，只估「就近的 1\~2 名鬼往你移動一步」的距離。

---

# 4) 不可同格下的衝突解算（Survivors Only）

所有生存者**同時**選好目標後，進行解算以滿足：

* 不可同格（生-生）
* 禁 swap（A→B 與 B→A）
* 禁跟隨鏈造成重疊

**建議流程（穩定 + 易實作）**

1. **為每個生存者提交 `(target_cell, score, id)`**。
2. **按「目標格」分桶**，對每個目標格的申請者：

   * 以 `score` 由高到低排序；若分數相同，以 `id` 由小到大（確保**決定性**）。
   * 允許**第一名**佔用；其他人**退回候補**（預設「原地不動」）。
3. **檢查 edge-swap**：若發生 A: X→Y、B: Y→X

   * **取消兩者移動**（都原地）。
4. **檢查跟隨鏈**（X→Y、Z→X… 形成循環）

   * 由最低分/後序者開始取消，直到消除循環。

> 為了行為更「合理」：步 2 可改用「**競標式分配**（score 高者贏）」而非單靠 id，能減少高分決策被 id 壓掉的隨機性。

---

# 5) 生存者決策的主流程（偽碼）

```text
# 每回合開始（鬼 Phase 已結束）：
D_exit    = MultiSourceBFS(exits)
D_killer  = MultiSourceBFS(killers)
T_margin  = D_killer - D_exit   # 可選

for each survivor S (alive):
  candidates = neighbors8(S.pos) ∪ {S.pos}  # 含原地
  legal = filter_out_of_bounds(candidates)
  # 不要在這裡排除「鬼所在格」，因為允許嘗試，之後會觸發抓捕/先逃脫判定
  # 也不要先排除同隊目標，統一交給解算器

  best = argmax_n in legal of score(n)
  submit_move(S, best, score(best))

# 解算（不可同格、禁 swap/跟隨）
moves = resolve_conflicts_by_bucket_and_no_swap(all_submitted)

# 套用移動
apply_moves(moves)

# 先判逃脫（在出口的直接移除 +1 分），再判「與鬼同格」被捕（移除 +1 分）
resolve_escapes_then_captures()
```

---

# 6) C# 介面／函式切割（範本）

```csharp
// 場建構
int[,] BuildDistanceFieldByBfs(Grid grid, IEnumerable<Point> sources); // Chebyshev
// 打分
double ScoreCell(Point n, DistFields f, LocalContext ctx);
// 生存者決策
MovePlan PlanSurvivorStep(Survivor s, DistFields f, LocalContext ctx);
// 衝突解算
IReadOnlyList<DecidedMove> ResolveNoOverlap(IReadOnlyList<CandidateMove> moves);
// 事件結算
void ResolveEscapesThenCaptures(GameState state);
```

`LocalContext` 可含：回合數 `t`、鄰近鬼資訊（距離≤k 的清單）、鄰近隊友距離等。

---

# 7) 參數調校建議

1. **先最小集**：`score = -D_exit + λ * D_killer`，λ 先從 `1.0` 開始。
2. **觀察行為**：

   * 若過度勇敢→加大近身懲罰（`D_killer ≤ 2` 大懲罰）。
   * 若過度保守→降低 `β` 或提高 `α`；並開啟 `margin_boost`。
   * 若擠在一起卡位→開 `flow_penalty` 或在解算器用「競標分配」。
3. **A/B 測**：以「存活率、平均逃脫時間、卡位次數、近身死亡率」為指標。

---

# 8) 效能與可擴充

* 50×50：兩次 BFS \~ 萬級操作，極快。
* 之後若加入**障礙/牆**，依然可用 BFS（障礙視為不可到達）；若加入**不同地形代價**，可改 **Dijkstra/A\***。
* 若要減少重算：當鬼與出口位置小變化，可做**增量更新**；但 POC 沒必要。

---

# 9) 常見陷阱與對策

* **直線貼近鬼**：純縮小 `D_exit` 會自殺，務必保留「近身懲罰 + 安全邊際」。
* **出口口袋被堵**：加入一次「單步展望預測」懲罰，避免走入死角。
* **同隊卡位**：先用解算器解決，必要時開 `flow_penalty` 或設「**排隊規則**」：距出口更近者優先、後位者暫緩。
* **非決定性重跑**：所有 tie-break（同分、同距、排序）都以固定規則（id/方向序）確保可重現。

---

## TL;DR

* **每回合**用兩張多源 BFS 建「出口距離場」與「鬼威脅場」。
* 用 **一步打分**從 8 鄰居（含原地）挑一步，內含**近身懲罰／安全邊際／出口優先**等微規則。
* 移動後用**不可同格解算器**處理衝突（競標式分配 + 禁 swap/跟隨），再依規則**先逃脫、後被捕**結算。
* 參數先簡單、指標化 A/B 調整；POC 容易跑、容易驗證，也能平滑升級到 A\*/Dijkstra/增量規劃。

如果你要，我可以下一步直接給你 **C# 可貼上的 `BuildDistanceFieldByBfs` 與 `PlanSurvivorStep` 的初版**（含幾個可切換的 `special_rules`），讓你立刻跑通一輪模擬。


Question : 
我想先確認一下這個生存者策略我理解的對不對，所以我們要做的事情是
Step 1、先用 BFS 計算兩個結果，生存者與出口路線距離、鬼與生存者路線距離
Step 2、使用 Scoring 演算法來挑選合適的路線 ， 這邊我想要多探討的是 BFS 得出來的結果會是只有2 個路線嗎?  還是我的理解有誤，其實是多個路線，然後再透過 Step2 的評分決定該走哪一個方位?
Step 3 、特別規則增加 Scoring 的權重，影響生存者在特殊情況的決策

Answer : 
你的理解大致正確 👍，但我幫你釐清一個關鍵誤解：

BFS 在這裡**不是用來直接產生「路線」**，而是用來產生一張「距離場 (distance field)」或「威脅場 (threat field)」。
換句話說，BFS 的結果**不是兩條路**，而是**整張地圖上每個格子對出口/鬼的最短距離**。

---

## 拆解你的三步驟

### Step 1：BFS 計算結果

* **出口距離場 D\_exit**：對每個格子算「到最近出口的步數」。
* **鬼距離場 D\_killer**：對每個格子算「到最近鬼的步數」。

> 所以結果是兩張 50×50 的矩陣，不是「兩條路」。
> 它提供每個位置的「走到出口還要幾步」以及「離鬼有多遠」。

---

### Step 2：Scoring 演算法

* 當生存者在格子 `p`，我們要考慮它的 **候選移動集合**：
  `neighbors8(p)` + `p`（原地不動）。
* 對於這些候選格 `n`，查表：

  * `D_exit[n]` = n 到出口的距離
  * `D_killer[n]` = n 離鬼的距離
* 然後用評分公式：

  ```
  score(n) = α * (-D_exit[n]) + β * D_killer[n] + ... + 特別規則
  ```
* 取分數最高的 `n` 作為移動方向。

> 這代表 BFS 的距離場只是**輸入特徵**，最後決定走哪裡是由 scoring 來做。
> 不是 BFS 自己給出兩條/多條路，而是 scoring 在每回合看 8 個方向，用 BFS 結果計算分數。

---

### Step 3：特別規則

* 在某些情境直接覆蓋或修改分數，例如：

  * **出口相鄰** → 優先逃脫，不計算其他分數。
  * **距離鬼 ≤ 2** → 大幅扣分，避免自殺。
  * **最後一回合** → 優先靠近出口。

這些規則就是你說的「增加 Scoring 的權重」。

---

## 舉例（簡單 5×5）

假設出口在 (4,4)，鬼在 (0,4)，生存者在 (2,2)

* BFS 結果（出口場 D\_exit）：
  (2,2) → 到出口 4 步
  (2,3) → 3 步
  (3,2) → 3 步
* BFS 結果（鬼場 D\_killer）：
  (2,2) → 離鬼 4 步
  (2,3) → 離鬼 3 步
  (3,2) → 離鬼 5 步

Scoring：

* (2,3)：出口近，但鬼也近 → 分數中等
* (3,2)：出口也近，鬼更遠 → 分數最高
  所以生存者會往 (3,2) 走。

---

✅ 所以總結：

* **Step 1**：BFS 給你「距離場」，不是「路線」。
* **Step 2**：生存者只考慮自己能走的一步，利用 BFS 的結果給分，挑最高分。
* **Step 3**：規則在特殊情況下修正/覆蓋分數，讓決策更合理。

---

要不要我幫你畫一個 **小的示意圖 (5×5)**，直接標出 BFS 的距離場，然後跑一輪 scoring，把決策過程圖解給你看？


Question : 
在確認一次理解正不正確
1、所以意思是 BFS 我們用來計算的是 Chebyshev distance ，得出所有距離，而決定生存者移動的則是 Scoring ?
2、所以意思是在這個演算法的邏輯下，生存者其實是看的到鬼在地圖上的位置的?

Answer : 
完全正確，你的理解方向對了 👍
我幫你再釐清一下細節，讓邏輯更嚴謹：

---

## 1. BFS 的用途

* 是的，這裡的 **BFS 用來計算 Chebyshev distance**（因為八方向走一步都算 1）。
* BFS 不是算「單一路徑」，而是建出一張**距離場**：對地圖上每一格，算出

  * 到最近出口的距離 `D_exit`
  * 到最近鬼的距離 `D_killer`
* **移動決策不是 BFS 給的，而是 Scoring 給的**。

  * Scoring 會查這兩張距離場，對每個候選步（8 個方向 + 原地）計算分數，然後挑最好的。

---

## 2. 生存者是否「看得到鬼」

* 在這個演算法設定裡，**是的**，生存者能「知道鬼在哪裡」，因為我們需要鬼的位置來跑 BFS（計算 `D_killer`）。
* 這代表我們假設 **全知視野**（omniscient vision）：生存者知道所有鬼的位置。

### 為什麼要這樣設計？

* 這是 **POC 版本**的簡化：

  * 方便測試與驗證演算法正確性。
  * 也能比較容易調整參數（α, β, γ 等）。
* 若要更真實模擬 Dead by Daylight，那就要加上 **有限視野 (R\_sight)**：

  * 例如：只有在距離 ≤ 7 格內的鬼才「能被看到」。
  * 那麼 `D_killer` 只能局部建，或是「看不到的鬼」視為「無限遠」。

---

✅ 所以你的理解總結：

1. **BFS 計算 Chebyshev distance**，得到距離場，不是直接給路線。最後移動是 **Scoring** 的工作。
2. 在目前這個設計裡，**生存者是能看到整張地圖上的鬼**（全知），因為我們要用鬼的位置來跑 BFS。如果想模擬更真實，就要改成有限視野版本。

---

要不要我幫你畫個「全知 vs 有限視野」的對比例子（用一張 7×7 小地圖），讓你清楚看到如果有限視野的話，生存者的決策會怎麼不同？

Question : 
在這邊我想要修改一下規則，生存者確實是可以知道出口在哪裡的這個情況全知視野沒有問題，但是在看到鬼的位置時全知視野似乎有點過於強大，所以我打算將可以看到鬼的距離限制在 5 X 5 的範圍內

Answer : 
太好了！把「看鬼」改成 **5×5 可視範圍**（中心包含自己）是很合理的弱化。下面我把規則精確化，並給出演算法怎麼改最穩、最容易落地。

# 視野規則（更新）

* **出口**：仍為全知（位置固定可見）。
* **鬼**：僅在「以生存者為中心的 5×5 區塊」內可見。

  * 形式化：對生存者位置 `p=(x,y)`，可見集合 `V = { q | max(|qx-x|, |qy-y|) ≤ 2 }`。
  * 換句話說：**Chebyshev 距離 ≤ 2** 可見（5×5 窗）。

# 距離/威脅場建構（Step 1 的調整）

我們原本每回合都建兩張場：`D_exit`、`D_killer`。

* `D_exit`：不變（多源 BFS from 所有出口）。
* `D_killer`：**只用「可見鬼」當作 BFS 的起點**。

  * 若看不到任何鬼：把 `D_killer` 視為「極安全」即可（例如用一個大數 `+∞` 或地圖最大距離+1）。

> 這代表：**不可見的鬼不進入威脅場**。生存者會在「未知區域」更傾向往出口走，但我們可以用一些「保守啟發」避免盲撞（見下）。

# Scoring（Step 2）的微調

核心仍是「對 8 鄰居 + 原地」打分，只是 `D_killer` 現在是「**局部威脅**」。

基礎分數仍然：

```
score(n) = α * (- D_exit[n])
         + β * safety(D_killer[n])      // 只會反映視野內鬼
         + γ * flow_penalty(n)
         + ω * margin_boost(D_killer[n] - D_exit[n])
         + φ * special_rules(n)
```

## 建議新增的「有限視野」對策（簡單好用）

1. **近身強懲**（維持）：若 `D_killer[n] ≤ 2`，給大負分；但 `n` 是出口則直接優先逃脫。
2. **未知區域的溫和懲罰**（避免盲撞）：

   * 定義：對於 `n` 的 5×5 區域若**完全沒有可見鬼訊息**，給一個微小負分 `-ε`（例如 `ε=0.1~0.3`），表示「未知有風險但不大」。
   * 好處：看不到鬼時仍以 `D_exit` 為主，但不會過度勇猛。
3. **最近一次看見的鬼（Last-Seen Memory，選配，強烈建議）**：

   * 為每個鬼記錄 `last_seen_pos` 與 `last_seen_time`。
   * 對每個候選 `n`，估計「鬼**可能**的覆蓋半徑」：`R = min(t_now - last_seen_time, R_cap)`（例如 `R_cap=5`），用 **Chebyshev** 往外擴。
   * 若 `n` 落在任一鬼的「**不確定區**」（以 `last_seen_pos` 為中心、半徑 R 的方窗）→ 給懲罰 `-δ`（例如 `δ=0.5~1.0`）。
   * 直覺：鬼越久沒看到，可能在更大區域內；但我們封頂 `R_cap`，避免無限擴張。
4. **單步預測（Local Lookahead, 0/1 步）**：

   * 對「視野內」的鬼，模擬它**下一步**可能朝我靠近（8 向 + 原地）。
   * 若 `n` 在模擬後的鬼可能位置的距離 ≤ 1，給懲罰 `-ζ`（例如 `ζ=1~2`）。
   * 成本極低，但能有效避免走到「下一步被貼臉」的位置。

> 以上 2–4 點都是在「不看不見的鬼」前提下，用**極廉價**的啟發來讓行為更保守、更合理。

# 衝突解算 & 特別規則（Step 3）——不變

* **不可同格**、**禁 swap**、**出口相鄰優先逃脫** 等規則不變。
* 只是現在 scoring 用的 `D_killer` 會因視野而變「稀疏」。

# 參數建議（起手式）

* 距離權重：`α=1.0, β=1.0`
* 安全邊際：`ω=0.3`
* 流量懲罰：`γ=0 ~ 0.2`
* 未知區懲罰：`ε=0.2`
* Last-Seen：`R_cap=5, δ=0.8`
* 一步預測懲罰：`ζ=1.5`
* 近身強懲：`D_killer ≤ 2` 時 `-∞`（或足夠大負分）

# 偽碼補丁（重點行為）

```text
# after Killer Phase
D_exit   = BFS_from_all_exits()
visibleK = { killer k | max(|kx - sx|, |ky - sy|) ≤ 2 for this survivor s }
D_killer = (visibleK is empty) ? +INF_field : BFS_from(visibleK)

# scoring extras:
unknownPenalty(n):
  return -ε if no killer is visible in 5x5 window centered at n else 0

lastSeenPenalty(n):
  for each killer k with last_seen_pos P and last_seen_time τ:
     R = min(t_now - τ, R_cap)
     if max(|nx - Px|, |ny - Py|) ≤ R: return -δ
  return 0

oneStepLookaheadPenalty(n):
  for each visible killer k at K:
     for m in neighbors8(K) ∪ {K}:
        if ChebyshevDist(n, m) ≤ 1: return -ζ
  return 0

score(n) = α*(-D_exit[n]) + β*safety(D_killer[n])
         + γ*flow_penalty(n) + ω*(D_killer[n] - D_exit[n])
         + unknownPenalty(n) + lastSeenPenalty(n) + oneStepLookaheadPenalty(n)
```

> `+INF_field` 可用一個很大的數（例如 10^6）代表「看不到鬼 ⇒ 當下無威脅」，讓 `safety` 不去扣分。

# 行為直覺（你可以預期到的變化）

* 看不到鬼時：生存者會以 `D_exit` 為主線前進，但因未知區小懲罰與 last-seen 陰影，**路徑會更保守**。
* 鬼一旦進入 5×5：`D_killer` 立即收斂，生存者會**大幅避讓**（近身強懲 + 一步預測）。
* 若鬼消失在視野外：威脅場回復「極安全」，但 **last-seen 陰影**仍會短時間維持警戒。

# 測試建議

* 固定種子跑 1000 場，對照「全知 vs 5×5 視野」的：

  * 逃脫率、平均逃脫步數、近身死亡率、卡位次數。
* 調 `ε, δ, ζ`（未知/陰影/預測懲罰）看行為曲線，找你想要的風格（保守/積極）。

---

如果你要，我可以直接給你 **C# 的 `BuildVisibleKillerField`（僅可見鬼的 BFS）、`LastSeenShadow`、以及調好參數的 `ScoreCell`** 版本，照這套邏輯就能跑出有限視野的生存者 AI。


Question : 
到這邊生存者的策略沒有問題，我想要先請你幫我整理一份到目前為止的詳細討論內容 整理的內容我期待要能夠看到我們每一個階段討論的議題，以及修改了哪些規則或策略，最後才會是我們現在的詳細規則

Answer : 
👌 很好，我幫你把我們到目前為止的討論做一份完整整理，分成三個層次：

1. **討論階段回顧** – 我們一步步聊了什麼主題
2. **每階段規則/策略修改** – 哪些規則被補充或修改過
3. **最終整合版詳細規則 (Current Spec)** – 目前的完整遊戲規格

---

# 1. 討論階段回顧

### (A) 初始規則草案

你最先提出了一個簡化版「鬼抓人 POC」的遊戲規則，包括：

* 回合制 100 回合、鬼先行
* 二維平面地圖（可八方向移動）
* 生存者 (1–3) vs 鬼 (2–5)
* 出口 ≥ 2
* 勝負條件（逃脫/捕獲/時間到）
* 生存者策略：往出口走、避鬼
* 鬼策略：追最近生存者

---

### (B) 我補充的完整規則草稿

我幫你整理出更精確的「POC 規格」，包含：

* **座標與距離** (Chebyshev)
* **同格規則** (原本鬼可同格、生可同格，但後續你修改掉)
* **衝突解算** (edge-swap、追尾)
* **事件順序** (鬼先移動捕獲 → 生存者移動逃脫 → 捕獲)
* **起始位置限制** (距出口/敵人最小距離)
* **生存者與鬼的 AI 行為** (用距離/分數決定方向)

---

### (C) 你修改的規則：不可同格

* **所有角色**（鬼-鬼、生-生、生-鬼）都不可同格。
* 我重新定義了「抓捕」：當**嘗試進入對方所在格**時觸發 → 被抓的一方移除 → 所以最終狀態仍不會同格。
* 並修正了衝突解算流程：

  * 鬼-鬼/生-生都要做「競爭 + tie-break」
  * 禁止 swap / 禁止追尾鏈條

---

### (D) 生存者策略：DFS vs BFS

* 我們深入比較：

  * **DFS**：不保證最短路，不適合逃脫需求。
  * **BFS**：能算最短距離，但因為是動態多智能體場景，結果必須每回合重算。
* 結論：用 BFS 來建 **距離場**（出口距離、鬼距離），再配合 **Scoring** 來選一步。

---

### (E) 生存者決策細節 (Scoring)

我提出完整的三步：

1. **BFS 距離場建構** – `D_exit` (出口距離)、`D_killer` (鬼距離)
2. **Scoring 打分** – 對每個候選方向算分：

   ```
   score = α*(-D_exit) + β*D_killer + γ*flow_penalty + ω*margin + 特殊規則
   ```
3. **特別規則** – 出口優先、近身懲罰、最後回合強制前進、一步預測鬼位置

---

### (F) 視野規則修改

* 你覺得「全知視野」對鬼的位置過強，於是修改為：

  * **出口：全知**（生存者永遠知道出口在哪）
  * **鬼：有限視野** → 只能看到自己為中心的 5×5 區域 (Chebyshev 距離 ≤ 2)
* 我幫你調整演算法：

  * `D_exit` 不變（全知）
  * `D_killer` 僅用「可見鬼」跑 BFS
  * 若看不到鬼 → `D_killer` 設為極大值
  * 補強策略：未知區小懲罰、last-seen 陰影、一步預測

---

# 2. 每階段修改過的規則/策略

1. **地圖大小**：從「30×30」改成「預設 50×50」。
2. **同格規則**：從「鬼/生可同格」改為「所有角色不可同格」，抓捕改為「嘗試進入觸發」。
3. **生存者視野**：從「全知」改成「僅出口全知、鬼 5×5 有限視野」。
4. **策略演算法**：從「直覺往出口走」→「BFS + Scoring → 加上特別規則 → 有限視野版」。

---

# 3. 最終詳細規則 (Current Spec)

### 0. 地圖與距離

* 尺寸：預設 50×50，日後可擴大。
* 移動：八方向 + 原地，每步成本 1（Chebyshev）。
* 邊界：不可越界。

### 1. 回合制

* 總共 100 回合。
* 每回合：鬼 Phase → 生存者 Phase。
* **事件順序**：

  * 鬼 Phase：移動 → 抓捕判定（嘗試進入生存者）
  * 生存者 Phase：移動 → 逃脫判定（出口優先） → 抓捕判定（踩到鬼）

### 2. 角色

* 生存者：1–3 人
* 鬼：2–5 人

### 3. 勝利條件

* **生存者隊**：成功逃脫者 +1 分；若全部逃脫則結算分數。
* **鬼隊**：捕獲者 +1 分；若在 100 回合前場上沒生存者，立即勝利；若 100 回合結束還有生存者未逃脫，也算鬼勝。

### 4. 同格規則

* **所有角色不可同格**。
* 抓捕定義：

  * 鬼移動到生存者所在格 → 生存者移除、鬼得分。
  * 生存者移動到鬼所在格 → 生存者移除、鬼得分。
* 最終棋盤狀態不會有重疊。

### 5. 起始配置

* 生/鬼與出口有最小距離 (`D_exit_min=8`)
* 生/鬼間最小距離 (`D_enemy_min=4`)
* 同隊間最小距離 (`D_ally_min=2`)
* 所有角色出生點互不重疊。

### 6. 生存者策略

* **視野**：

  * 出口：全知
  * 鬼：僅限 Chebyshev ≤ 2 (5×5 區域) 可見
* **BFS 場建構**：

  * `D_exit`: BFS from exits (全知)
  * `D_killer`: BFS from visible killers (有限視野)，若無可見鬼 → 設為極大值
* **Scoring 打分**：

  * 基本公式：

    ```
    score(n) = α*(-D_exit[n]) + β*D_killer[n]
             + γ*flow_penalty(n) + ω*(D_killer[n]-D_exit[n])
             + 特別規則
    ```
  * 特別規則：

    * 出口相鄰 → 優先逃脫
    * D\_killer ≤ 2 → 強懲（除非是出口）
    * 最後回合 → 強制逼近出口
    * Last-seen 陰影 → 曾經看過的鬼留下威脅區
    * 一步預測 → 避免走到鬼下一步可能貼臉的位置

### 7. 鬼策略

* 目標：追最近的生存者（Chebyshev 最近，tie-break by id）。
* 移動：往目標縮短距離的一步；同樣做衝突解算（不可同格/禁 swap）。

### 8. 衝突解算

* **同格目標衝突**：多角色想進同一格 → score 高者贏、其他退回原地。
* **swap 衝突**：兩角色互換位置 → 都原地。
* **跟隨鏈**：循環移動 → 後序者退回原地。

---

✅ 這就是我們目前的完整規則。
它已經足夠寫一個 **POC 模擬器**，可以輸出事件日誌（移動、逃脫、捕獲、比分），並且可以測試「全知 vs 有限視野」的差異。

---

要不要我幫你做一個 **流程圖 (Mermaid)**，把「一個回合的處理流程」圖解清楚（鬼 Phase → 生存者 Phase → 事件判定 → 衝突解算）？


